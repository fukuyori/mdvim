<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>mdvim v0.2.4 - Vim-style Markdown Editor</title>
  <!-- KaTeX CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <!-- Highlight.js CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css">
  <style>
/* „ÉÜ„Éº„ÉûÂÆöÁæ© */
:root, [data-theme="dark"] {
  --bg-primary: #1e1e2e;
  --bg-secondary: #313244;
  --bg-tertiary: #45475a;
  --text-primary: #cdd6f4;
  --text-secondary: #a6adc8;
  --accent: #89b4fa;
  --accent-green: #a6e3a1;
  --accent-yellow: #f9e2af;
  --accent-red: #f38ba8;
  --accent-purple: #cba6f7;
  --border: #585b70;
  /* Ë¶ãÂá∫„Åó„É¨„Éô„É´Âà•„ÅÆËâ≤ */
  --heading-h1: #f38ba8;
  --heading-h2: #fab387;
  --heading-h3: #f9e2af;
  --heading-h4: #a6e3a1;
  --heading-h5: #89b4fa;
  --heading-h6: #cba6f7;
}

[data-theme="light"] {
  --bg-primary: #ffffff;
  --bg-secondary: #f5f5f5;
  --bg-tertiary: #e0e0e0;
  --text-primary: #1a1a1a;
  --text-secondary: #555555;
  --accent: #0066cc;
  --accent-green: #2e7d32;
  --accent-yellow: #f9a825;
  --accent-red: #c62828;
  --accent-purple: #7b1fa2;
  --border: #cccccc;
  /* Ë¶ãÂá∫„Åó„É¨„Éô„É´Âà•„ÅÆËâ≤ */
  --heading-h1: #c62828;
  --heading-h2: #e65100;
  --heading-h3: #f9a825;
  --heading-h4: #2e7d32;
  --heading-h5: #0066cc;
  --heading-h6: #7b1fa2;
}

[data-theme="original"] {
  --bg-primary: #000000;
  --bg-secondary: #1a1a1a;
  --bg-tertiary: #2d2d2d;
  --text-primary: #00ff00;
  --text-secondary: #00cc00;
  --accent: #00ffff;
  --accent-green: #00ff00;
  --accent-yellow: #ffff00;
  --accent-red: #ff0000;
  --accent-purple: #ff00ff;
  --border: #333333;
  /* Ë¶ãÂá∫„Åó„É¨„Éô„É´Âà•„ÅÆËâ≤ */
  --heading-h1: #ff0000;
  --heading-h2: #ff8800;
  --heading-h3: #ffff00;
  --heading-h4: #00ff00;
  --heading-h5: #00ffff;
  --heading-h6: #ff00ff;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'JetBrains Mono', 'Fira Code', 'Source Code Pro', Consolas, monospace;
  background: var(--bg-primary);
  color: var(--text-primary);
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.toolbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.5rem 1rem;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
}

.logo { font-weight: bold; font-size: 1.1rem; color: var(--accent); }

.view-controls button {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 0.4rem 1rem;
  margin: 0 0.2rem;
  cursor: pointer;
  border-radius: 4px;
  font-family: inherit;
  font-size: 0.85rem;
  transition: all 0.2s;
}

.view-controls button:hover { background: var(--border); }
.view-controls button.active { background: var(--accent); color: var(--bg-primary); border-color: var(--accent); }
.view-controls button[id^="btn-theme-"] { padding: 0.4rem 0.6rem; font-size: 1rem; }

#font-size-display {
  color: var(--text-secondary);
  font-size: 0.85rem;
  min-width: 3rem;
  text-align: center;
}

.mode-indicator { display: flex; gap: 1rem; font-size: 0.9rem; align-items: center; }
#vim-mode { color: var(--accent-green); padding: 0.2rem 0.4rem; font-weight: bold; min-width: 60px; text-align: center; font-size: 0.85rem; }
#vim-mode.insert { color: var(--accent); }
#vim-mode.visual { color: var(--accent-yellow); }
#vim-mode.command { color: var(--accent-red); }
#vim-mode.recording { color: var(--accent-purple); }
#vim-mode.edit-mode { color: var(--text-secondary); }
#btn-vim-mode { min-width: 50px; }
#btn-vim-mode.active { background: var(--accent-green); color: var(--bg-primary); }
#cursor-pos { color: var(--text-secondary); }
#macro-indicator { color: var(--accent-purple); font-weight: bold; display: none; }
#macro-indicator.active { display: inline; }

#main-container { flex: 1; display: flex; overflow: hidden; }
.pane { flex: 1; display: flex; overflow: hidden; position: relative; }
#editor-pane { border-right: 1px solid var(--border); flex-direction: column; }
#editor-content { display: flex; flex: 1; overflow: hidden; }

#line-numbers {
  min-width: 3rem;
  background: var(--bg-secondary);
  color: var(--text-secondary);
  text-align: right;
  padding: 0.5rem 0.5rem 0.5rem 0;
  font-size: 0.9rem;
  line-height: 1.5;
  overflow: hidden;
  user-select: none;
  white-space: pre;
}

#line-numbers .line-num {
  display: block;
}

#line-numbers .heading-h1 { color: var(--heading-h1); font-weight: bold; }
#line-numbers .heading-h2 { color: var(--heading-h2); font-weight: bold; }
#line-numbers .heading-h3 { color: var(--heading-h3); font-weight: bold; }
#line-numbers .heading-h4 { color: var(--heading-h4); font-weight: bold; }
#line-numbers .heading-h5 { color: var(--heading-h5); font-weight: bold; }
#line-numbers .heading-h6 { color: var(--heading-h6); font-weight: bold; }

#editor-wrapper {
  flex: 1;
  position: relative;
  overflow: hidden;
}

#editor {
  width: 100%;
  height: 100%;
  background: var(--bg-primary);
  color: var(--text-primary);
  border: none;
  padding: 0.5rem;
  font-family: inherit;
  font-size: 0.95rem;
  line-height: 1.5;
  resize: none;
  outline: none;
  overflow: auto;
  white-space: pre;
  tab-size: 4;
  caret-color: transparent;
}

#editor.insert-mode {
  caret-color: var(--accent);
}

#cursor-overlay {
  position: absolute;
  pointer-events: none;
  background: var(--accent-green);
  opacity: 0.8;
  z-index: 10;
}

#cursor-overlay.insert {
  width: 2px !important;
  background: var(--accent);
  opacity: 1;
}

#cursor-overlay.visual {
  background: var(--accent-yellow);
}

#cursor-overlay.command {
  display: none;
}

@keyframes blink {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 0.3; }
}

#cursor-overlay.blink {
  animation: blink 1s ease-in-out infinite;
}

#preview-pane { 
  background: var(--bg-primary); 
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#preview-content { 
  flex: 1;
  overflow: auto;
  padding: 1.5rem; 
}

#preview-content h1 { font-size: 2rem; margin: 1rem 0 0.5rem; color: var(--heading-h1); border-bottom: 2px solid var(--border); padding-bottom: 0.3rem; }
#preview-content h2 { font-size: 1.6rem; margin: 1rem 0 0.5rem; color: var(--heading-h2); }
#preview-content h3 { font-size: 1.3rem; margin: 0.8rem 0 0.4rem; color: var(--heading-h3); }
#preview-content h4 { margin: 0.6rem 0 0.3rem; color: var(--heading-h4); }
#preview-content h5 { margin: 0.6rem 0 0.3rem; color: var(--heading-h5); }
#preview-content h6 { margin: 0.6rem 0 0.3rem; color: var(--heading-h6); }
#preview-content p { margin: 0.6rem 0; line-height: 1.7; }
#preview-content ul, #preview-content ol { margin: 0.5rem 0; padding-left: 1.5rem; }
#preview-content li { margin: 0.3rem 0; }
#preview-content code { background: var(--bg-secondary); padding: 0.15rem 0.4rem; border-radius: 3px; font-size: 0.9em; }
#preview-content pre { background: var(--bg-secondary); padding: 1rem; border-radius: 6px; overflow-x: auto; margin: 0.8rem 0; line-height: 1.4; }
#preview-content pre code { background: none; padding: 0; line-height: 1.4; display: block; }

/* MermaidÂõ≥„ÅÆ„Çπ„Çø„Ç§„É´ */
#preview-content .mermaid {
  background: var(--bg-secondary);
  padding: 1rem;
  border-radius: 6px;
  margin: 0.8rem 0;
  text-align: center;
  overflow-x: auto;
}

#preview-content .mermaid svg {
  max-width: 100%;
  height: auto;
}

/* Êäò„ÇäÁï≥„ÅøÔºàdetailsÔºâ„ÅÆ„Çπ„Çø„Ç§„É´ */
#preview-content details.collapsible {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 6px;
  margin: 0.8rem 0;
  overflow: hidden;
}

#preview-content details.collapsible summary {
  background: var(--bg-tertiary);
  padding: 0.6rem 1rem;
  cursor: pointer;
  font-weight: bold;
  user-select: none;
  list-style: none;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

#preview-content details.collapsible summary::-webkit-details-marker {
  display: none;
}

#preview-content details.collapsible summary::before {
  content: "‚ñ∂";
  font-size: 0.8em;
  transition: transform 0.2s;
}

#preview-content details.collapsible[open] summary::before {
  transform: rotate(90deg);
}

#preview-content details.collapsible summary:hover {
  background: var(--border);
}

#preview-content details.collapsible .details-content {
  padding: 1rem;
  border-top: 1px solid var(--border);
}

#preview-content details.collapsible .details-content > :first-child {
  margin-top: 0;
}

#preview-content details.collapsible .details-content > :last-child {
  margin-bottom: 0;
}

/* „Éó„É¨„Éì„É•„ÉºË¶ãÂá∫„ÅóÊäò„ÇäÁï≥„Åø„Çπ„Çø„Ç§„É´ */
#preview-content h1,
#preview-content h2,
#preview-content h3,
#preview-content h4,
#preview-content h5,
#preview-content h6 {
  position: relative;
  transition: opacity 0.2s;
}

#preview-content .fold-indicator {
  font-size: 0.7em;
  margin-right: 0.5rem;
  opacity: 0.5;
  transition: transform 0.2s, opacity 0.2s;
  display: inline-block;
}

#preview-content h1:hover .fold-indicator,
#preview-content h2:hover .fold-indicator,
#preview-content h3:hover .fold-indicator,
#preview-content h4:hover .fold-indicator,
#preview-content h5:hover .fold-indicator,
#preview-content h6:hover .fold-indicator {
  opacity: 1;
}

#preview-content .folded .fold-indicator {
  transform: rotate(-90deg);
}

#preview-content .heading-hidden {
  display: none !important;
}

/* „Éó„É¨„Éì„É•„Éº„Ç≥„É≥„Éà„É≠„Éº„É´„Éê„Éº */
#preview-controls {
  display: flex;
  gap: 0.5rem;
  padding: 0.5rem;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

#preview-controls button {
  padding: 0.3rem 0.8rem;
  font-size: 0.8rem;
  background: var(--bg-tertiary);
  color: var(--text-secondary);
  border: 1px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
}

#preview-controls button:hover {
  background: var(--accent);
  color: var(--bg-primary);
  border-color: var(--accent);
}

/* „Ç®„Éá„Ç£„Çø„Ç≥„É≥„Éà„É≠„Éº„É´„Éê„Éº */
#editor-controls {
  display: flex;
  gap: 0.5rem;
  padding: 0.5rem;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  align-items: center;
}

#editor-controls button {
  padding: 0.3rem 0.8rem;
  font-size: 0.8rem;
  background: var(--bg-tertiary);
  color: var(--text-secondary);
  border: 1px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
}

#editor-controls button:hover {
  background: var(--accent);
  color: var(--bg-primary);
  border-color: var(--accent);
}

#editor-controls button.active {
  background: var(--accent-green);
  color: var(--bg-primary);
  border-color: var(--accent-green);
}

#editor-controls #vim-mode {
  /* „É¢„Éº„ÉâË°®Á§∫ */
}

#editor-controls #cursor-pos {
  color: var(--text-secondary);
  font-size: 0.85rem;
  margin-right: auto;
}

#editor-controls #macro-indicator {
  color: var(--accent-red);
  font-weight: bold;
  font-size: 0.8rem;
  display: none;
}

#editor-controls #macro-indicator.active {
  display: inline;
  animation: blink 1s infinite;
}

/* ÁõÆÊ¨°„Éë„Éç„É´ */
#toc-pane {
  width: 200px;
  min-width: 150px;
  max-width: 300px;
  background: var(--bg-secondary);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  transition: width 0.2s, min-width 0.2s;
}

#toc-pane.collapsed {
  width: 0;
  min-width: 0;
  border-right: none;
}

#toc-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem;
  background: var(--bg-tertiary);
  border-bottom: 1px solid var(--border);
  font-weight: bold;
  font-size: 0.85rem;
  color: var(--text-primary);
}

#toc-header button {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.2rem 0.4rem;
  font-size: 0.8rem;
}

#toc-header button:hover {
  color: var(--accent);
}

#toc-content {
  flex: 1;
  overflow-y: auto;
  padding: 0.5rem 0;
}

.toc-item {
  padding: 0.3rem 0.5rem;
  cursor: pointer;
  font-size: 0.85rem;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  border-left: 3px solid transparent;
  transition: all 0.15s;
}

.toc-item:hover {
  background: var(--bg-tertiary);
  color: var(--text-primary);
}

.toc-item.active {
  background: var(--bg-tertiary);
  border-left-color: var(--accent);
  color: var(--text-primary);
}

.toc-item.h1 { padding-left: 0.5rem; color: var(--heading-h1); font-weight: bold; }
.toc-item.h2 { padding-left: 1rem; color: var(--heading-h2); }
.toc-item.h3 { padding-left: 1.5rem; color: var(--heading-h3); }
.toc-item.h4 { padding-left: 2rem; color: var(--heading-h4); }
.toc-item.h5 { padding-left: 2.5rem; color: var(--heading-h5); }
.toc-item.h6 { padding-left: 3rem; color: var(--heading-h6); }

#toc-open-btn {
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-left: none;
  border-radius: 0 4px 4px 0;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.5rem 0.3rem;
  font-size: 0.8rem;
  z-index: 10;
}

#toc-open-btn:hover {
  background: var(--bg-tertiary);
  color: var(--accent);
}

#toc-open-btn.hidden {
  display: none;
}

/* Ë¶ãÂá∫„ÅóË°å„Éè„Ç§„É©„Ç§„Éà */
#heading-highlight {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  overflow: hidden;
  font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
  font-size: 0.95rem;
}

.heading-text-overlay {
  position: absolute;
  white-space: pre;
  font-weight: bold;
}

.heading-text-overlay.h1 { color: var(--heading-h1); }
.heading-text-overlay.h2 { color: var(--heading-h2); }
.heading-text-overlay.h3 { color: var(--heading-h3); }
.heading-text-overlay.h4 { color: var(--heading-h4); }
.heading-text-overlay.h5 { color: var(--heading-h5); }
.heading-text-overlay.h6 { color: var(--heading-h6); }

#preview-content blockquote { border-left: 4px solid var(--accent); padding-left: 1rem; margin: 0.8rem 0; color: var(--text-secondary); font-style: italic; }
#preview-content hr { border: none; border-top: 1px solid var(--border); margin: 1.5rem 0; }
#preview-content a { color: var(--accent); text-decoration: none; }
#preview-content a:hover { text-decoration: underline; }
#preview-content img { max-width: 100%; border-radius: 6px; }
#preview-content table { border-collapse: collapse; margin: 0.8rem 0; width: 100%; }
#preview-content th, #preview-content td { border: 1px solid var(--border); padding: 0.5rem; text-align: left; }
#preview-content th { background: var(--bg-secondary); }

/* KaTeXÊï∞Âºè„Çπ„Çø„Ç§„É´ */
#preview-content .katex-display {
  margin: 1rem 0;
  overflow-x: auto;
  overflow-y: hidden;
}

#preview-content .katex {
  font-size: 1.1em;
}

#preview-content .math-inline {
  display: inline;
}

#preview-content .math-block {
  display: block;
  text-align: center;
  margin: 1rem 0;
}

#preview-content .math-error {
  color: var(--accent-red);
  font-family: monospace;
  font-size: 0.9em;
}

.edit-only #preview-pane { display: none; }
.edit-only #editor-pane { border-right: none; }
.preview-only #editor-pane { display: none; }

#command-line {
  display: flex;
  align-items: center;
  padding: 0.3rem 0.5rem;
  background: var(--bg-secondary);
  border-top: 1px solid var(--border);
}

#command-line.hidden { display: none; }
#command-prefix { color: var(--accent); font-weight: bold; margin-right: 0.3rem; }
#command-input { flex: 1; background: transparent; border: none; color: var(--text-primary); font-family: inherit; font-size: 0.95rem; outline: none; }

#status-bar {
  display: flex;
  justify-content: space-between;
  padding: 0.3rem 1rem;
  background: var(--bg-tertiary);
  font-size: 0.85rem;
  color: var(--text-secondary);
}

.modal {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal.hidden { display: none; }

.modal-content {
  background: var(--bg-secondary);
  padding: 1.5rem;
  border-radius: 8px;
  max-width: 1000px;
  max-height: 85vh;
  overflow: auto;
}

.modal-content h2 { color: var(--accent); margin-bottom: 1rem; text-align: center; }
.help-columns { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1.5rem; }
.help-section h3 { color: var(--accent-yellow); margin-bottom: 0.5rem; font-size: 1rem; }
.help-section ul { list-style: none; }
.help-section li { margin: 0.3rem 0; font-size: 0.85rem; }
kbd { background: var(--bg-tertiary); padding: 0.1rem 0.4rem; border-radius: 3px; border: 1px solid var(--border); font-family: inherit; font-size: 0.85em; }
.modal-content > button { display: block; margin: 1.5rem auto 0; padding: 0.5rem 2rem; background: var(--accent); color: var(--bg-primary); border: none; border-radius: 4px; font-family: inherit; cursor: pointer; font-size: 1rem; }
.new-feature { color: var(--accent-green); font-size: 0.75em; margin-left: 0.3rem; }

@media (max-width: 900px) {
  .help-columns { grid-template-columns: repeat(2, 1fr); }
}
@media (max-width: 600px) {
  .help-columns { grid-template-columns: 1fr; }
  .toolbar { flex-wrap: wrap; gap: 0.5rem; }
}

/* „Çø„Çπ„ÇØ„É™„Çπ„Éà */
.task-list {
  list-style: none;
  padding-left: 0;
}

.task-item {
  display: flex;
  align-items: flex-start;
  gap: 0.5rem;
}

.task-item input[type="checkbox"] {
  margin-top: 0.3rem;
  accent-color: var(--accent);
}

/* GitHub Alerts */
.alert {
  padding: 1rem;
  margin: 1rem 0;
  border-radius: 6px;
  border-left: 4px solid;
}

.alert-title {
  display: block;
  font-weight: bold;
  margin-bottom: 0.5rem;
}

.alert p {
  margin: 0;
}

.alert-note {
  background: rgba(56, 139, 253, 0.1);
  border-color: #388bfd;
}

.alert-note .alert-title {
  color: #388bfd;
}

.alert-tip {
  background: rgba(46, 160, 67, 0.1);
  border-color: #2ea043;
}

.alert-tip .alert-title {
  color: #2ea043;
}

.alert-important {
  background: rgba(130, 80, 223, 0.1);
  border-color: #8250df;
}

.alert-important .alert-title {
  color: #8250df;
}

.alert-warning {
  background: rgba(210, 153, 34, 0.1);
  border-color: #d29922;
}

.alert-warning .alert-title {
  color: #d29922;
}

.alert-caution {
  background: rgba(248, 81, 73, 0.1);
  border-color: #f85149;
}

.alert-caution .alert-title {
  color: #f85149;
}

/* Highlight.js „ÅÆ„Çπ„Çø„Ç§„É´Ë™øÊï¥ */
#preview-content pre code.hljs {
  background: transparent;
  padding: 0;
}

/* Qiita noteË®òÊ≥ï */
.note {
  display: flex;
  padding: 1rem;
  margin: 1rem 0;
  border-radius: 6px;
  gap: 0.75rem;
}

.note-icon {
  font-size: 1.2rem;
  flex-shrink: 0;
}

.note-content {
  flex: 1;
}

.note-content p:first-child {
  margin-top: 0;
  font-weight: bold;
}

.note-content p:last-child {
  margin-bottom: 0;
}

.note-info {
  background: #e6f6e6;
  border-left: 4px solid #55c500;
}

.note-warn {
  background: #fff9e6;
  border-left: 4px solid #ffc800;
}

.note-alert {
  background: #ffe6e6;
  border-left: 4px solid #dd0000;
}

/* „ÉÄ„Éº„ÇØ„ÉÜ„Éº„ÉûÁî® */
[data-theme="dark"] .note-info {
  background: rgba(85, 197, 0, 0.15);
}

[data-theme="dark"] .note-warn {
  background: rgba(255, 200, 0, 0.15);
}

[data-theme="dark"] .note-alert {
  background: rgba(221, 0, 0, 0.15);
}
  </style>
</head>
<body>
  <header class="toolbar">
    <div class="logo">üìù mdvim <span style="font-size: 0.8em; color: var(--accent-green);">v0.2.4</span></div>
    <div class="view-controls">
      <button id="btn-edit" class="active" onclick="setViewMode('edit')">Edit</button>
      <button id="btn-preview" onclick="setViewMode('preview')">Preview</button>
      <button id="btn-split" onclick="setViewMode('split')">Split</button>
      <span style="margin: 0 0.5rem; color: var(--border);">|</span>
      <button id="btn-theme-dark" class="active" onclick="setTheme('dark')">üåô</button>
      <button id="btn-theme-light" onclick="setTheme('light')">‚òÄÔ∏è</button>
      <button id="btn-theme-original" onclick="setTheme('original')">üíª</button>
      <span style="margin: 0 0.5rem; color: var(--border);">|</span>
      <button onclick="VimEditor.decreaseFontSize()" title="Decrease font size">A-</button>
      <span id="font-size-display">100%</span>
      <button onclick="VimEditor.increaseFontSize()" title="Increase font size">A+</button>
    </div>
  </header>
  
  <main id="main-container" class="split-view">
    <div id="toc-pane">
      <div id="toc-header">
        <span>Headings</span>
        <button id="toc-toggle" onclick="VimEditor.toggleToc()" title="Close headings">‚óÄ</button>
      </div>
      <div id="toc-content"></div>
    </div>
    <button id="toc-open-btn" class="hidden" onclick="VimEditor.toggleToc()" title="Open headings">‚ñ∂</button>
    <div id="editor-pane" class="pane">
      <div id="editor-controls">
        <span id="vim-mode">NORMAL</span>
        <span id="cursor-pos">1:1</span>
        <span id="macro-indicator">‚óèREC</span>
        <button id="btn-vim-mode" onclick="VimEditor.toggleVimMode()" title="Toggle VIM/NOVIM mode">NOVIM</button>
      </div>
      <div id="editor-content">
        <div id="line-numbers"></div>
        <div id="editor-wrapper">
          <textarea id="editor" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
          <div id="cursor-overlay"></div>
        </div>
      </div>
    </div>
    <div id="preview-pane" class="pane">
      <div id="preview-controls">
        <button onclick="VimEditor.foldAllHeadings()" title="Collapse all">‚ñ∂ Collapse All</button>
        <button onclick="VimEditor.unfoldAllHeadings()" title="Expand all">‚ñº Expand All</button>
      </div>
      <div id="preview-content"></div>
    </div>
  </main>
  
  <div id="command-line" class="hidden">
    <span id="command-prefix">:</span>
    <input type="text" id="command-input">
  </div>
  
  <input type="file" id="file-input" accept=".md,.txt,.markdown" style="display: none;">
  
  <footer id="status-bar">
    <span id="file-name">Untitled</span>
    <span id="file-status"></span>
    <span id="help-hint">Press ? for help</span>
  </footer>
  <div id="help-modal" class="modal hidden">
    <div class="modal-content">
      <h2>‚å®Ô∏è Keybindings Help</h2>
      <div class="help-columns">
        <div class="help-section">
          <h3>Mode Switch</h3>
          <ul>
            <li><kbd>i</kbd> Insert at cursor</li>
            <li><kbd>I</kbd> Insert at line start</li>
            <li><kbd>a</kbd> Insert after cursor</li>
            <li><kbd>A</kbd> Insert at line end</li>
            <li><kbd>o</kbd> New line below</li>
            <li><kbd>O</kbd> New line above</li>
            <li><kbd>v</kbd> Visual mode</li>
            <li><kbd>V</kbd> Visual line mode</li>
            <li><kbd>Esc</kbd> / <kbd>Ctrl+[</kbd> Normal mode</li>
            <li><kbd>:</kbd> Command mode</li>
          </ul>
        </div>
        <div class="help-section">
          <h3>Movement</h3>
          <ul>
            <li><kbd>h</kbd>/<kbd>j</kbd>/<kbd>k</kbd>/<kbd>l</kbd> Left/Down/Up/Right</li>
            <li><kbd>w</kbd>/<kbd>b</kbd> Word forward/backward</li>
            <li><kbd>e</kbd> End of word</li>
            <li><kbd>0</kbd>/<kbd>$</kbd> Line start/end</li>
            <li><kbd>^</kbd> First non-space</li>
            <li><kbd>gg</kbd>/<kbd>G</kbd> File start/end</li>
            <li><kbd>f</kbd><i>x</i> / <kbd>F</kbd><i>x</i> Find <i>x</i> in line</li>
            <li><kbd>t</kbd><i>x</i> / <kbd>T</kbd><i>x</i> Till <i>x</i></li>
            <li><kbd>;</kbd> / <kbd>,</kbd> Repeat f/t</li>
            <li><kbd>%</kbd> Matching bracket</li>
            <li><kbd>{</kbd> / <kbd>}</kbd> Paragraph</li>
            <li><kbd>Ctrl+f</kbd>/<kbd>Ctrl+b</kbd> Page up/down</li>
            <li><kbd>Ctrl+d</kbd>/<kbd>Ctrl+u</kbd> Half page</li>
          </ul>
        </div>
        <div class="help-section">
          <h3>Editing</h3>
          <ul>
            <li><kbd>x</kbd> / <kbd>X</kbd> Delete char</li>
            <li><kbd>dd</kbd> / <kbd>dw</kbd> / <kbd>D</kbd> Delete</li>
            <li><kbd>cc</kbd> / <kbd>cw</kbd> / <kbd>C</kbd> / <kbd>S</kbd> Change</li>
            <li><kbd>yy</kbd> / <kbd>yw</kbd> / <kbd>Y</kbd> Yank</li>
            <li><kbd>p</kbd> / <kbd>P</kbd> Paste</li>
            <li><kbd>u</kbd> / <kbd>Ctrl+r</kbd> Undo/Redo</li>
            <li><kbd>.</kbd> Repeat last edit</li>
            <li><kbd>~</kbd> Toggle case</li>
            <li><kbd>J</kbd> Join lines</li>
            <li><kbd>r</kbd><i>x</i> Replace char</li>
            <li><kbd>>></kbd> / <kbd><<</kbd> Indent</li>
          </ul>
        </div>
        <div class="help-section">
          <h3>Text Objects</h3>
          <ul>
            <li><kbd>diw</kbd> / <kbd>daw</kbd> Delete word</li>
            <li><kbd>ciw</kbd> / <kbd>caw</kbd> Change word</li>
            <li><kbd>di"</kbd> / <kbd>da"</kbd> Delete in "..."</li>
            <li><kbd>di'</kbd> / <kbd>da'</kbd> Delete in '...'</li>
            <li><kbd>di(</kbd> / <kbd>da(</kbd> Delete in (...)</li>
            <li><kbd>di[</kbd> / <kbd>da[</kbd> Delete in [...]</li>
            <li><kbd>di{</kbd> / <kbd>da{</kbd> Delete in {...}</li>
            <li><kbd>di`</kbd> / <kbd>da`</kbd> Delete in `...`</li>
            <li><kbd>yi</kbd><i>x</i> / <kbd>ci</kbd><i>x</i> same pattern</li>
          </ul>
        </div>
        <div class="help-section">
          <h3>Marks</h3>
          <ul>
            <li><kbd>m</kbd><i>a-z</i> Set mark</li>
            <li><kbd>'</kbd><i>a-z</i> Go to mark line</li>
            <li><kbd>`</kbd><i>a-z</i> Go to mark position</li>
            <li><kbd>''</kbd> Go to previous</li>
          </ul>
          <h3 style="margin-top: 1rem;">Macros</h3>
          <ul>
            <li><kbd>q</kbd><i>a-z</i> Start recording</li>
            <li><kbd>q</kbd> Stop recording</li>
            <li><kbd>@</kbd><i>a-z</i> Play macro</li>
            <li><kbd>@@</kbd> Replay last macro</li>
          </ul>
        </div>
        <div class="help-section">
          <h3>Search & Replace</h3>
          <ul>
            <li><kbd>/</kbd><i>pattern</i> Search forward</li>
            <li><kbd>n</kbd> / <kbd>N</kbd> Next/prev result</li>
            <li><kbd>*</kbd> Search word under cursor</li>
            <li><kbd>:s/old/new/</kbd> Replace (line)</li>
            <li><kbd>:%s/old/new/g</kbd> Replace all</li>
            <li><kbd>:n,ms/old/new/g</kbd> Range replace</li>
          </ul>
          <h3 style="margin-top: 1rem;">Commands</h3>
          <ul>
            <li><kbd>:w</kbd> Save dialog</li>
            <li><kbd>:w file.md</kbd> Download as name</li>
            <li><kbd>:e</kbd> Open file</li>
            <li><kbd>:r</kbd> Insert at cursor</li>
            <li><kbd>:new</kbd> New file</li>
            <li><kbd>:ls</kbd> Save to localStorage</li>
            <li><kbd>:q</kbd> / <kbd>:wq</kbd> Quit</li>
            <li><kbd>:set nu/nonu</kbd> Toggle line numbers</li>
            <li><kbd>:theme dark/light/original</kbd> Theme</li>
            <li><kbd>:help</kbd> Show help</li>
          </ul>
        </div>
      </div>
      <div class="help-section" style="margin-top: 1rem;">
        <h3>Math (LaTeX)</h3>
        <ul style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.3rem;">
          <li><kbd>$...$</kbd> Inline math</li>
          <li><kbd>$$...$$</kbd> Block math</li>
          <li><kbd>\frac{a}{b}</kbd> Fraction</li>
          <li><kbd>\sqrt{x}</kbd> Square root</li>
          <li><kbd>x^{2}</kbd> Superscript</li>
          <li><kbd>x_{i}</kbd> Subscript</li>
          <li><kbd>\sum_{i=0}^{n}</kbd> Summation</li>
          <li><kbd>\int_{a}^{b}</kbd> Integral</li>
          <li><kbd>\alpha \beta</kbd> Greek letters</li>
          <li><kbd>\mathbf{x}</kbd> Bold</li>
        </ul>
        <h3 style="margin-top: 1rem;">Tables</h3>
        <ul>
          <li><kbd>| A | B |</kbd> Header row</li>
          <li><kbd>|---|---|</kbd> Separator</li>
          <li><kbd>|:--|</kbd> Left <kbd>|:-:|</kbd> Center <kbd>|--:|</kbd> Right</li>
        </ul>
        <h3 style="margin-top: 1rem;">Mermaid Diagrams</h3>
        <ul>
          <li><kbd>```mermaid</kbd> Start diagram block</li>
          <li><kbd>graph TD</kbd> Flowchart (top-down)</li>
          <li><kbd>graph LR</kbd> Flowchart (left-right)</li>
          <li><kbd>sequenceDiagram</kbd> Sequence</li>
          <li><kbd>classDiagram</kbd> Class</li>
          <li><kbd>gantt</kbd> Gantt chart</li>
          <li><kbd>pie</kbd> Pie chart</li>
        </ul>
        <h3 style="margin-top: 1rem;">Collapsible</h3>
        <ul>
          <li><kbd>:::details Title</kbd> Start collapsible</li>
          <li><kbd>:::</kbd> End collapsible</li>
          <li>Markdown supported inside</li>
        </ul>
        <h3 style="margin-top: 1rem;">Heading Fold</h3>
        <ul>
          <li>Click heading in preview to fold</li>
          <li>Collapse All / Expand All buttons</li>
          <li>Folds until same or higher level</li>
        </ul>
      </div>
      <button onclick="toggleHelp()">Close (Esc)</button>
    </div>
  </div>
  
  <script>

// Vim„Ç®„Éá„Ç£„ÇøÊã°ÂºµÁâà

/**
 * Markdown Parser
 * „Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„ÇíHTML„Å´Â§âÊèõ„Åô„Çã„Éë„Éº„Çµ„Éº
 */
const MarkdownParser = {
  escapeHtml(text) {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  },
  
  parseInline(text) {
    let result = text;
    
    // „Ç§„É≥„É©„Ç§„É≥Êï∞Âºè $...$ „ÇíÂá¶ÁêÜÔºà$$„ÇíÈô§Â§ñÔºâ
    result = result.replace(/(?<!\$)\$(?!\$)([^$\n]+?)\$(?!\$)/g, (match, formula) => {
      return `<span class="math-inline" data-math="${this.escapeHtml(formula)}"></span>`;
    });
    
    result = result.replace(/`([^`]+)`/g, '<code>$1</code>');
    result = result.replace(/~~([^~]+)~~/g, '<del>$1</del>');
    result = result.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    result = result.replace(/__([^_]+)__/g, '<strong>$1</strong>');
    result = result.replace(/\*([^*]+)\*/g, '<em>$1</em>');
    result = result.replace(/_([^_]+)_/g, '<em>$1</em>');
    result = result.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
    result = result.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1">');
    
    // Ëá™Âãï„É™„É≥„ÇØÔºàURL„ÇíËá™Âãï„Åß„É™„É≥„ÇØÂåñÔºâ
    result = result.replace(/(?<!href="|src="|<a[^>]*>)(https?:\/\/[^\s<>"']+)/g, '<a href="$1">$1</a>');
    
    // ÁµµÊñáÂ≠ó„Ç∑„Éß„Éº„Éà„Ç≥„Éº„Éâ
    result = this.parseEmoji(result);
    
    return result;
  },
  
  // ÁµµÊñáÂ≠óÂ§âÊèõ
  parseEmoji(text) {
    const emojiMap = {
      ':smile:': 'üòÑ', ':laughing:': 'üòÜ', ':blush:': 'üòä', ':smiley:': 'üòÉ',
      ':relaxed:': '‚ò∫Ô∏è', ':smirk:': 'üòè', ':heart_eyes:': 'üòç', ':kissing_heart:': 'üòò',
      ':kissing:': 'üòó', ':flushed:': 'üò≥', ':relieved:': 'üòå', ':satisfied:': 'üòÜ',
      ':grin:': 'üòÅ', ':wink:': 'üòâ', ':stuck_out_tongue_winking_eye:': 'üòú',
      ':stuck_out_tongue:': 'üòõ', ':sleeping:': 'üò¥', ':worried:': 'üòü',
      ':frowning:': 'üò¶', ':anguished:': 'üòß', ':open_mouth:': 'üòÆ', ':grimacing:': 'üò¨',
      ':confused:': 'üòï', ':hushed:': 'üòØ', ':expressionless:': 'üòë', ':unamused:': 'üòí',
      ':sweat_smile:': 'üòÖ', ':sweat:': 'üòì', ':weary:': 'üò©', ':pensive:': 'üòî',
      ':disappointed:': 'üòû', ':confounded:': 'üòñ', ':fearful:': 'üò®', ':cold_sweat:': 'üò∞',
      ':persevere:': 'üò£', ':cry:': 'üò¢', ':sob:': 'üò≠', ':joy:': 'üòÇ', ':astonished:': 'üò≤',
      ':scream:': 'üò±', ':tired_face:': 'üò´', ':angry:': 'üò†', ':rage:': 'üò°',
      ':triumph:': 'üò§', ':sleepy:': 'üò™', ':yum:': 'üòã', ':mask:': 'üò∑',
      ':sunglasses:': 'üòé', ':dizzy_face:': 'üòµ', ':imp:': 'üëø', ':smiling_imp:': 'üòà',
      ':neutral_face:': 'üòê', ':no_mouth:': 'üò∂', ':innocent:': 'üòá', ':alien:': 'üëΩ',
      ':heart:': '‚ù§Ô∏è', ':broken_heart:': 'üíî', ':star:': '‚≠ê', ':star2:': 'üåü',
      ':sparkles:': '‚ú®', ':zap:': '‚ö°', ':fire:': 'üî•', ':boom:': 'üí•',
      ':+1:': 'üëç', ':thumbsup:': 'üëç', ':-1:': 'üëé', ':thumbsdown:': 'üëé',
      ':ok_hand:': 'üëå', ':punch:': 'üëä', ':fist:': '‚úä', ':v:': '‚úåÔ∏è',
      ':wave:': 'üëã', ':hand:': '‚úã', ':clap:': 'üëè', ':pray:': 'üôè',
      ':point_up:': '‚òùÔ∏è', ':point_down:': 'üëá', ':point_left:': 'üëà', ':point_right:': 'üëâ',
      ':rocket:': 'üöÄ', ':warning:': '‚ö†Ô∏è', ':x:': '‚ùå', ':white_check_mark:': '‚úÖ',
      ':heavy_check_mark:': '‚úîÔ∏è', ':question:': '‚ùì', ':exclamation:': '‚ùó',
      ':bulb:': 'üí°', ':memo:': 'üìù', ':book:': 'üìñ', ':bookmark:': 'üîñ',
      ':link:': 'üîó', ':wrench:': 'üîß', ':hammer:': 'üî®', ':nut_and_bolt:': 'üî©',
      ':gear:': '‚öôÔ∏è', ':package:': 'üì¶', ':tada:': 'üéâ', ':100:': 'üíØ',
      ':bug:': 'üêõ', ':construction:': 'üöß', ':rotating_light:': 'üö®',
      ':lock:': 'üîí', ':unlock:': 'üîì', ':key:': 'üîë', ':mag:': 'üîç',
      ':email:': 'üìß', ':phone:': 'üì±', ':computer:': 'üíª', ':desktop_computer:': 'üñ•Ô∏è',
      ':folder:': 'üìÅ', ':file_folder:': 'üìÇ', ':clipboard:': 'üìã',
      ':calendar:': 'üìÖ', ':clock:': 'üïê', ':hourglass:': '‚åõ',
      ':sun:': '‚òÄÔ∏è', ':moon:': 'üåô', ':cloud:': '‚òÅÔ∏è', ':umbrella:': '‚òÇÔ∏è',
      ':snowflake:': '‚ùÑÔ∏è', ':coffee:': '‚òï', ':beer:': 'üç∫', ':pizza:': 'üçï'
    };
    
    return text.replace(/:([a-z0-9_+-]+):/g, (match, code) => {
      return emojiMap[match] || match;
    });
  },
  
  parse(markdown) {
    // CRLF„ÇíLF„Å´Ê≠£Ë¶èÂåñ
    markdown = markdown.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    const lines = markdown.split('\n');
    const html = [];
    let inCodeBlock = false;
    let inMathBlock = false;
    let mathBuffer = [];
    let inList = null;
    let tableRows = [];
    let codeLang = '';
    let codeBuffer = [];
    let inDetails = false;
    let detailsBuffer = [];
    let detailsSummary = '';
    let blockquoteBuffer = [];
    let alertType = null;
    let inNote = false;
    let noteType = '';
    let noteBuffer = [];
    
    for (const line of lines) {
      // Êäò„ÇäÁï≥„ÅøÈñãÂßã :::details „Çø„Ç§„Éà„É´
      const detailsStart = line.match(/^:::details\s*(.*)$/);
      if (detailsStart && !inCodeBlock && !inMathBlock) {
        if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
        inDetails = true;
        detailsSummary = detailsStart[1] || 'Ë©≥Á¥∞';
        detailsBuffer = [];
        continue;
      }
      
      // Êäò„ÇäÁï≥„ÅøÁµÇ‰∫Ü :::
      if (line.trim() === ':::' && inDetails && !inCodeBlock && !inMathBlock) {
        const innerHtml = this.parse(detailsBuffer.join('\n'));
        html.push(`<details class="collapsible"><summary>${this.parseInline(detailsSummary)}</summary><div class="details-content">${innerHtml}</div></details>`);
        inDetails = false;
        detailsBuffer = [];
        detailsSummary = '';
        continue;
      }
      
      // Êäò„ÇäÁï≥„ÅøÂÜÖÈÉ®
      if (inDetails) {
        detailsBuffer.push(line);
        continue;
      }
      
      // Qiita noteË®òÊ≥ïÈñãÂßã :::note [info|warn|alert]
      const noteStart = line.match(/^:::note\s*(info|warn|alert)?$/i);
      if (noteStart && !inCodeBlock && !inMathBlock && !inNote) {
        if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
        inNote = true;
        noteType = (noteStart[1] || 'info').toLowerCase();
        noteBuffer = [];
        continue;
      }
      
      // Qiita noteÁµÇ‰∫Ü :::
      if (line.trim() === ':::' && inNote && !inCodeBlock && !inMathBlock) {
        const innerHtml = this.parse(noteBuffer.join('\n'));
        const noteIcons = { 'info': '‚úÖ', 'warn': '‚ö†Ô∏è', 'alert': 'üö´' };
        html.push(`<div class="note note-${noteType}"><span class="note-icon">${noteIcons[noteType]}</span><div class="note-content">${innerHtml}</div></div>`);
        inNote = false;
        noteBuffer = [];
        noteType = '';
        continue;
      }
      
      // noteÂÜÖÈÉ®
      if (inNote) {
        noteBuffer.push(line);
        continue;
      }
      
      // „Ç≥„Éº„Éâ„Éñ„É≠„ÉÉ„ÇØ
      if (line.startsWith('```')) {
        if (inCodeBlock) {
          // Mermaid„Éñ„É≠„ÉÉ„ÇØ„ÅÆÂ†¥Âêà
          if (codeLang === 'mermaid') {
            const mermaidCode = codeBuffer.join('\n');
            html.push(`<div class="mermaid">${mermaidCode}</div>`);
          } else {
            // „Ç≥„Éº„Éâ„Éê„ÉÉ„Éï„Ç°„ÇíÁµêÂêà„Åó„Å¶‰∏ÄÂ∫¶„Å´Âá∫Âäõ
            html.push(`<pre><code class="language-${codeLang}">${codeBuffer.join('\n')}</code></pre>`);
          }
          codeBuffer = [];
          inCodeBlock = false;
          codeLang = '';
        } else {
          codeLang = line.slice(3).trim() || 'text';
          inCodeBlock = true;
        }
        continue;
      }
      
      if (inCodeBlock) {
        if (codeLang === 'mermaid') {
          codeBuffer.push(line);
        } else {
          codeBuffer.push(this.escapeHtml(line));
        }
        continue;
      }
      
      // Êï∞Âºè„Éñ„É≠„ÉÉ„ÇØ $$...$$ 
      if (line.trim() === '$$') {
        if (inMathBlock) {
          const formula = mathBuffer.join('\n');
          html.push(`<div class="math-block" data-math="${this.escapeHtml(formula)}"></div>`);
          mathBuffer = [];
          inMathBlock = false;
        } else {
          if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
          inMathBlock = true;
        }
        continue;
      }
      
      // 1Ë°å„ÅÆÊï∞Âºè„Éñ„É≠„ÉÉ„ÇØ $$...$$
      const singleLineMath = line.match(/^\$\$(.+)\$\$$/);
      if (singleLineMath) {
        if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
        html.push(`<div class="math-block" data-math="${this.escapeHtml(singleLineMath[1])}"></div>`);
        continue;
      }
      
      if (inMathBlock) {
        mathBuffer.push(line);
        continue;
      }
      
      // Ë¶ãÂá∫„Åó
      const headingMatch = line.match(/^(#{1,6})\s+(.+)$/);
      if (headingMatch) {
        if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
        const level = headingMatch[1].length;
        html.push(`<h${level}>${this.parseInline(headingMatch[2])}</h${level}>`);
        continue;
      }
      
      // Ê∞¥Âπ≥Á∑ö
      if (/^(---|\*\*\*|___)$/.test(line.trim())) {
        if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
        html.push('<hr>');
        continue;
      }
      
      // ÂºïÁî®ÔºàË§áÊï∞Ë°åÂØæÂøú + GitHub AlertsÔºâ
      if (line.startsWith('>')) {
        if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
        if (tableRows.length > 0) { html.push(this.parseTable(tableRows)); tableRows = []; }
        
        const content = line.slice(1).trim();
        
        // GitHub Alerts „ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
        const alertMatch = content.match(/^\[!(NOTE|TIP|IMPORTANT|WARNING|CAUTION)\]$/i);
        if (alertMatch && blockquoteBuffer.length === 0) {
          alertType = alertMatch[1].toUpperCase();
          blockquoteBuffer.push('');
          continue;
        }
        
        blockquoteBuffer.push(content);
        continue;
      } else if (blockquoteBuffer.length > 0) {
        // ÂºïÁî®„Éñ„É≠„ÉÉ„ÇØ„ÇíÂá∫Âäõ
        const content = blockquoteBuffer.filter(l => l).map(l => this.parseInline(l)).join('<br>');
        if (alertType) {
          const alertIcons = {
            'NOTE': '‚ÑπÔ∏è',
            'TIP': 'üí°', 
            'IMPORTANT': '‚ùó',
            'WARNING': '‚ö†Ô∏è',
            'CAUTION': 'üî¥'
          };
          html.push(`<div class="alert alert-${alertType.toLowerCase()}"><span class="alert-title">${alertIcons[alertType]} ${alertType}</span><p>${content}</p></div>`);
        } else {
          html.push(`<blockquote>${content}</blockquote>`);
        }
        blockquoteBuffer = [];
        alertType = null;
      }
      
      // „ÉÜ„Éº„Éñ„É´Ë°å„ÅÆÊ§úÂá∫
      if (line.trim().startsWith('|') && line.trim().endsWith('|')) {
        if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
        tableRows.push(line);
        continue;
      } else if (tableRows.length > 0) {
        html.push(this.parseTable(tableRows));
        tableRows = [];
      }
      
      // „Çø„Çπ„ÇØ„É™„Çπ„ÉàÔºà„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„ÇπÔºâ
      const taskMatch = line.match(/^[-*+]\s+\[([ xX])\]\s+(.+)$/);
      if (taskMatch) {
        if (inList !== 'ul') {
          if (inList) html.push('</ol>');
          html.push('<ul class="task-list">');
          inList = 'ul';
        }
        const checked = taskMatch[1].toLowerCase() === 'x' ? 'checked' : '';
        html.push(`<li class="task-item"><input type="checkbox" ${checked} disabled>${this.parseInline(taskMatch[2])}</li>`);
        continue;
      }
      
      // È†ÜÂ∫è„Å™„Åó„É™„Çπ„Éà
      const ulMatch = line.match(/^[-*+]\s+(.+)$/);
      if (ulMatch) {
        if (inList !== 'ul') {
          if (inList) html.push('</ol>');
          html.push('<ul>');
          inList = 'ul';
        }
        html.push(`<li>${this.parseInline(ulMatch[1])}</li>`);
        continue;
      }
      
      // È†ÜÂ∫è„ÅÇ„Çä„É™„Çπ„Éà
      const olMatch = line.match(/^\d+\.\s+(.+)$/);
      if (olMatch) {
        if (inList !== 'ol') {
          if (inList) html.push('</ul>');
          html.push('<ol>');
          inList = 'ol';
        }
        html.push(`<li>${this.parseInline(olMatch[1])}</li>`);
        continue;
      }
      
      // Á©∫Ë°å
      if (line.trim() === '') {
        if (inList) {
          html.push(inList === 'ol' ? '</ol>' : '</ul>');
          inList = null;
        }
        if (tableRows.length > 0) {
          html.push(this.parseTable(tableRows));
          tableRows = [];
        }
        continue;
      }
      
      // ÈÄöÂ∏∏„ÅÆ„Éë„É©„Ç∞„É©„Éï
      if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
      if (tableRows.length > 0) { html.push(this.parseTable(tableRows)); tableRows = []; }
      html.push(`<p>${this.parseInline(line)}</p>`);
    }
    
    // Èñâ„Åò„Çø„Ç∞„ÅÆÂá¶ÁêÜ
    if (inList) html.push(inList === 'ol' ? '</ol>' : '</ul>');
    if (inCodeBlock) {
      html.push(`<pre><code class="language-${codeLang || 'text'}">${codeBuffer.join('\n')}</code></pre>`);
    }
    if (tableRows.length > 0) html.push(this.parseTable(tableRows));
    if (blockquoteBuffer.length > 0) {
      const content = blockquoteBuffer.filter(l => l).map(l => this.parseInline(l)).join('<br>');
      if (alertType) {
        const alertIcons = { 'NOTE': '‚ÑπÔ∏è', 'TIP': 'üí°', 'IMPORTANT': '‚ùó', 'WARNING': '‚ö†Ô∏è', 'CAUTION': 'üî¥' };
        html.push(`<div class="alert alert-${alertType.toLowerCase()}"><span class="alert-title">${alertIcons[alertType]} ${alertType}</span><p>${content}</p></div>`);
      } else {
        html.push(`<blockquote>${content}</blockquote>`);
      }
    }
    
    return html.join('\n');
  },
  
  parseTable(rows) {
    if (rows.length < 2) return '';
    
    const parseRow = (row) => {
      return row.trim()
        .replace(/^\|/, '')
        .replace(/\|$/, '')
        .split('|')
        .map(cell => cell.trim());
    };
    
    const headerCells = parseRow(rows[0]);
    
    // 2Ë°åÁõÆ„ÅåÂå∫Âàá„ÇäË°å„Åã„ÉÅ„Çß„ÉÉ„ÇØ
    const separatorRow = rows[1].trim();
    if (!/^\|[\s\-:|]+\|$/.test(separatorRow)) {
      return rows.map(row => `<p>${this.parseInline(row)}</p>`).join('\n');
    }
    
    // „Ç¢„É©„Ç§„É°„É≥„Éà„ÇíËß£Êûê
    const alignments = parseRow(rows[1]).map(cell => {
      if (cell.startsWith(':') && cell.endsWith(':')) return 'center';
      if (cell.endsWith(':')) return 'right';
      return 'left';
    });
    
    let html = '<table><thead><tr>';
    headerCells.forEach((cell, i) => {
      const align = alignments[i] || 'left';
      html += `<th style="text-align: ${align}">${this.parseInline(cell)}</th>`;
    });
    html += '</tr></thead><tbody>';
    
    // „Éá„Éº„ÇøË°å
    for (let i = 2; i < rows.length; i++) {
      const cells = parseRow(rows[i]);
      html += '<tr>';
      cells.forEach((cell, j) => {
        const align = alignments[j] || 'left';
        html += `<td style="text-align: ${align}">${this.parseInline(cell)}</td>`;
      });
      html += '</tr>';
    }
    
    html += '</tbody></table>';
    return html;
  }
};

const VimEditor = {
  mode: 'normal',
  vimMode: false,              // VIM„É¢„Éº„ÉâÊúâÂäπ/ÁÑ°ÂäπÔºà„Éá„Éï„Ç©„É´„Éà: ÁÑ°ÂäπÔºâ
  register: '',
  searchTerm: '',
  undoStack: [],
  redoStack: [],
  visualStart: null,
  visualLine: false,
  count: '',
  pendingKey: '',
  pendingOperator: '',
  modified: false,
  
  // Êñ∞Ê©üËÉΩÁî®„ÅÆÁä∂ÊÖã
  marks: {},                    // „Éû„Éº„ÇØ
  macros: {},                   // „Éû„ÇØ„É≠
  recordingMacro: null,         // Ë®òÈå≤‰∏≠„ÅÆ„Éû„ÇØ„É≠Âêç
  macroBuffer: [],              // „Éû„ÇØ„É≠Ë®òÈå≤„Éê„ÉÉ„Éï„Ç°
  lastMacro: null,              // ÊúÄÂæå„Å´ÂÆüË°å„Åó„Åü„Éû„ÇØ„É≠
  lastFindChar: null,           // f/F/t/T „ÅÆÊúÄÂæå„ÅÆÊñáÂ≠ó
  lastFindDirection: 1,         // 1: forward, -1: backward
  lastFindType: 'f',            // 'f' or 't'
  lastEdit: null,               // „Éâ„ÉÉ„Éà„É™„Éî„Éº„ÉàÁî®
  lastEditText: '',             // ÊåøÂÖ•„Åï„Çå„Åü„ÉÜ„Ç≠„Çπ„Éà
  previousPosition: null,       // '' „Ç∏„É£„É≥„ÉóÁî®
  currentFileName: 'Untitled',      // ÁèæÂú®„ÅÆ„Éï„Ç°„Ç§„É´Âêç
  fileInsertMode: false,        // „Éï„Ç°„Ç§„É´ÊåøÂÖ•„É¢„Éº„Éâ
  currentFileHandle: null,      // File System Access APIÁî®
  
  init() {
    this.editor = document.getElementById('editor');
    this.preview = document.getElementById('preview-content');
    this.modeIndicator = document.getElementById('vim-mode');
    this.cursorPos = document.getElementById('cursor-pos');
    this.commandLine = document.getElementById('command-line');
    this.commandInput = document.getElementById('command-input');
    this.commandPrefix = document.getElementById('command-prefix');
    this.lineNumbers = document.getElementById('line-numbers');
    this.fileStatus = document.getElementById('file-status');
    this.fileName = document.getElementById('file-name');
    this.macroIndicator = document.getElementById('macro-indicator');
    this.cursorOverlay = document.getElementById('cursor-overlay');
    this.fileInput = document.getElementById('file-input');
    this.fontSizeDisplay = document.getElementById('font-size-display');
    
    // „Çª„ÉÉ„Ç∑„Éß„É≥IDÔºà„Çø„Éñ„Åî„Å®„Å´Áã¨Á´ãÔºâ
    this.sessionId = sessionStorage.getItem('vim-md-session-id');
    if (!this.sessionId) {
      this.sessionId = 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      sessionStorage.setItem('vim-md-session-id', this.sessionId);
    }
    
    // ÁõÆÊ¨°„Éë„Éç„É´
    this.tocPane = document.getElementById('toc-pane');
    this.tocContent = document.getElementById('toc-content');
    this.tocOpenBtn = document.getElementById('toc-open-btn');
    this.tocVisible = true;
    
    // Ë¶ãÂá∫„Åó„Éè„Ç§„É©„Ç§„Éà„Ç™„Éº„Éê„Éº„É¨„Ç§
    this.headingHighlight = document.createElement('div');
    this.headingHighlight.id = 'heading-highlight';
    document.getElementById('editor-wrapper').appendChild(this.headingHighlight);
    
    // „Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫Ôºà%Ôºâ- „Åì„Çå„ÅØÂÖ®„Çø„ÉñÂÖ±ÈÄö„ÅßOK
    this.fontSize = parseInt(localStorage.getItem('vim-md-font-size')) || 100;
    this.applyFontSize();
    
    // VIM„É¢„Éº„ÉâË®≠ÂÆö„ÇíË™≠„ÅøËæº„Åø
    this.vimMode = localStorage.getItem('vim-md-vim-mode') === 'true';
    this.updateVimModeUI();
    
    // „Éï„Ç°„Ç§„É´ÂÖ•Âäõ„ÅÆ„Ç§„Éô„É≥„Éà
    this.fileInput.addEventListener('change', e => this.handleFileOpen(e));
    
    // „Ç´„Éº„ÇΩ„É´Ë®àÊ∏¨Áî®„ÅÆÈö†„ÅóË¶ÅÁ¥†
    this.measureSpan = document.createElement('span');
    this.measureSpan.style.cssText = `
      position: absolute;
      visibility: hidden;
      white-space: pre;
      font-family: inherit;
      font-size: 0.95rem;
      line-height: 1.5;
    `;
    document.body.appendChild(this.measureSpan);
    
    this.setupEventListeners();
    this.loadFromStorage();
    this.updateLineNumbers();
    this.updatePreview();
    this.updateToc();
    this.updateHeadingHighlight();
    this.saveState();
    this.updateCursorOverlay();
    
    // NOVIM mode: set editable state
    if (!this.vimMode) {
      this.mode = 'insert';
      this.editor.readOnly = false;
      this.editor.classList.add('insert-mode');
    }
    
    this.editor.focus();
    this.initialized = true;
  },
  
  setupEventListeners() {
    this.editor.addEventListener('keydown', e => this.handleKeydown(e));
    this.editor.addEventListener('input', e => this.onInput(e));
    this.editor.addEventListener('click', () => this.updateCursorPos());
    this.editor.addEventListener('scroll', () => this.syncScroll());
    this.commandInput.addEventListener('keydown', e => this.handleCommandKey(e));
    
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape' && !document.getElementById('help-modal').classList.contains('hidden')) {
        toggleHelp();
      }
    });
    
    this.editor.addEventListener('scroll', () => {
      this.lineNumbers.scrollTop = this.editor.scrollTop;
      this.updateCursorOverlay();
      this.updateHeadingHighlight();
    });
  },
  
  loadFromStorage() {
    // 1. Check sessionStorage first (tab restore)
    const sessionContent = sessionStorage.getItem('vim-md-content-' + this.sessionId);
    if (sessionContent) {
      this.editor.value = sessionContent;
      // Restore filename from localStorage session data
      try {
        const sessionData = JSON.parse(localStorage.getItem('vim-md-session-' + this.sessionId) || '{}');
        if (sessionData.filename) {
          this.currentFileName = sessionData.filename;
          this.fileName.textContent = sessionData.filename;
        }
      } catch (e) {}
      this.showStatus('Session restored');
      return;
    }
    
    // 2. For new tabs, restore the latest session from localStorage
    let sessions = [];
    try {
      sessions = JSON.parse(localStorage.getItem('vim-md-sessions') || '[]');
    } catch (e) {
      sessions = [];
    }
    
    if (sessions.length > 0) {
      // Find the latest session
      let latestSession = null;
      let latestTimestamp = 0;
      
      for (const sid of sessions) {
        try {
          const data = JSON.parse(localStorage.getItem('vim-md-session-' + sid) || '{}');
          if (data.timestamp && data.timestamp > latestTimestamp && data.content) {
            latestTimestamp = data.timestamp;
            latestSession = data;
          }
        } catch (e) {}
      }
      
      if (latestSession) {
        this.editor.value = latestSession.content;
        this.currentFileName = latestSession.filename || 'Untitled';
        this.fileName.textContent = this.currentFileName;
        this.showStatus('Previous content restored');
        return;
      }
    }
    
    // 3. Migrate from old localStorage format
    const oldContent = localStorage.getItem('vim-md-content');
    if (oldContent) {
      this.editor.value = oldContent;
      const oldFilename = localStorage.getItem('vim-md-filename');
      if (oldFilename) {
        this.currentFileName = oldFilename;
        this.fileName.textContent = oldFilename;
      }
      // Migrate to new format
      this.saveSessionData();
      // Remove old format
      localStorage.removeItem('vim-md-content');
      localStorage.removeItem('vim-md-filename');
      this.showStatus('Previous content restored');
      return;
    }
    
    // 4. Default content for first launch
    this.editor.value = this.getWelcomeContent();
  },
  
  // Get welcome document content
  getWelcomeContent() {
    return `# Welcome to mdvim v0.2.4!

**mdvim** is a Vim-style Markdown editor.

## Features

### Vim Operations
- \`h\`/\`j\`/\`k\`/\`l\` cursor movement
- \`i\`/\`a\`/\`o\` insert mode
- \`dd\`/\`yy\`/\`p\` delete/copy/paste
- \`u\`/\`Ctrl+r\` undo/redo

### Search & Replace
- \`/pattern\` search
- \`:s/old/new/g\` replace
- \`:%s/old/new/g\` replace all

### File Operations
- \`:w\` save dialog
- \`:e\` open file
- \`:new\` new file

### Math (LaTeX)

Inline: $E = mc^2$

Block:
$$
\\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}
$$

### Table

| Key | Action |
|:----|:-------|
| \`h\` | Move left |
| \`j\` | Move down |
| \`k\` | Move up |
| \`l\` | Move right |

### Mermaid Diagram

\`\`\`mermaid
graph LR
    A[mdvim] --> B[Vim]
    A --> C[Markdown]
    A --> D[Preview]
\`\`\`

### Task List

- [x] Vim operations
- [x] Markdown preview
- [x] Math support
- [x] Mermaid diagrams
- [ ] More features coming

### GitHub Alerts

> [!NOTE]
> This is a note.

> [!WARNING]
> This is a warning.

### Qiita Note Syntax

:::note info
Information
:::

:::note warn
Warning message
:::

### Emoji

:smile: :rocket: :star: :+1:

---

Press \`?\` for help
`;
  },
  
  // Show welcome screen
  showWelcome() {
    this.saveState();
    this.editor.value = this.getWelcomeContent();
    this.fileName.textContent = 'welcome.md';
    this.currentFileName = 'welcome.md';
    this.modified = false;
    this.updateFileStatus();
    this.updateLineNumbers();
    this.updatePreview();
    this.updateToc();
    this.updateHeadingHighlight();
    this.editor.selectionStart = 0;
    this.editor.selectionEnd = 0;
    this.updateCursorPos();
    this.showStatus('Welcome screen displayed');
  },
  
  // „Éû„ÇØ„É≠Ë®òÈå≤
  recordKey(key, e) {
    if (this.recordingMacro && key !== 'q') {
      this.macroBuffer.push({ key, ctrlKey: e?.ctrlKey, shiftKey: e?.shiftKey });
    }
  },
  
  handleKeydown(e) {
  handleKeydown(e) {
    // NOVIM„É¢„Éº„Éâ„ÅÆÂ†¥Âêà - „Ç∑„É≥„Éó„É´„Å´Âá¶ÁêÜ
    if (this.vimMode !== true) {
      
      // Ctrl+` „ÅßVIM„É¢„Éº„Éâ„Å´Âàá„ÇäÊõø„Åà
      if (e.ctrlKey && e.code === 'Backquote') {
        e.preventDefault();
        this.setVimMode(true);
        return;
      }
      
      // Ctrl+„Ç≠„Éº„ÅÆ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà
      if (e.ctrlKey) {
        switch (e.key.toLowerCase()) {
          case 's':
            e.preventDefault();
            this.downloadFile(this.currentFileName || 'Untitled');
            return;
          case 'o':
            e.preventDefault();
            this.openFileDialog(false);
            return;
          case 'a':
            e.preventDefault();
            const filename = prompt('Enter filename:', this.currentFileName || 'Untitled.md');
            if (filename) {
              this.downloadFile(filename);
            }
            return;
          case 'n':
            e.preventDefault();
            if (this.modified) {
              if (confirm('Changes not saved. Create new file?')) {
                this.newFile();
              }
            } else {
              this.newFile();
            }
            return;
        }
        // „Åù„ÅÆ‰ªñ„ÅÆCtrl+„Ç≠„Éº„ÅØ„Éñ„É©„Ç¶„Ç∂„ÅÆ„Éá„Éï„Ç©„É´„ÉàÂãï‰ΩúÔºàCtrl+Z, Ctrl+CÁ≠âÔºâ
        return;
      }
      
      // Tab„Ç≠„Éº
      if (e.key === 'Tab') {
        e.preventDefault();
        this.handleTab(e.shiftKey);
        return;
      }
      
      // Escape„Ç≠„Éº
      if (e.key === 'Escape') {
        if (!this.commandLine.classList.contains('hidden')) {
          this.commandLine.classList.add('hidden');
          this.editor.focus();
        }
        return;
      }
      
      // „Åù„ÅÆ‰ªñÂÖ®„Å¶„ÅÆ„Ç≠„ÉºÔºàÁü¢Âç∞„Ç≠„ÉºÂê´„ÇÄÔºâ„ÅØ„Éá„Éï„Ç©„É´„ÉàÂãï‰Ωú„ÇíË®±ÂèØ
      return;
    }
    
    // ‰ª•‰∏ã„ÅØVIM„É¢„Éº„ÉâÔºàthis.vimMode === trueÔºâ„ÅÆÂá¶ÁêÜ
    
    // Ctrl+` „ÅßNOVIM„É¢„Éº„Éâ„Å´Âàá„ÇäÊõø„Åà
    if (e.ctrlKey && e.code === 'Backquote') {
      e.preventDefault();
      this.setVimMode(false);
      return;
    }
    
    // Ctrl+[ „ÇíESC„Å®„Åó„Å¶Êâ±„ÅÜ
    if (e.ctrlKey && e.key === '[') {
      e.preventDefault();
      if (this.mode === 'insert') {
        this.exitInsertMode();
      } else if (this.mode === 'visual') {
        this.setMode('normal');
        this.editor.selectionEnd = this.editor.selectionStart;
      }
      return;
    }
    
    if (this.mode === 'insert') {
      if (e.key === 'Escape') {
        e.preventDefault();
        this.exitInsertMode();
      } else if (e.key === 'Tab') {
        e.preventDefault();
        this.handleTab(e.shiftKey);
      }
      return;
    }
    
    if (this.mode === 'visual') {
      e.preventDefault();
      this.handleVisualMode(e);
      return;
    }
    
    e.preventDefault();
    this.handleNormalMode(e);
  },
  
  // „Çø„Éñ„Ç≠„ÉºÂá¶ÁêÜÔºà„Ç§„É≥„Éá„É≥„Éà/„Ç¢„É≥„Ç§„É≥„Éá„É≥„ÉàÔºâ
  handleTab(isShift) {
    const text = this.editor.value;
    const start = this.editor.selectionStart;
    const end = this.editor.selectionEnd;
    const tabChar = '  '; // 2„Çπ„Éö„Éº„Çπ„Çí„Ç§„É≥„Éá„É≥„Éà„Å®„Åó„Å¶‰ΩøÁî®
    
    // ÈÅ∏ÊäûÁØÑÂõ≤„Åå„Å™„ÅÑÂ†¥Âêà
    if (start === end) {
      if (isShift) {
        // Shift+Tab: ÁèæÂú®Ë°å„ÅÆ„Ç§„É≥„Éá„É≥„Éà„ÇíÊ∏õ„Çâ„Åô
        const lineStart = text.lastIndexOf('\n', start - 1) + 1;
        const lineText = text.substring(lineStart, start);
        
        if (lineText.startsWith(tabChar)) {
          this.editor.value = text.substring(0, lineStart) + text.substring(lineStart + tabChar.length);
          this.editor.selectionStart = this.editor.selectionEnd = start - tabChar.length;
        } else if (lineText.startsWith('\t')) {
          this.editor.value = text.substring(0, lineStart) + text.substring(lineStart + 1);
          this.editor.selectionStart = this.editor.selectionEnd = start - 1;
        }
      } else {
        // Tab: „Çø„ÉñÊñáÂ≠ó„ÇíÊåøÂÖ•
        this.editor.value = text.substring(0, start) + tabChar + text.substring(end);
        this.editor.selectionStart = this.editor.selectionEnd = start + tabChar.length;
      }
    } else {
      // ÈÅ∏ÊäûÁØÑÂõ≤„Åå„ÅÇ„ÇãÂ†¥Âêà: Ë§áÊï∞Ë°å„Çí„Ç§„É≥„Éá„É≥„Éà/„Ç¢„É≥„Ç§„É≥„Éá„É≥„Éà
      const lineStart = text.lastIndexOf('\n', start - 1) + 1;
      const lineEnd = text.indexOf('\n', end);
      const actualEnd = lineEnd === -1 ? text.length : lineEnd;
      const selectedLines = text.substring(lineStart, actualEnd);
      const lines = selectedLines.split('\n');
      
      let newLines;
      if (isShift) {
        // „Ç¢„É≥„Ç§„É≥„Éá„É≥„Éà
        newLines = lines.map(line => {
          if (line.startsWith(tabChar)) {
            return line.substring(tabChar.length);
          } else if (line.startsWith('\t')) {
            return line.substring(1);
          }
          return line;
        });
      } else {
        // „Ç§„É≥„Éá„É≥„Éà
        newLines = lines.map(line => tabChar + line);
      }
      
      const newText = newLines.join('\n');
      this.editor.value = text.substring(0, lineStart) + newText + text.substring(actualEnd);
      
      // ÈÅ∏ÊäûÁØÑÂõ≤„ÇíÁ∂≠ÊåÅ
      this.editor.selectionStart = lineStart;
      this.editor.selectionEnd = lineStart + newText.length;
    }
    
    this.modified = true;
    this.updateFileStatus();
    this.onInput();
  },
  
  exitInsertMode() {
    // ÊåøÂÖ•„É¢„Éº„ÉâÁµÇ‰∫ÜÊôÇ„ÅÆÂá¶ÁêÜ
    if (this.lastEdit && this.lastEdit.type === 'insert') {
      this.lastEdit.insertedText = this.lastEditText;
    }
    this.lastEditText = '';
    
    this.setMode('normal');
    if (this.editor.selectionStart > 0) {
      this.editor.selectionStart--;
      this.editor.selectionEnd = this.editor.selectionStart;
    }
  },
  
  handleNormalMode(e) {
    const key = e.key;
    
    this.recordKey(key, e);
    
    // Êï∞ÂÄ§„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ
    if (/^[1-9]$/.test(key) || (this.count && /^[0-9]$/.test(key))) {
      this.count += key;
      return;
    }
    
    const count = parseInt(this.count) || 1;
    this.count = '';
    
    // „Ç™„Éö„É¨„Éº„Çø„ÉºÂæÖ„Å°Áä∂ÊÖãÔºàd, c, y „ÅÆÂæåÔºâ
    if (this.pendingOperator) {
      this.handleOperatorPending(key, count, e);
      return;
    }
    
    // ‰øùÁïô‰∏≠„ÅÆ„Ç≠„Éº
    if (this.pendingKey) {
      this.handlePendingKey(key, count);
      return;
    }
    
    // CtrlÁµÑ„ÅøÂêà„Çè„Åõ
    if (e.ctrlKey) {
      switch(key) {
        case 'r': this.redo(); return;
        case 'd': this.scrollHalfPage(1); return;
        case 'u': this.scrollHalfPage(-1); return;
        case 'f': this.scrollFullPage(1); return;
        case 'b': this.scrollFullPage(-1); return;
      }
    }
    
    switch(key) {
      // „É¢„Éº„ÉâÂàáÊõø
      case 'i': 
        this.setLastEdit('insert', this.editor.selectionStart);
        this.setMode('insert'); 
        break;
      case 'I': 
        this.moveToFirstNonSpace(); 
        this.setLastEdit('insert', this.editor.selectionStart);
        this.setMode('insert'); 
        break;
      case 'a': 
        if (this.editor.selectionStart < this.editor.value.length) {
          this.editor.selectionStart++;
          this.editor.selectionEnd = this.editor.selectionStart;
        }
        this.setLastEdit('insert', this.editor.selectionStart);
        this.setMode('insert'); 
        break;
      case 'A': 
        this.moveToLineEnd(); 
        this.setLastEdit('insert', this.editor.selectionStart);
        this.setMode('insert'); 
        break;
      case 'o': 
        this.saveState();
        this.moveToLineEnd(); 
        this.insertText('\n'); 
        this.setLastEdit('o');
        this.setMode('insert'); 
        break;
      case 'O': 
        this.saveState();
        this.moveToLineStart(); 
        this.insertText('\n'); 
        this.moveCursor(-1); 
        this.setLastEdit('O');
        this.setMode('insert'); 
        break;
      case 's':
        this.saveState();
        this.deleteChar();
        this.setLastEdit('s');
        this.setMode('insert');
        break;
      case 'S':
        this.saveState();
        this.deleteLineContent();
        this.setLastEdit('S');
        this.setMode('insert');
        break;
      case 'v': 
        this.setMode('visual'); 
        this.visualStart = this.editor.selectionStart; 
        this.visualLine = false; 
        break;
      case 'V': 
        this.setMode('visual'); 
        this.selectCurrentLine(); 
        this.visualLine = true; 
        break;
      case ':': 
        this.setMode('command'); 
        this.commandPrefix.textContent = ':'; 
        break;
      case '/': 
        this.setMode('command'); 
        this.commandPrefix.textContent = '/'; 
        break;
      case '?': 
        toggleHelp(); 
        break;
      
      // ÁßªÂãï
      case 'h': case 'ArrowLeft': this.moveCursor(-count); break;
      case 'l': case 'ArrowRight': this.moveCursor(count); break;
      case 'j': case 'ArrowDown': for (let i = 0; i < count; i++) this.moveVertical(1); break;
      case 'k': case 'ArrowUp': for (let i = 0; i < count; i++) this.moveVertical(-1); break;
      case 'w': for (let i = 0; i < count; i++) this.moveWord(1); break;
      case 'b': for (let i = 0; i < count; i++) this.moveWord(-1); break;
      case 'e': for (let i = 0; i < count; i++) this.moveWordEnd(); break;
      case '0': this.moveToLineStart(); break;
      case '$': this.moveToLineEnd(); break;
      case '^': this.moveToFirstNonSpace(); break;
      case 'g': this.pendingKey = 'g'; break;
      case 'G': if (count > 1) this.gotoLine(count); else this.moveToEnd(); break;
      case 'z': this.pendingKey = 'z'; break;
      
      // Ë°åÂÜÖÊ§úÁ¥¢ (f/F/t/T)
      case 'f': this.pendingKey = 'f'; break;
      case 'F': this.pendingKey = 'F'; break;
      case 't': this.pendingKey = 't'; break;
      case 'T': this.pendingKey = 'T'; break;
      case ';': this.repeatFindChar(1); break;
      case ',': this.repeatFindChar(-1); break;
      
      // Êã¨Âºß„Ç∏„É£„É≥„Éó
      case '%': this.jumpToMatchingBracket(); break;
      
      // „Éë„É©„Ç∞„É©„ÉïÁßªÂãï
      case '{': for (let i = 0; i < count; i++) this.moveParagraph(-1); break;
      case '}': for (let i = 0; i < count; i++) this.moveParagraph(1); break;
      
      // „Éû„Éº„ÇØ
      case 'm': this.pendingKey = 'm'; break;
      case "'": this.pendingKey = "'"; break;
      case '`': this.pendingKey = '`'; break;
      
      // „Éû„ÇØ„É≠
      case 'q':
        if (this.recordingMacro) {
          this.stopRecordingMacro();
        } else {
          this.pendingKey = 'q_start';
        }
        break;
      case '@': this.pendingKey = '@'; break;
      
      // Á∑®ÈõÜ
      case 'x': 
        this.saveState(); 
        for (let i = 0; i < count; i++) this.deleteChar(); 
        this.setLastEdit('x', null, count);
        break;
      case 'X': 
        this.saveState(); 
        for (let i = 0; i < count; i++) this.deleteCharBefore(); 
        this.setLastEdit('X', null, count);
        break;
      case 'd': this.pendingOperator = 'd'; break;
      case 'D': 
        this.saveState(); 
        this.deleteToLineEnd(); 
        this.setLastEdit('D');
        break;
      case 'c': this.pendingOperator = 'c'; break;
      case 'C': 
        this.saveState(); 
        this.deleteToLineEnd(); 
        this.setLastEdit('C');
        this.setMode('insert'); 
        break;
      case 'y': this.pendingOperator = 'y'; break;
      case 'Y': this.yankLine(); break;
      case 'p': this.saveState(); this.paste(); break;
      case 'P': this.saveState(); this.pasteBefore(); break;
      case 'u': this.undo(); break;
      case 'J': this.saveState(); this.joinLines(); this.setLastEdit('J'); break;
      case 'r': this.pendingKey = 'r'; break;
      
      // „Éâ„ÉÉ„Éà„É™„Éî„Éº„Éà
      case '.': this.repeatLastEdit(count); break;
      
      // Â§ßÊñáÂ≠ó/Â∞èÊñáÂ≠óÂàáÊõø
      case '~': 
        this.saveState(); 
        for (let i = 0; i < count; i++) this.toggleCase(); 
        this.setLastEdit('~', null, count);
        break;
      
      // „Ç§„É≥„Éá„É≥„Éà
      case '>': this.pendingKey = '>'; break;
      case '<': this.pendingKey = '<'; break;
      
      // Ê§úÁ¥¢
      case 'n': this.findNext(); break;
      case 'N': this.findPrev(); break;
      case '*': this.searchWordUnderCursor(); break;
    }
    
    this.updateCursorPos();
  },
  
  // „Ç™„Éö„É¨„Éº„Çø„ÉºÂæÖ„Å°Áä∂ÊÖã„ÅÆÂá¶ÁêÜ (d, c, y „ÅÆÂæå)
  handleOperatorPending(key, count, e) {
    const op = this.pendingOperator;
    this.pendingOperator = '';
    
    // „ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà (i/a)
    if (key === 'i' || key === 'a') {
      this.pendingKey = op + key;  // ‰æã: 'di', 'ca'
      return;
    }
    
    // „Ç™„Éö„É¨„Éº„Çø„Éº„ÅÆÈáçË§á (dd, cc, yy)
    if (key === op) {
      this.saveState();
      if (op === 'd') {
        for (let i = 0; i < count; i++) this.deleteLine();
        this.setLastEdit('dd', null, count);
      } else if (op === 'c') {
        this.deleteLineContent();
        this.setLastEdit('cc', null, count);
        this.setMode('insert');
      } else if (op === 'y') {
        this.yankLine();
      }
      return;
    }
    
    // „É¢„Éº„Ç∑„Éß„É≥
    this.saveState();
    const startPos = this.editor.selectionStart;
    
    switch(key) {
      case 'w':
        for (let i = 0; i < count; i++) this.moveWord(1);
        break;
      case 'b':
        for (let i = 0; i < count; i++) this.moveWord(-1);
        break;
      case 'e':
        for (let i = 0; i < count; i++) this.moveWordEnd();
        this.editor.selectionStart++;
        this.editor.selectionEnd++;
        break;
      case '$':
        this.moveToLineEnd();
        break;
      case '0':
        this.moveToLineStart();
        break;
      case '^':
        this.moveToFirstNonSpace();
        break;
      case 'G':
        this.moveToEnd();
        break;
      case '{':
        this.moveParagraph(-1);
        break;
      case '}':
        this.moveParagraph(1);
        break;
      case 'g':
        this.pendingKey = op + 'g';
        return;
      default:
        return;
    }
    
    const endPos = this.editor.selectionStart;
    const start = Math.min(startPos, endPos);
    const end = Math.max(startPos, endPos);
    
    this.applyOperator(op, start, end, key, count);
    this.updateCursorPos();
  },
  
  applyOperator(op, start, end, motion, count) {
    const text = this.editor.value.substring(start, end);
    
    if (op === 'y') {
      this.register = text;
      this.editor.selectionStart = start;
      this.editor.selectionEnd = start;
      this.showStatus('Yanked');
    } else if (op === 'd') {
      this.register = text;
      this.editor.value = this.editor.value.substring(0, start) + this.editor.value.substring(end);
      this.editor.selectionStart = start;
      this.editor.selectionEnd = start;
      this.setLastEdit('d' + motion, null, count);
      this.onInput();
    } else if (op === 'c') {
      this.register = text;
      this.editor.value = this.editor.value.substring(0, start) + this.editor.value.substring(end);
      this.editor.selectionStart = start;
      this.editor.selectionEnd = start;
      this.setLastEdit('c' + motion, null, count);
      this.setMode('insert');
      this.onInput();
    }
  },
  
  handlePendingKey(key, count) {
    const pending = this.pendingKey;
    this.pendingKey = '';
    
    switch(pending) {
      case 'g':
        if (key === 'g') this.moveToStart();
        break;
      
      case 'z':
        // z Enter, zt - cursor line to top
        if (key === 'Enter' || key === 't') {
          this.scrollCursorToTop();
        }
        // z. zz - cursor line to center
        else if (key === '.' || key === 'z') {
          this.scrollCursorToCenter();
        }
        // z- zb - cursor line to bottom
        else if (key === '-' || key === 'b') {
          this.scrollCursorToBottom();
        }
        break;
        
      case 'd':
        this.saveState();
        if (key === 'd') { for (let i = 0; i < count; i++) this.deleteLine(); this.setLastEdit('dd', null, count); }
        else if (key === 'w') { this.deleteWord(); this.setLastEdit('dw'); }
        else if (key === '$') { this.deleteToLineEnd(); this.setLastEdit('d$'); }
        else if (key === '0') { this.deleteToLineStart(); this.setLastEdit('d0'); }
        break;
        
      case 'y':
        if (key === 'y') this.yankLine();
        else if (key === 'w') this.yankWord();
        break;
        
      case 'c':
        this.saveState();
        if (key === 'c') { this.deleteLineContent(); this.setLastEdit('cc'); this.setMode('insert'); }
        else if (key === 'w') { this.deleteWord(); this.setLastEdit('cw'); this.setMode('insert'); }
        break;
        
      case 'r':
        if (key.length === 1) {
          this.saveState();
          this.replaceChar(key);
          this.setLastEdit('r', key);
        }
        break;
        
      // Ë°åÂÜÖÊ§úÁ¥¢
      case 'f':
        if (key.length === 1) {
          this.findCharInLine(key, 1, false);
          this.lastFindChar = key;
          this.lastFindDirection = 1;
          this.lastFindType = 'f';
        }
        break;
      case 'F':
        if (key.length === 1) {
          this.findCharInLine(key, -1, false);
          this.lastFindChar = key;
          this.lastFindDirection = -1;
          this.lastFindType = 'f';
        }
        break;
      case 't':
        if (key.length === 1) {
          this.findCharInLine(key, 1, true);
          this.lastFindChar = key;
          this.lastFindDirection = 1;
          this.lastFindType = 't';
        }
        break;
      case 'T':
        if (key.length === 1) {
          this.findCharInLine(key, -1, true);
          this.lastFindChar = key;
          this.lastFindDirection = -1;
          this.lastFindType = 't';
        }
        break;
        
      // „Éû„Éº„ÇØ
      case 'm':
        if (/^[a-z]$/.test(key)) {
          this.marks[key] = this.editor.selectionStart;
          this.showStatus(`Mark '${key}' set`);
        }
        break;
      case "'":
        if (key === "'") {
          // '' „ÅßÁõ¥Ââç‰ΩçÁΩÆ„Å∏
          if (this.previousPosition !== null) {
            const current = this.editor.selectionStart;
            this.gotoPosition(this.previousPosition);
            this.previousPosition = current;
            this.moveToFirstNonSpace();
          }
        } else if (/^[a-z]$/.test(key) && this.marks[key] !== undefined) {
          this.previousPosition = this.editor.selectionStart;
          this.gotoPosition(this.marks[key]);
          this.moveToFirstNonSpace();
        }
        break;
      case '`':
        if (/^[a-z]$/.test(key) && this.marks[key] !== undefined) {
          this.previousPosition = this.editor.selectionStart;
          this.gotoPosition(this.marks[key]);
        }
        break;
        
      // „Éû„ÇØ„É≠
      case 'q_start':
        if (/^[a-z]$/.test(key)) {
          this.startRecordingMacro(key);
        }
        break;
      case '@':
        if (key === '@' && this.lastMacro) {
          this.playMacro(this.lastMacro);
        } else if (/^[a-z]$/.test(key) && this.macros[key]) {
          this.playMacro(key);
        }
        break;
        
      // „Ç§„É≥„Éá„É≥„Éà
      case '>':
        if (key === '>') {
          this.saveState();
          for (let i = 0; i < count; i++) this.indentLine(1);
          this.setLastEdit('>>', null, count);
        }
        break;
      case '<':
        if (key === '<') {
          this.saveState();
          for (let i = 0; i < count; i++) this.indentLine(-1);
          this.setLastEdit('<<', null, count);
        }
        break;
        
      // „ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà (di, da, ci, ca, yi, ya)
      case 'di': case 'da': case 'ci': case 'ca': case 'yi': case 'ya':
        this.handleTextObject(pending, key);
        break;
        
      // dg, cg, yg
      case 'dg':
        if (key === 'g') {
          this.saveState();
          const pos = this.editor.selectionStart;
          this.register = this.editor.value.substring(0, pos);
          this.editor.value = this.editor.value.substring(pos);
          this.editor.selectionStart = 0;
          this.editor.selectionEnd = 0;
          this.onInput();
        }
        break;
    }
    
    this.updateCursorPos();
  },
  
  // „ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂá¶ÁêÜ
  handleTextObject(opType, objChar) {
    const op = opType[0];  // 'd', 'c', 'y'
    const inner = opType[1] === 'i';  // true: inner, false: around
    
    let range = null;
    
    switch(objChar) {
      case 'w':
        range = this.getWordRange(inner);
        break;
      case '"':
      case "'":
      case '`':
        range = this.getQuoteRange(objChar, inner);
        break;
      case '(':
      case ')':
      case 'b':
        range = this.getBracketRange('(', ')', inner);
        break;
      case '[':
      case ']':
        range = this.getBracketRange('[', ']', inner);
        break;
      case '{':
      case '}':
      case 'B':
        range = this.getBracketRange('{', '}', inner);
        break;
      case '<':
      case '>':
        range = this.getBracketRange('<', '>', inner);
        break;
    }
    
    if (range) {
      this.saveState();
      const text = this.editor.value.substring(range.start, range.end);
      
      if (op === 'y') {
        this.register = text;
        this.showStatus('Yanked');
      } else {
        this.register = text;
        this.editor.value = this.editor.value.substring(0, range.start) + this.editor.value.substring(range.end);
        this.editor.selectionStart = range.start;
        this.editor.selectionEnd = range.start;
        this.setLastEdit(opType + objChar);
        
        if (op === 'c') {
          this.setMode('insert');
        }
        this.onInput();
      }
    }
  },
  
  getWordRange(inner) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    let start = pos;
    let end = pos;
    
    // ÂçòË™û„ÅÆÂ¢ÉÁïå„ÇíË¶ã„Å§„Åë„Çã
    while (start > 0 && /\w/.test(text[start - 1])) start--;
    while (end < text.length && /\w/.test(text[end])) end++;
    
    if (!inner) {
      // around: ÂæåÁ∂ö„ÅÆÁ©∫ÁôΩ„ÇÇÂê´„ÇÅ„Çã
      while (end < text.length && /\s/.test(text[end]) && text[end] !== '\n') end++;
    }
    
    if (start === end) return null;
    return { start, end };
  },
  
  getQuoteRange(quote, inner) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    // ÁèæÂú®Ë°å„ÇíÂèñÂæó
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    const line = text.substring(lineStart, lineEnd);
    const colPos = pos - lineStart;
    
    // ÂºïÁî®Á¨¶„ÅÆ„Éö„Ç¢„ÇíÊé¢„Åô
    let start = -1;
    let end = -1;
    let inQuote = false;
    let quoteStart = -1;
    
    for (let i = 0; i < line.length; i++) {
      if (line[i] === quote && (i === 0 || line[i-1] !== '\\')) {
        if (!inQuote) {
          quoteStart = i;
          inQuote = true;
        } else {
          if (colPos >= quoteStart && colPos <= i) {
            start = quoteStart;
            end = i;
            break;
          }
          inQuote = false;
        }
      }
    }
    
    if (start === -1 || end === -1) return null;
    
    if (inner) {
      return { start: lineStart + start + 1, end: lineStart + end };
    } else {
      return { start: lineStart + start, end: lineStart + end + 1 };
    }
  },
  
  getBracketRange(open, close, inner) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    // ÂØæÂøú„Åô„ÇãÊã¨Âºß„ÇíÊé¢„Åô
    let depth = 0;
    let start = -1;
    let end = -1;
    
    // Èñã„ÅçÊã¨Âºß„ÇíÂæå„Çç„Å´Êé¢„Åô
    for (let i = pos; i >= 0; i--) {
      if (text[i] === close) depth++;
      else if (text[i] === open) {
        if (depth === 0) {
          start = i;
          break;
        }
        depth--;
      }
    }
    
    if (start === -1) return null;
    
    // Èñâ„ÅòÊã¨Âºß„ÇíÂâç„Å´Êé¢„Åô
    depth = 0;
    for (let i = start; i < text.length; i++) {
      if (text[i] === open) depth++;
      else if (text[i] === close) {
        depth--;
        if (depth === 0) {
          end = i;
          break;
        }
      }
    }
    
    if (end === -1) return null;
    
    if (inner) {
      return { start: start + 1, end: end };
    } else {
      return { start: start, end: end + 1 };
    }
  },
  
  handleVisualMode(e) {
    const key = e.key;
    
    this.recordKey(key, e);
    
    if (key === 'Escape' || (e.ctrlKey && key === '[')) {
      this.setMode('normal');
      this.editor.selectionEnd = this.editor.selectionStart;
      return;
    }
    
    const start = Math.min(this.visualStart, this.editor.selectionStart);
    const end = Math.max(this.visualStart, this.editor.selectionEnd);
    
    switch(key) {
      case 'h': case 'ArrowLeft': this.moveCursor(-1); break;
      case 'l': case 'ArrowRight': this.moveCursor(1); break;
      case 'j': case 'ArrowDown': this.moveVertical(1); break;
      case 'k': case 'ArrowUp': this.moveVertical(-1); break;
      case 'w': this.moveWord(1); break;
      case 'b': this.moveWord(-1); break;
      case '0': this.moveToLineStart(); break;
      case '$': this.moveToLineEnd(); break;
      case 'G': this.moveToEnd(); break;
      case 'g': this.pendingKey = 'g'; break;
      case '{': this.moveParagraph(-1); break;
      case '}': this.moveParagraph(1); break;
      
      // „Ç§„É≥„Éá„É≥„Éà
      case '>':
        this.saveState();
        this.indentSelection(1);
        this.setMode('normal');
        return;
      case '<':
        this.saveState();
        this.indentSelection(-1);
        this.setMode('normal');
        return;
        
      case 'd': case 'x':
        this.saveState();
        this.editor.selectionStart = start;
        this.editor.selectionEnd = end;
        this.register = this.editor.value.substring(start, end);
        this.deleteSelection();
        this.setMode('normal');
        return;
      case 'y':
        this.register = this.editor.value.substring(start, end);
        this.setMode('normal');
        this.editor.selectionEnd = this.editor.selectionStart;
        this.showStatus('Yanked');
        return;
      case 'c':
        this.saveState();
        this.editor.selectionStart = start;
        this.editor.selectionEnd = end;
        this.register = this.editor.value.substring(start, end);
        this.deleteSelection();
        this.setMode('insert');
        return;
      case '~':
        this.saveState();
        this.toggleCaseSelection(start, end);
        this.setMode('normal');
        return;
      case 'U':
        this.saveState();
        this.changeCaseSelection(start, end, 'upper');
        this.setMode('normal');
        return;
      case 'u':
        this.saveState();
        this.changeCaseSelection(start, end, 'lower');
        this.setMode('normal');
        return;
    }
    
    // ÈÅ∏ÊäûÁØÑÂõ≤„ÅÆÊõ¥Êñ∞
    if (this.mode === 'visual') {
      const curPos = this.editor.selectionStart;
      if (this.visualLine) {
        const text = this.editor.value;
        const startLine = text.lastIndexOf('\n', Math.min(this.visualStart, curPos) - 1) + 1;
        let endLine = text.indexOf('\n', Math.max(this.visualStart, curPos));
        if (endLine === -1) endLine = text.length;
        else endLine++;
        this.editor.selectionStart = startLine;
        this.editor.selectionEnd = endLine;
      } else {
        this.editor.selectionStart = Math.min(this.visualStart, curPos);
        this.editor.selectionEnd = Math.max(this.visualStart, curPos);
      }
    }
    
    this.updateCursorPos();
  },
  
  handleCommandKey(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      const cmd = this.commandInput.value;
      const prefix = this.commandPrefix.textContent;
      this.commandInput.value = '';
      this.setMode('normal');
      
      if (prefix === ':') this.executeCommand(cmd);
      else if (prefix === '/') this.search(cmd);
    } else if (e.key === 'Escape' || (e.ctrlKey && e.key === '[')) {
      e.preventDefault();
      this.commandInput.value = '';
      this.setMode('normal');
    }
  },
  
  executeCommand(cmd) {
    // ÁΩÆÊèõ„Ç≥„Éû„É≥„Éâ„ÅÆ„Éë„Éº„Çπ
    const substituteMatch = cmd.match(/^(%)?s\/(.+?)\/(.*)\/([gic]*)$/);
    if (substituteMatch) {
      this.substitute(substituteMatch);
      return;
    }
    
    // ÁØÑÂõ≤ÊåáÂÆöÁΩÆÊèõ
    const rangeSubMatch = cmd.match(/^(\d+),(\d+)s\/(.+?)\/(.*)\/([gic]*)$/);
    if (rangeSubMatch) {
      this.substituteRange(rangeSubMatch);
      return;
    }
    
    const parts = cmd.trim().split(/\s+/);
    const command = parts[0];
    
    switch(command) {
      case 'w':
        if (parts[1]) {
          // „Éï„Ç°„Ç§„É´ÂêçÊåáÂÆö„ÅÇ„Çä ‚Üí Áõ¥Êé•„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
          this.downloadFile(parts[1]);
        } else {
          // „Éï„Ç°„Ç§„É´Âêç„Å™„Åó ‚Üí ‰øùÂ≠ò„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÇíÈñã„Åè
          this.saveWithDialog();
        }
        break;
      case 'q':
        if (this.modified) {
          this.showStatus('Unsaved changes! Use :q! to force quit');
        } else {
          this.showStatus('Close browser to exit');
        }
        break;
      case 'q!':
        this.showStatus('Close browser to exit');
        break;
      case 'wq': case 'x':
        this.saveWithDialog();
        break;
      case 'e': case 'edit': case 'open':
        if (parts[1]) {
          // „Éï„Ç°„Ç§„É´ÂêçÊåáÂÆö ‚Üí New file„Å®„Åó„Å¶Êâ±„ÅÜ
          if (this.modified) {
            this.showStatus('Unsaved changes! Use :e! to force');
          } else {
            this.editor.value = '';
            this.fileName.textContent = parts[1];
            this.currentFileName = parts[1];
            this.modified = false;
            this.updateFileStatus();
            this.onInput();
          }
        } else {
          // „Éï„Ç°„Ç§„É´ÈÅ∏Êäû„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÇíÈñã„Åè
          this.openWithDialog();
        }
        break;
      case 'e!':
        // Âº∑Âà∂ÁöÑ„Å´Êñ∞Ë¶è/Èñã„Åè
        if (parts[1]) {
          this.editor.value = '';
          this.fileName.textContent = parts[1];
          this.currentFileName = parts[1];
          this.modified = false;
          this.updateFileStatus();
          this.onInput();
        } else {
          this.openWithDialog();
        }
        break;
      case 'saveas': case 'sav':
        if (parts[1]) {
          this.downloadFile(parts[1]);
        } else {
          this.saveWithDialog();
        }
        break;
      case 'read': case 'r':
        // „Ç´„Éº„ÇΩ„É´‰ΩçÁΩÆ„Å´„Éï„Ç°„Ç§„É´„ÇíÊåøÂÖ•
        this.openFileDialog(true);
        break;
      case 'new':
        // New file
        if (this.modified) {
          this.showStatus('Unsaved changes!');
        } else {
          this.newFile();
        }
        break;
      case 'new!':
        this.newFile();
        break;
      case 'welcome':
        // Show welcome screen
        this.showWelcome();
        break;
      case 'set':
        if (parts[1] === 'nu' || parts[1] === 'number') {
          this.lineNumbers.style.display = 'block';
        } else if (parts[1] === 'nonu' || parts[1] === 'nonumber') {
          this.lineNumbers.style.display = 'none';
        } else if (parts[1] === 'vim') {
          this.setVimMode(true);
        } else if (parts[1] === 'novim') {
          this.setVimMode(false);
        } else if (parts[1] && parts[1].startsWith('theme=')) {
          const theme = parts[1].split('=')[1];
          if (['dark', 'light', 'original'].includes(theme)) {
            setTheme(theme);
          } else {
            this.showStatus('Invalid theme: choose dark, light, or original');
          }
        } else if (parts[1] === 'theme') {
          const current = document.documentElement.getAttribute('data-theme') || 'dark';
          this.showStatus(`Current theme: ${current}`);
        }
        break;
      case 'theme':
        if (parts[1] && ['dark', 'light', 'original'].includes(parts[1])) {
          setTheme(parts[1]);
        } else {
          this.showStatus('Usage: :theme dark|light|original');
        }
        break;
      case 'dark':
        setTheme('dark');
        break;
      case 'light':
        setTheme('light');
        break;
      case 'original':
        setTheme('original');
        break;
      case 'marks':
        this.showMarks();
        break;
      case 'help': case 'h':
        toggleHelp();
        break;
      case 'ls':
        this.save();
        this.showStatus('Saved to localStorage');
        break;
      default:
        const lineNum = parseInt(command);
        if (!isNaN(lineNum)) {
          this.gotoLine(lineNum);
        } else {
          this.showStatus('Unknown command: ' + command);
        }
    }
  },
  
  // ÁΩÆÊèõ„Ç≥„Éû„É≥„Éâ
  substitute(match) {
    const [, global, pattern, replacement, flags] = match;
    const isGlobal = flags.includes('g');
    
    this.saveState();
    
    if (global === '%') {
      // ÂÖ®ÁΩÆÊèõ
      const regex = new RegExp(pattern, isGlobal ? 'g' : '');
      const oldValue = this.editor.value;
      this.editor.value = oldValue.replace(regex, replacement);
      const count = (oldValue.match(new RegExp(pattern, 'g')) || []).length;
      this.showStatus(`${count} replaced`);
    } else {
      // ÁèæÂú®Ë°å„ÅÆ„Åø
      const text = this.editor.value;
      const pos = this.editor.selectionStart;
      const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
      let lineEnd = text.indexOf('\n', pos);
      if (lineEnd === -1) lineEnd = text.length;
      
      const line = text.substring(lineStart, lineEnd);
      const regex = new RegExp(pattern, isGlobal ? 'g' : '');
      const newLine = line.replace(regex, replacement);
      
      this.editor.value = text.substring(0, lineStart) + newLine + text.substring(lineEnd);
      this.showStatus('Replaced');
    }
    
    this.onInput();
  },
  
  substituteRange(match) {
    const [, startLine, endLine, pattern, replacement, flags] = match;
    const isGlobal = flags.includes('g');
    const start = parseInt(startLine);
    const end = parseInt(endLine);
    
    this.saveState();
    
    const lines = this.editor.value.split('\n');
    const regex = new RegExp(pattern, isGlobal ? 'g' : '');
    let count = 0;
    
    for (let i = start - 1; i < end && i < lines.length; i++) {
      const matches = lines[i].match(new RegExp(pattern, 'g'));
      if (matches) count += matches.length;
      lines[i] = lines[i].replace(regex, replacement);
    }
    
    this.editor.value = lines.join('\n');
    this.showStatus(`${count} replaced`);
    this.onInput();
  },
  
  showMarks() {
    const markList = Object.entries(this.marks)
      .map(([k, v]) => `'${k}: ${v}`)
      .join(', ');
    this.showStatus(markList || 'No marks');
  },
  
  // Ë°åÂÜÖÊ§úÁ¥¢
  findCharInLine(char, direction, beforeChar) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    
    let newPos = -1;
    
    if (direction > 0) {
      // ÂâçÊñπÊ§úÁ¥¢
      for (let i = pos + 1; i < lineEnd; i++) {
        if (text[i] === char) {
          newPos = beforeChar ? i - 1 : i;
          break;
        }
      }
    } else {
      // ÂæåÊñπÊ§úÁ¥¢
      for (let i = pos - 1; i >= lineStart; i--) {
        if (text[i] === char) {
          newPos = beforeChar ? i + 1 : i;
          break;
        }
      }
    }
    
    if (newPos >= lineStart && newPos < lineEnd) {
      this.editor.selectionStart = newPos;
      this.editor.selectionEnd = newPos;
    }
  },
  
  repeatFindChar(directionMultiplier) {
    if (this.lastFindChar) {
      const direction = this.lastFindDirection * directionMultiplier;
      const beforeChar = this.lastFindType === 't';
      this.findCharInLine(this.lastFindChar, direction, beforeChar);
    }
  },
  
  // „Éë„É©„Ç∞„É©„ÉïÁßªÂãï
  moveParagraph(direction) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lines = text.split('\n');
    
    // ÁèæÂú®„ÅÆË°åÁï™Âè∑„ÇíË®àÁÆó
    let currentLine = 0;
    let charCount = 0;
    for (let i = 0; i < lines.length; i++) {
      if (charCount + lines[i].length >= pos) {
        currentLine = i;
        break;
      }
      charCount += lines[i].length + 1;
    }
    
    let targetLine = currentLine;
    
    if (direction > 0) {
      // Ê¨°„ÅÆÁ©∫Ë°å„ÇíÊé¢„ÅôÔºà}Ôºâ
      // „Åæ„ÅöÁèæÂú®„ÅÆÁ©∫Ë°å„Éñ„É≠„ÉÉ„ÇØ„Çí„Çπ„Ç≠„ÉÉ„Éó
      while (targetLine < lines.length && lines[targetLine].trim() === '') {
        targetLine++;
      }
      // Ê¨°„ÅÆÁ©∫Ë°å„ÇíË¶ã„Å§„Åë„Çã
      while (targetLine < lines.length && lines[targetLine].trim() !== '') {
        targetLine++;
      }
    } else {
      // Ââç„ÅÆÁ©∫Ë°å„ÇíÊé¢„ÅôÔºà{Ôºâ
      // „Åæ„ÅöÁèæÂú®Ë°å„Åã„Çâ1„Å§Êàª„Çã
      targetLine--;
      // ÁèæÂú®„ÅÆÁ©∫Ë°å„Éñ„É≠„ÉÉ„ÇØ„Çí„Çπ„Ç≠„ÉÉ„Éó
      while (targetLine >= 0 && lines[targetLine].trim() === '') {
        targetLine--;
      }
      // Ââç„ÅÆÁ©∫Ë°å„ÇíË¶ã„Å§„Åë„Çã
      while (targetLine >= 0 && lines[targetLine].trim() !== '') {
        targetLine--;
      }
      // Ë¶ã„Å§„Åã„Çâ„Å™„Åë„Çå„Å∞ÂÖàÈ†≠„Å∏
      if (targetLine < 0) targetLine = 0;
    }
    
    // targetLine„ÅåÁØÑÂõ≤Â§ñ„Å™„ÇâË£úÊ≠£
    targetLine = Math.max(0, Math.min(targetLine, lines.length - 1));
    
    // Êñ∞„Åó„ÅÑ‰ΩçÁΩÆ„ÇíË®àÁÆó
    let newPos = 0;
    for (let i = 0; i < targetLine; i++) {
      newPos += lines[i].length + 1;
    }
    
    this.previousPosition = pos;
    this.editor.selectionStart = newPos;
    this.editor.selectionEnd = newPos;
    this.scrollToCursor();
    this.updateCursorPos();
  },
  
  // Êã¨Âºß„Ç∏„É£„É≥„Éó
  jumpToMatchingBracket() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const char = text[pos];
    
    const pairs = { '(': ')', ')': '(', '[': ']', ']': '[', '{': '}', '}': '{', '<': '>', '>': '<' };
    const openBrackets = '([{<';
    
    if (!pairs[char]) {
      // ÁèæÂú®‰ΩçÁΩÆ„Å´Êã¨Âºß„Åå„Å™„ÅÑÂ†¥Âêà„ÄÅË°åÂÜÖ„ÅßÊúÄÂàù„ÅÆÊã¨Âºß„ÇíÊé¢„Åô
      const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
      let lineEnd = text.indexOf('\n', pos);
      if (lineEnd === -1) lineEnd = text.length;
      
      for (let i = pos; i < lineEnd; i++) {
        if (pairs[text[i]]) {
          this.editor.selectionStart = i;
          this.editor.selectionEnd = i;
          this.jumpToMatchingBracket();
          return;
        }
      }
      return;
    }
    
    const target = pairs[char];
    const isOpen = openBrackets.includes(char);
    let depth = 0;
    
    if (isOpen) {
      for (let i = pos; i < text.length; i++) {
        if (text[i] === char) depth++;
        else if (text[i] === target) {
          depth--;
          if (depth === 0) {
            this.previousPosition = pos;
            this.editor.selectionStart = i;
            this.editor.selectionEnd = i;
            this.scrollToCursor();
            return;
          }
        }
      }
    } else {
      for (let i = pos; i >= 0; i--) {
        if (text[i] === char) depth++;
        else if (text[i] === target) {
          depth--;
          if (depth === 0) {
            this.previousPosition = pos;
            this.editor.selectionStart = i;
            this.editor.selectionEnd = i;
            this.scrollToCursor();
            return;
          }
        }
      }
    }
  },
  
  // „Éû„ÇØ„É≠
  startRecordingMacro(name) {
    this.recordingMacro = name;
    this.macroBuffer = [];
    this.macroIndicator.classList.add('active');
    this.modeIndicator.classList.add('recording');
    this.showStatus(`Recording macro '${name}'`);
  },
  
  stopRecordingMacro() {
    this.macros[this.recordingMacro] = [...this.macroBuffer];
    this.showStatus(`Macro '${this.recordingMacro}' recorded (${this.macroBuffer.length} „Ç≠„Éº)`);
    this.recordingMacro = null;
    this.macroBuffer = [];
    this.macroIndicator.classList.remove('active');
    this.modeIndicator.classList.remove('recording');
  },
  
  playMacro(name) {
    const macro = this.macros[name];
    if (!macro || macro.length === 0) return;
    
    this.lastMacro = name;
    
    // „Éû„ÇØ„É≠ÂÜçÁîü‰∏≠„ÅØË®òÈå≤„Åó„Å™„ÅÑ
    const wasRecording = this.recordingMacro;
    this.recordingMacro = null;
    
    for (const keyInfo of macro) {
      const event = new KeyboardEvent('keydown', {
        key: keyInfo.key,
        ctrlKey: keyInfo.ctrlKey || false,
        shiftKey: keyInfo.shiftKey || false
      });
      
      if (this.mode === 'insert') {
        if (keyInfo.key === 'Escape') {
          this.exitInsertMode();
        } else if (keyInfo.key.length === 1) {
          this.insertText(keyInfo.key);
        }
      } else {
        this.handleNormalMode(event);
      }
    }
    
    this.recordingMacro = wasRecording;
  },
  
  // „Éâ„ÉÉ„Éà„É™„Éî„Éº„Éà
  setLastEdit(type, char = null, count = 1) {
    this.lastEdit = { type, char, count, insertedText: '' };
  },
  
  repeatLastEdit(count) {
    if (!this.lastEdit) return;
    
    const repeat = count || this.lastEdit.count || 1;
    
    for (let i = 0; i < repeat; i++) {
      this.saveState();
      
      switch(this.lastEdit.type) {
        case 'x':
          this.deleteChar();
          break;
        case 'X':
          this.deleteCharBefore();
          break;
        case 'dd':
          this.deleteLine();
          break;
        case 'dw':
          this.deleteWord();
          break;
        case 'd$':
        case 'D':
          this.deleteToLineEnd();
          break;
        case 'd0':
          this.deleteToLineStart();
          break;
        case 'cc':
        case 'S':
          this.deleteLineContent();
          this.insertText(this.lastEdit.insertedText || '');
          break;
        case 'cw':
          this.deleteWord();
          this.insertText(this.lastEdit.insertedText || '');
          break;
        case 'C':
          this.deleteToLineEnd();
          this.insertText(this.lastEdit.insertedText || '');
          break;
        case 'r':
          this.replaceChar(this.lastEdit.char);
          break;
        case 's':
          this.deleteChar();
          this.insertText(this.lastEdit.insertedText || '');
          break;
        case 'o':
          this.moveToLineEnd();
          this.insertText('\n' + (this.lastEdit.insertedText || ''));
          break;
        case 'O':
          this.moveToLineStart();
          this.insertText((this.lastEdit.insertedText || '') + '\n');
          this.moveVertical(-1);
          break;
        case 'insert':
          this.insertText(this.lastEdit.insertedText || '');
          break;
        case '~':
          this.toggleCase();
          break;
        case '>>':
          this.indentLine(1);
          break;
        case '<<':
          this.indentLine(-1);
          break;
        case 'J':
          this.joinLines();
          break;
        // „ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
        case 'diw': case 'daw': case 'ciw': case 'caw':
        case 'di"': case 'da"': case "di'": case "da'":
        case 'di(': case 'da(': case 'di[': case 'da[':
        case 'di{': case 'da{': case 'di`': case 'da`':
          const op = this.lastEdit.type[0];
          const inner = this.lastEdit.type[1] === 'i';
          const objChar = this.lastEdit.type[2];
          this.handleTextObject(op + (inner ? 'i' : 'a'), objChar);
          if (op === 'c') {
            this.insertText(this.lastEdit.insertedText || '');
          }
          break;
      }
    }
  },
  
  // Â§ßÊñáÂ≠ó/Â∞èÊñáÂ≠óÂàáÊõø
  toggleCase() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    if (pos < text.length) {
      const char = text[pos];
      let newChar;
      if (char === char.toLowerCase()) {
        newChar = char.toUpperCase();
      } else {
        newChar = char.toLowerCase();
      }
      
      this.editor.value = text.substring(0, pos) + newChar + text.substring(pos + 1);
      this.editor.selectionStart = pos + 1;
      this.editor.selectionEnd = pos + 1;
      this.onInput();
    }
  },
  
  toggleCaseSelection(start, end) {
    const text = this.editor.value;
    let result = '';
    
    for (let i = start; i < end; i++) {
      const char = text[i];
      if (char === char.toLowerCase()) {
        result += char.toUpperCase();
      } else {
        result += char.toLowerCase();
      }
    }
    
    this.editor.value = text.substring(0, start) + result + text.substring(end);
    this.editor.selectionStart = start;
    this.editor.selectionEnd = start;
    this.onInput();
  },
  
  changeCaseSelection(start, end, caseType) {
    const text = this.editor.value;
    const selected = text.substring(start, end);
    const changed = caseType === 'upper' ? selected.toUpperCase() : selected.toLowerCase();
    
    this.editor.value = text.substring(0, start) + changed + text.substring(end);
    this.editor.selectionStart = start;
    this.editor.selectionEnd = start;
    this.onInput();
  },
  
  // „Ç§„É≥„Éá„É≥„Éà
  indentLine(direction) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    
    const line = text.substring(lineStart, lineEnd);
    let newLine;
    
    if (direction > 0) {
      newLine = '  ' + line;
    } else {
      newLine = line.replace(/^  /, '').replace(/^\t/, '');
    }
    
    this.editor.value = text.substring(0, lineStart) + newLine + text.substring(lineEnd);
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineStart;
    this.onInput();
  },
  
  indentSelection(direction) {
    const text = this.editor.value;
    const start = this.editor.selectionStart;
    const end = this.editor.selectionEnd;
    
    const lineStart = text.lastIndexOf('\n', start - 1) + 1;
    let lineEnd = text.indexOf('\n', end - 1);
    if (lineEnd === -1) lineEnd = text.length;
    
    const selectedLines = text.substring(lineStart, lineEnd).split('\n');
    const newLines = selectedLines.map(line => {
      if (direction > 0) {
        return '  ' + line;
      } else {
        return line.replace(/^  /, '').replace(/^\t/, '');
      }
    });
    
    this.editor.value = text.substring(0, lineStart) + newLines.join('\n') + text.substring(lineEnd);
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineStart;
    this.onInput();
  },
  
  // ÁßªÂãïÁ≥ª
  moveCursor(delta) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const newPos = Math.max(0, Math.min(text.length, pos + delta));
    this.editor.selectionStart = newPos;
    this.editor.selectionEnd = newPos;
  },
  
  moveVertical(direction) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lines = text.substring(0, pos).split('\n');
    const currentLine = lines.length - 1;
    const currentCol = lines[lines.length - 1].length;
    const allLines = text.split('\n');
    
    const targetLine = currentLine + direction;
    if (targetLine < 0 || targetLine >= allLines.length) return;
    
    let newPos = 0;
    for (let i = 0; i < targetLine; i++) newPos += allLines[i].length + 1;
    newPos += Math.min(currentCol, allLines[targetLine].length);
    
    this.editor.selectionStart = newPos;
    this.editor.selectionEnd = newPos;
  },
  
  moveWord(direction) {
    const text = this.editor.value;
    let pos = this.editor.selectionStart;
    
    if (direction > 0) {
      const match = text.substring(pos).match(/^\s*\S+\s*/);
      if (match) pos += match[0].length;
    } else {
      const before = text.substring(0, pos);
      const match = before.match(/\S+\s*$/);
      if (match) pos -= match[0].length;
    }
    
    this.editor.selectionStart = pos;
    this.editor.selectionEnd = pos;
  },
  
  moveWordEnd() {
    const text = this.editor.value;
    let pos = this.editor.selectionStart;
    const match = text.substring(pos + 1).match(/^\s*\S*/);
    if (match) pos += match[0].length;
    this.editor.selectionStart = pos;
    this.editor.selectionEnd = pos;
  },
  
  moveToLineStart() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineStart;
  },
  
  moveToLineEnd() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    this.editor.selectionStart = lineEnd;
    this.editor.selectionEnd = lineEnd;
  },
  
  moveToFirstNonSpace() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    const line = text.substring(lineStart, lineEnd);
    const match = line.match(/^\s*/);
    const newPos = lineStart + (match ? match[0].length : 0);
    this.editor.selectionStart = newPos;
    this.editor.selectionEnd = newPos;
  },
  
  moveToStart() { 
    this.previousPosition = this.editor.selectionStart;
    this.editor.selectionStart = 0; 
    this.editor.selectionEnd = 0;
    this.editor.scrollTop = 0;
  },
  
  moveToEnd() { 
    this.previousPosition = this.editor.selectionStart;
    const len = this.editor.value.length; 
    this.editor.selectionStart = len; 
    this.editor.selectionEnd = len;
    this.editor.scrollTop = this.editor.scrollHeight;
  },
  
  gotoLine(lineNum) {
    this.previousPosition = this.editor.selectionStart;
    const lines = this.editor.value.split('\n');
    const targetLine = Math.min(Math.max(1, lineNum), lines.length) - 1;
    let pos = 0;
    for (let i = 0; i < targetLine; i++) pos += lines[i].length + 1;
    this.editor.selectionStart = pos;
    this.editor.selectionEnd = pos;
    this.scrollToCursor();
    this.editor.focus();
    this.updateCursorPos();
  },
  
  gotoPosition(pos) {
    this.editor.selectionStart = pos;
    this.editor.selectionEnd = pos;
    this.scrollToCursor();
    this.editor.focus();
    this.updateCursorPos();
  },
  
  selectCurrentLine() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    else lineEnd++;
    this.visualStart = lineStart;
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineEnd;
  },
  
  // Á∑®ÈõÜÁ≥ª
  insertText(text) {
    const pos = this.editor.selectionStart;
    const before = this.editor.value.substring(0, pos);
    const after = this.editor.value.substring(this.editor.selectionEnd);
    this.editor.value = before + text + after;
    this.editor.selectionStart = pos + text.length;
    this.editor.selectionEnd = this.editor.selectionStart;
    this.onInput();
  },
  
  deleteChar() {
    const pos = this.editor.selectionStart;
    const text = this.editor.value;
    if (pos < text.length) {
      this.editor.value = text.substring(0, pos) + text.substring(pos + 1);
      this.editor.selectionStart = pos;
      this.editor.selectionEnd = pos;
      this.onInput();
    }
    this.editor.focus();
    this.updateCursorPos();
  },
  
  deleteCharBefore() {
    const pos = this.editor.selectionStart;
    if (pos > 0) {
      this.editor.value = this.editor.value.substring(0, pos - 1) + this.editor.value.substring(pos);
      this.editor.selectionStart = pos - 1;
      this.editor.selectionEnd = pos - 1;
      this.onInput();
    }
    this.editor.focus();
    this.updateCursorPos();
  },
  
  deleteLine() {
    const text = this.editor.value;
    if (text.length === 0) return;
    
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    
    if (lineEnd === -1) {
      lineEnd = text.length;
      if (lineStart > 0) {
        this.register = text.substring(lineStart, lineEnd) + '\n';
        this.editor.value = text.substring(0, lineStart - 1);
        this.editor.selectionStart = Math.max(0, lineStart - 1);
        this.editor.selectionEnd = this.editor.selectionStart;
      } else {
        this.register = text.substring(lineStart, lineEnd) + '\n';
        this.editor.value = '';
        this.editor.selectionStart = 0;
        this.editor.selectionEnd = 0;
      }
    } else {
      lineEnd++;
      this.register = text.substring(lineStart, lineEnd);
      this.editor.value = text.substring(0, lineStart) + text.substring(lineEnd);
      const newPos = Math.min(lineStart, this.editor.value.length);
      this.editor.selectionStart = newPos;
      this.editor.selectionEnd = newPos;
    }
    
    this.editor.focus();
    this.onInput();
    this.updateCursorPos();
  },
  
  deleteLineContent() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    
    // „Ç§„É≥„Éá„É≥„Éà„Çí‰øùÊåÅ
    const line = text.substring(lineStart, lineEnd);
    const indent = line.match(/^\s*/)[0];
    
    this.register = line;
    this.editor.value = text.substring(0, lineStart) + indent + text.substring(lineEnd);
    this.editor.selectionStart = lineStart + indent.length;
    this.editor.selectionEnd = lineStart + indent.length;
    this.onInput();
  },
  
  deleteWord() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const match = text.substring(pos).match(/^\S*\s*/);
    if (match) {
      this.register = match[0];
      this.editor.value = text.substring(0, pos) + text.substring(pos + match[0].length);
      this.onInput();
    }
  },
  
  deleteToLineEnd() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    
    this.register = text.substring(pos, lineEnd);
    this.editor.value = text.substring(0, pos) + text.substring(lineEnd);
    this.onInput();
  },
  
  deleteToLineStart() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    
    this.register = text.substring(lineStart, pos);
    this.editor.value = text.substring(0, lineStart) + text.substring(pos);
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineStart;
    this.onInput();
  },
  
  deleteSelection() {
    const start = this.editor.selectionStart;
    const end = this.editor.selectionEnd;
    this.editor.value = this.editor.value.substring(0, start) + this.editor.value.substring(end);
    this.editor.selectionStart = start;
    this.editor.selectionEnd = start;
    this.onInput();
  },
  
  replaceChar(char) {
    const pos = this.editor.selectionStart;
    const text = this.editor.value;
    if (pos < text.length) {
      this.editor.value = text.substring(0, pos) + char + text.substring(pos + 1);
      this.onInput();
    }
  },
  
  joinLines() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) return;
    
    // Ê¨°„ÅÆË°å„ÅÆÂÖàÈ†≠„ÅÆÁ©∫ÁôΩ„ÇíÂèñÂæó
    const nextLineStart = lineEnd + 1;
    const nextLineMatch = text.substring(nextLineStart).match(/^\s*/);
    const nextLineIndent = nextLineMatch ? nextLineMatch[0].length : 0;
    
    this.editor.value = text.substring(0, lineEnd) + ' ' + text.substring(nextLineStart + nextLineIndent);
    this.editor.selectionStart = lineEnd;
    this.editor.selectionEnd = lineEnd;
    this.onInput();
  },
  
  // „É§„É≥„ÇØ/„Éö„Éº„Çπ„Éà
  yankLine() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    else lineEnd++;
    
    this.register = text.substring(lineStart, lineEnd);
    this.showStatus('Line yanked');
  },
  
  yankWord() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const match = text.substring(pos).match(/^\S+/);
    if (match) {
      this.register = match[0];
      this.showStatus('Yanked');
    }
  },
  
  paste() {
    if (!this.register) return;
    
    if (this.register.endsWith('\n')) {
      let lineEnd = this.editor.value.indexOf('\n', this.editor.selectionStart);
      if (lineEnd === -1) lineEnd = this.editor.value.length;
      this.editor.selectionStart = lineEnd;
      this.editor.selectionEnd = lineEnd;
      this.insertText('\n' + this.register.slice(0, -1));
    } else {
      this.moveCursor(1);
      this.insertText(this.register);
    }
  },
  
  pasteBefore() {
    if (!this.register) return;
    
    if (this.register.endsWith('\n')) {
      this.moveToLineStart();
      this.insertText(this.register);
      this.moveToLineStart();
    } else {
      this.insertText(this.register);
    }
  },
  
  // „Ç¢„É≥„Éâ„Ç•/„É™„Éâ„Ç•
  saveState() {
    this.undoStack.push({ text: this.editor.value, pos: this.editor.selectionStart });
    this.redoStack = [];
    if (this.undoStack.length > 100) this.undoStack.shift();
  },
  
  undo() {
    if (this.undoStack.length === 0) { this.showStatus('Nothing to undo'); return; }
    this.redoStack.push({ text: this.editor.value, pos: this.editor.selectionStart });
    const state = this.undoStack.pop();
    this.editor.value = state.text;
    this.editor.selectionStart = state.pos;
    this.editor.selectionEnd = state.pos;
    this.onInput();
    this.showStatus('Undone');
  },
  
  redo() {
    if (this.redoStack.length === 0) { this.showStatus('Nothing to redo'); return; }
    this.undoStack.push({ text: this.editor.value, pos: this.editor.selectionStart });
    const state = this.redoStack.pop();
    this.editor.value = state.text;
    this.editor.selectionStart = state.pos;
    this.editor.selectionEnd = state.pos;
    this.onInput();
    this.showStatus('Redone');
  },
  
  // Ê§úÁ¥¢
  search(term) { this.searchTerm = term; this.findNext(); },
  
  searchWordUnderCursor() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    let start = pos;
    let end = pos;
    while (start > 0 && /\w/.test(text[start - 1])) start--;
    while (end < text.length && /\w/.test(text[end])) end++;
    
    if (start < end) {
      this.searchTerm = text.substring(start, end);
      this.findNext();
    }
  },
  
  findNext() {
    if (!this.searchTerm) return;
    const text = this.editor.value;
    const pos = this.editor.selectionStart + 1;
    let idx = text.indexOf(this.searchTerm, pos);
    
    if (idx === -1) idx = text.indexOf(this.searchTerm);
    
    if (idx !== -1) {
      this.previousPosition = this.editor.selectionStart;
      this.editor.selectionStart = idx;
      this.editor.selectionEnd = idx + this.searchTerm.length;
      this.scrollToCursor();
      this.showStatus('/' + this.searchTerm);
    } else {
      this.showStatus('Not found: ' + this.searchTerm);
    }
    this.editor.focus();
    this.updateCursorPos();
  },
  
  findPrev() {
    if (!this.searchTerm) return;
    const text = this.editor.value;
    const pos = this.editor.selectionStart - 1;
    let idx = text.lastIndexOf(this.searchTerm, pos);
    
    if (idx === -1) idx = text.lastIndexOf(this.searchTerm);
    
    if (idx !== -1) {
      this.previousPosition = this.editor.selectionStart;
      this.editor.selectionStart = idx;
      this.editor.selectionEnd = idx + this.searchTerm.length;
      this.scrollToCursor();
      this.showStatus('/' + this.searchTerm);
    } else {
      this.showStatus('Not found: ' + this.searchTerm);
    }
    this.editor.focus();
    this.updateCursorPos();
  },
  
  // Save
  save() {
    this.saveSessionData();
    this.modified = false;
    this.updateFileStatus();
    this.showStatus('Saved');
  },
  
  // Save session data
  saveSessionData() {
    // Save to sessionStorage (for tab restore)
    sessionStorage.setItem('vim-md-content-' + this.sessionId, this.editor.value);
    
    // Save to localStorage per session
    const sessionData = {
      content: this.editor.value,
      filename: this.currentFileName || 'Untitled',
      timestamp: Date.now()
    };
    localStorage.setItem('vim-md-session-' + this.sessionId, JSON.stringify(sessionData));
    
    // Update session list
    let sessions = [];
    try {
      sessions = JSON.parse(localStorage.getItem('vim-md-sessions') || '[]');
    } catch (e) {
      sessions = [];
    }
    if (!sessions.includes(this.sessionId)) {
      sessions.push(this.sessionId);
      localStorage.setItem('vim-md-sessions', JSON.stringify(sessions));
    }
    
    // Cleanup old sessions (older than 7 days)
    this.cleanupOldSessions();
  },
  
  // Remove old sessions
  cleanupOldSessions() {
    const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days
    const now = Date.now();
    let sessions = [];
    try {
      sessions = JSON.parse(localStorage.getItem('vim-md-sessions') || '[]');
    } catch (e) {
      return;
    }
    
    const validSessions = sessions.filter(sid => {
      if (sid === this.sessionId) return true; // Keep current session
      try {
        const data = JSON.parse(localStorage.getItem('vim-md-session-' + sid) || '{}');
        if (data.timestamp && (now - data.timestamp) > maxAge) {
          localStorage.removeItem('vim-md-session-' + sid);
          return false;
        }
        return true;
      } catch (e) {
        localStorage.removeItem('vim-md-session-' + sid);
        return false;
      }
    });
    
    if (validSessions.length !== sessions.length) {
      localStorage.setItem('vim-md-sessions', JSON.stringify(validSessions));
    }
  },
  
  // Auto-save
  autoSave() {
    this.saveSessionData();
  },
  
  // „ÉÄ„Ç§„Ç¢„É≠„Ç∞„Åß‰øùÂ≠ò
  async saveWithDialog() {
    // File System Access API „Åå‰Ωø„Åà„Çã„ÅãÁ¢∫Ë™ç
    if ('showSaveFilePicker' in window) {
      try {
        const handle = await window.showSaveFilePicker({
          suggestedName: this.currentFileName || 'document.md',
          types: [{
            description: 'Markdown Files',
            accept: { 'text/markdown': ['.md', '.markdown'] }
          }, {
            description: 'Text Files',
            accept: { 'text/plain': ['.txt'] }
          }]
        });
        
        const writable = await handle.createWritable();
        await writable.write(this.editor.value);
        await writable.close();
        
        this.currentFileName = handle.name;
        this.fileName.textContent = handle.name;
        this.currentFileHandle = handle;
        this.modified = false;
        this.updateFileStatus();
        this.showStatus(`"${handle.name}" „ÇíSaved`);
      } catch (err) {
        if (err.name !== 'AbortError') {
          this.showStatus('Save cancelled');
        }
      }
    } else {
      // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Éó„É≠„É≥„Éó„Éà„Åß„Éï„Ç°„Ç§„É´Âêç„ÇíÂÖ•Âäõ
      const filename = prompt('„Éï„Ç°„Ç§„É´Âêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ:', this.currentFileName || 'document.md');
      if (filename) {
        this.downloadFile(filename);
      }
    }
  },
  
  // „ÉÄ„Ç§„Ç¢„É≠„Ç∞„Åß„Éï„Ç°„Ç§„É´„ÇíÈñã„Åè
  async openWithDialog() {
    // File System Access API „Åå‰Ωø„Åà„Çã„ÅãÁ¢∫Ë™ç
    if ('showOpenFilePicker' in window) {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{
            description: 'Markdown Files',
            accept: { 'text/markdown': ['.md', '.markdown'] }
          }, {
            description: 'Text Files',
            accept: { 'text/plain': ['.txt'] }
          }],
          multiple: false
        });
        
        const file = await handle.getFile();
        const content = await file.text();
        
        this.undoStack = [];
        this.redoStack = [];
        this.editor.value = content;
        this.fileName.textContent = file.name;
        this.currentFileName = file.name;
        this.currentFileHandle = handle;
        this.modified = false;
        this.updateFileStatus();
        this.updateLineNumbers();
        this.updatePreview();
        this.editor.selectionStart = 0;
        this.editor.selectionEnd = 0;
        this.updateCursorPos();
        this.saveState();
        this.showStatus(`"${file.name}" opened`);
      } catch (err) {
        if (err.name !== 'AbortError') {
          this.showStatus('Failed to open file');
        }
      }
    } else {
      // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: inputË¶ÅÁ¥†„Çí‰ΩøÁî®
      this.openFileDialog(false);
    }
  },
  
  // New file
  newFile() {
    this.undoStack = [];
    this.redoStack = [];
    this.editor.value = '';
    this.fileName.textContent = 'Untitled';
    this.currentFileName = 'Untitled';
    this.currentFileHandle = null;
    this.modified = false;
    this.updateFileStatus();
    this.updateLineNumbers();
    this.updatePreview();
    this.updateToc();
    this.updateHeadingHighlight();
    this.editor.selectionStart = 0;
    this.editor.selectionEnd = 0;
    this.updateCursorPos();
    this.saveState();
    this.showStatus('New file');
  },
  
  // „Éï„Ç°„Ç§„É´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
  downloadFile(filename) {
    // Êã°ÂºµÂ≠ê„Åå„Å™„Åë„Çå„Å∞ .md „ÇíËøΩÂä†
    if (!filename.includes('.')) {
      filename += '.md';
    }
    
    const blob = new Blob([this.editor.value], { type: 'text/markdown;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    this.fileName.textContent = filename;
    this.currentFileName = filename;
    this.modified = false;
    this.updateFileStatus();
    this.showStatus(`"${filename}" „ÇíSaved`);
  },
  
  // „Éï„Ç°„Ç§„É´ÈÅ∏Êäû„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÇíÈñã„Åè
  openFileDialog(insertMode = false) {
    this.fileInsertMode = insertMode;
    this.fileInput.click();
  },
  
  // „Éï„Ç°„Ç§„É´„ÇíÈñã„Åè
  handleFileOpen(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      const content = event.target.result;
      
      if (this.fileInsertMode) {
        // Insert at cursor position
        this.saveState();
        this.insertText(content);
        this.updateToc();
        this.showStatus(`"${file.name}" inserted`);
      } else {
        // Replace entire file
        this.undoStack = [];
        this.redoStack = [];
        this.editor.value = content;
        this.fileName.textContent = file.name;
        this.currentFileName = file.name;
        this.modified = false;
        this.updateFileStatus();
        this.updateLineNumbers();
        this.updatePreview();
        this.updateToc();
        this.updateHeadingHighlight();
        this.editor.selectionStart = 0;
        this.editor.selectionEnd = 0;
        this.updateCursorPos();
        this.saveState();
        this.showStatus(`"${file.name}" opened`);
      }
      
      this.fileInsertMode = false;
    };
    
    reader.onerror = () => {
      this.showStatus('Failed to read file');
    };
    
    reader.readAsText(file);
    
    // Reset to allow selecting the same file again
    this.fileInput.value = '';
  },
  
  // UI
  setMode(mode) {
    this.mode = mode;
    if (this.vimMode) {
      this.modeIndicator.textContent = mode.toUpperCase();
      this.modeIndicator.className = mode;
      this.modeIndicator.style.opacity = '';
      if (this.recordingMacro) this.modeIndicator.classList.add('recording');
    }
    
    if (mode === 'command') {
      this.commandLine.classList.remove('hidden');
      this.commandInput.focus();
    } else {
      this.commandLine.classList.add('hidden');
      this.editor.focus();
    }
    
    // VIM„É¢„Éº„Éâ„ÅÆÂ†¥Âêà„ÅÆ„ÅøreadOnly„ÇíÂà∂Âæ°
    if (this.vimMode) {
      this.editor.readOnly = (mode !== 'insert');
    } else {
      this.editor.readOnly = false;
    }
    
    // „Ç´„Éº„ÇΩ„É´Ë°®Á§∫„ÅÆÊõ¥Êñ∞
    if (mode === 'insert') {
      this.editor.classList.add('insert-mode');
    } else {
      this.editor.classList.remove('insert-mode');
    }
    this.updateCursorOverlay();
  },
  
  onInput(e) {
    this.modified = true;
    this.updateFileStatus();
    this.updateLineNumbers();
    this.updatePreview();
    this.updateToc();
    this.updateHeadingHighlight();
    this.updateCursorPos();
    
    // ÊåøÂÖ•„É¢„Éº„Éâ„Åß„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàËøΩË∑°
    if (this.mode === 'insert' && e && e.data) {
      this.lastEditText += e.data;
    }
    
    // Ëá™Âãï‰øùÂ≠òÔºà„Éá„Éê„Ç¶„É≥„Çπ: 1ÁßíÂæå„Å´‰øùÂ≠òÔºâ
    clearTimeout(this.autoSaveTimer);
    this.autoSaveTimer = setTimeout(() => this.autoSave(), 1000);
  },
  
  updateCursorPos() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lines = text.substring(0, pos).split('\n');
    const line = lines.length;
    const col = lines[lines.length - 1].length + 1;
    this.cursorPos.textContent = `${line}:${col}`;
    this.updateCursorOverlay();
    
    // „Éó„É¨„Éì„É•„Éº„ÇíÁèæÂú®Ë°å„Å´ÂêåÊúü
    this.syncPreviewToLine(line - 1);
    
    // ÁõÆÊ¨°„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÁä∂ÊÖã„ÇíÊõ¥Êñ∞
    this.updateTocActive(line - 1);
  },
  
  updateCursorOverlay() {
    if (!this.cursorOverlay) return;
    
    // NOVIM„É¢„Éº„Éâ„Åß„ÅØ„Ç´„Éº„ÇΩ„É´„Ç™„Éº„Éê„Éº„É¨„Ç§„ÇíÈùûË°®Á§∫
    if (!this.vimMode) {
      this.cursorOverlay.style.display = 'none';
      return;
    }
    
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    // ÁèæÂú®Ë°å„Å®„Ç´„É©„É†„ÇíË®àÁÆó
    const textBeforeCursor = text.substring(0, pos);
    const lines = textBeforeCursor.split('\n');
    const currentLineIndex = lines.length - 1;
    const currentCol = lines[currentLineIndex];
    
    // Ë°å„ÅÆÈ´ò„Åï„Å®„Éë„Éá„Ç£„É≥„Ç∞„ÇíÂèñÂæó
    const style = getComputedStyle(this.editor);
    const lineHeight = parseFloat(style.lineHeight);
    const paddingTop = parseFloat(style.paddingTop);
    const paddingLeft = parseFloat(style.paddingLeft);
    
    // ÊñáÂ≠óÂπÖ„ÇíÊ∏¨ÂÆö
    this.measureSpan.textContent = currentCol || ' ';
    const charWidth = this.measureSpan.getBoundingClientRect().width / (currentCol.length || 1);
    const textWidth = currentCol.length * charWidth;
    
    // „Ç´„Éº„ÇΩ„É´‰ΩçÁΩÆ„ÇíË®àÁÆó
    const top = paddingTop + (currentLineIndex * lineHeight) - this.editor.scrollTop;
    const left = paddingLeft + textWidth - this.editor.scrollLeft;
    
    // „Ç´„Éº„ÇΩ„É´„ÅÆÊñáÂ≠óÔºà„Éñ„É≠„ÉÉ„ÇØ„Ç´„Éº„ÇΩ„É´Áî®Ôºâ
    const charAtCursor = text[pos] || ' ';
    const cursorWidth = charAtCursor === '\n' || charAtCursor === ' ' || pos >= text.length 
      ? charWidth 
      : charWidth;
    
    // „Ç™„Éº„Éê„Éº„É¨„Ç§„ÇíÈÖçÁΩÆ
    this.cursorOverlay.style.top = `${top}px`;
    this.cursorOverlay.style.left = `${left}px`;
    this.cursorOverlay.style.width = `${cursorWidth}px`;
    this.cursorOverlay.style.height = `${lineHeight}px`;
    
    // „É¢„Éº„Éâ„Å´Âøú„Åò„Å¶„ÇØ„É©„Çπ„ÇíË®≠ÂÆö
    this.cursorOverlay.className = this.mode;
    
    // ÁîªÈù¢Â§ñ„Å™„ÇâÈùûË°®Á§∫
    if (top < 0 || top > this.editor.clientHeight) {
      this.cursorOverlay.style.display = 'none';
    } else {
      this.cursorOverlay.style.display = 'block';
    }
  },
  
  updateFileStatus() { this.fileStatus.textContent = this.modified ? '[+]' : ''; },
  
  // Show status message
  showStatus(message, duration = 2000) {
    const helpHint = document.getElementById('help-hint');
    if (helpHint) {
      const originalText = 'Press ? for help';
      helpHint.textContent = message;
      if (this.statusTimeout) {
        clearTimeout(this.statusTimeout);
      }
      this.statusTimeout = setTimeout(() => {
        helpHint.textContent = originalText;
      }, duration);
    }
  },
  
  updateLineNumbers() {
    const lines = this.editor.value.split('\n');
    let html = '';
    let inCodeBlock = false;
    
    for (let i = 0; i < lines.length; i++) {
      const lineNum = i + 1;
      const line = lines[i];
      
      // „Ç≥„Éº„Éâ„Éñ„É≠„ÉÉ„ÇØ„ÅÆÈñãÂßã/ÁµÇ‰∫Ü„ÇíËøΩË∑°
      if (line.trim().startsWith('```')) {
        inCodeBlock = !inCodeBlock;
      }
      
      // „Ç≥„Éº„Éâ„Éñ„É≠„ÉÉ„ÇØÂ§ñ„ÅßË¶ãÂá∫„ÅóË°å„Åã„Å©„ÅÜ„ÅãÂà§ÂÆö
      const headingMatch = !inCodeBlock && line.match(/^(#{1,6})\s+.+/);
      
      if (headingMatch) {
        const level = headingMatch[1].length;
        html += `<span class="line-num heading-h${level}">${lineNum}</span>`;
      } else {
        html += `<span class="line-num">${lineNum}</span>`;
      }
    }
    
    this.lineNumbers.innerHTML = html;
  },

  updatePreview() {
    this.preview.innerHTML = MarkdownParser.parse(this.editor.value);
    this.renderMath();
    this.renderMermaid();
    this.setupHeadingFold();
    this.highlightCode();
  },
  
  // „Ç∑„É≥„Çø„ÉÉ„ÇØ„Çπ„Éè„Ç§„É©„Ç§„Éà
  highlightCode() {
    if (typeof hljs !== 'undefined') {
      this.preview.querySelectorAll('pre code').forEach(block => {
        hljs.highlightElement(block);
      });
    }
  },
  
  // ÁõÆÊ¨°„ÇíÊõ¥Êñ∞
  updateToc() {
    if (!this.tocContent) return;
    
    const lines = this.editor.value.split('\n');
    let html = '';
    let inCodeBlock = false;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      if (line.trim().startsWith('```')) {
        inCodeBlock = !inCodeBlock;
        continue;
      }
      if (inCodeBlock) continue;
      
      const match = line.match(/^(#{1,6})\s+(.+)/);
      if (match) {
        const level = match[1].length;
        const text = match[2].trim();
        html += `<div class="toc-item h${level}" data-line="${i}" title="${text}">${text}</div>`;
      }
    }
    
    this.tocContent.innerHTML = html || '<div style="padding: 0.5rem; color: var(--text-secondary); font-size: 0.85rem;">Ë¶ãÂá∫„Åó„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
    
    // „ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„Éà„ÇíË®≠ÂÆö
    this.tocContent.querySelectorAll('.toc-item').forEach(item => {
      item.addEventListener('click', () => {
        const lineNum = parseInt(item.dataset.line);
        this.jumpToLine(lineNum);
      });
    });
  },
  
  // „Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫„ÇíÈÅ©Áî®
  applyFontSize() {
    const scale = this.fontSize / 100;
    const baseFontSize = 0.95 * scale;
    const basePreviewSize = 1 * scale;
    
    if (this.editor) {
      this.editor.style.fontSize = `${baseFontSize}rem`;
    }
    if (this.lineNumbers) {
      this.lineNumbers.style.fontSize = `${baseFontSize * 0.95}rem`;
    }
    if (this.preview) {
      this.preview.style.fontSize = `${basePreviewSize}rem`;
    }
    
    if (this.fontSizeDisplay) {
      this.fontSizeDisplay.textContent = `${this.fontSize}%`;
    }
    
    // Ë¶ãÂá∫„Åó„Éè„Ç§„É©„Ç§„Éà„ÅÆ„Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫„ÇÇÊõ¥Êñ∞
    if (this.headingHighlight) {
      this.headingHighlight.style.fontSize = `${baseFontSize}rem`;
    }
    
    // ÂàùÊúüÂåñÂÆå‰∫ÜÂæå„ÅÆ„ÅøË°®Á§∫„ÇíÊõ¥Êñ∞
    if (this.initialized) {
      this.updateHeadingHighlight();
      this.updateCursorOverlay();
    }
  },
  
  // „Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫„ÇíÂ§ß„Åç„Åè
  increaseFontSize() {
    if (this.fontSize < 200) {
      this.fontSize += 10;
      this.applyFontSize();
      localStorage.setItem('vim-md-font-size', this.fontSize);
    }
  },
  
  // „Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫„ÇíÂ∞è„Åï„Åè
  decreaseFontSize() {
    if (this.fontSize > 50) {
      this.fontSize -= 10;
      this.applyFontSize();
      localStorage.setItem('vim-md-font-size', this.fontSize);
    }
  },
  
  // VIM„É¢„Éº„Éâ„ÇíË®≠ÂÆö
  setVimMode(enabled) {
    this.vimMode = enabled;
    localStorage.setItem('vim-md-vim-mode', enabled);
    if (enabled) {
      this.mode = 'normal';
      this.editor.classList.remove('insert-mode');
      this.showStatus('VIM mode enabled');
    } else {
      this.mode = 'insert';
      this.editor.classList.add('insert-mode');
      this.showStatus('Normal edit mode');
    }
    this.updateVimModeUI();
    this.updateCursorOverlay();
    this.editor.focus();
  },
  
  // Update VIM mode UI
  updateVimModeUI() {
    const btn = document.getElementById('btn-vim-mode');
    if (btn) {
      btn.textContent = this.vimMode ? 'VIM' : 'NOVIM';
      btn.classList.toggle('active', this.vimMode);
    }
    if (this.modeIndicator) {
      if (this.vimMode) {
        this.modeIndicator.textContent = this.mode.toUpperCase();
        this.modeIndicator.className = this.mode;
      } else {
        this.modeIndicator.textContent = 'EDIT';
        this.modeIndicator.className = 'edit-mode';
      }
    }
    // NOVIM mode: readOnly=false, show cursor
    if (this.editor) {
      if (this.vimMode) {
        this.editor.readOnly = (this.mode !== 'insert');
        if (this.mode === 'insert') {
          this.editor.classList.add('insert-mode');
        } else {
          this.editor.classList.remove('insert-mode');
        }
      } else {
        this.editor.readOnly = false;
        this.editor.classList.add('insert-mode');
      }
    }
  },
  
  // Toggle VIM mode
  toggleVimMode() {
    this.setVimMode(!this.vimMode);
  },
  
  // ÁõÆÊ¨°„ÅÆÈñãÈñâ
  toggleToc() {
    this.tocVisible = !this.tocVisible;
    
    if (this.tocVisible) {
      this.tocPane.classList.remove('collapsed');
      this.tocOpenBtn.classList.add('hidden');
    } else {
      this.tocPane.classList.add('collapsed');
      this.tocOpenBtn.classList.remove('hidden');
    }
  },
  
  // ÊåáÂÆöË°å„Å´„Ç∏„É£„É≥„Éó
  jumpToLine(lineNum) {
    const lines = this.editor.value.split('\n');
    
    // Ë°å„ÅÆÂÖàÈ†≠‰ΩçÁΩÆ„ÇíË®àÁÆó
    let pos = 0;
    for (let i = 0; i < lineNum; i++) {
      pos += lines[i].length + 1;
    }
    
    // „Ç´„Éº„ÇΩ„É´„ÇíÁßªÂãï
    this.editor.focus();
    this.editor.setSelectionRange(pos, pos);
    
    // „Ç®„Éá„Ç£„Çø„Çí„Çπ„ÇØ„É≠„Éº„É´
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const scrollTop = lineNum * lineHeight - this.editor.clientHeight / 3;
    this.editor.scrollTop = Math.max(0, scrollTop);
    
    // „Éó„É¨„Éì„É•„Éº„ÇÇÂêåÊúü
    this.syncPreviewToLine(lineNum);
    
    // ÁõÆÊ¨°„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÁä∂ÊÖã„ÇíÊõ¥Êñ∞
    this.updateTocActive(lineNum);
    
    // „Ç´„Éº„ÇΩ„É´‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞
    this.updateCursorPos();
    this.updateCursorOverlay();
  },
  
  // „Éó„É¨„Éì„É•„Éº„ÇíÊåáÂÆöË°å„Å´ÂêåÊúü
  // „Éó„É¨„Éì„É•„Éº„ÇíÊåáÂÆöË°å„Å´ÂêåÊúü
  syncPreviewToLine(lineNum) {
    const lines = this.editor.value.split('\n');
    let targetHeadingText = null;
    let targetLevel = null;
    let inCodeBlock = false;
    
    // ÊåáÂÆöË°å„ÅåË¶ãÂá∫„Åó„Åã„ÉÅ„Çß„ÉÉ„ÇØ
    const currentLine = lines[lineNum];
    if (currentLine && /^#{1,6}\s+/.test(currentLine)) {
      targetHeadingText = currentLine.replace(/^#+\s+/, '').trim();
      targetLevel = currentLine.match(/^(#{1,6})/)[1].length;
    } else {
      // ÊåáÂÆöË°å‰ª•Ââç„ÅßÊúÄ„ÇÇËøë„ÅÑË¶ãÂá∫„Åó„ÇíÊé¢„Åô
      for (let i = lineNum; i >= 0; i--) {
        const line = lines[i];
        if (line.trim().startsWith('```')) {
          inCodeBlock = !inCodeBlock;
        }
        if (!inCodeBlock && /^#{1,6}\s+/.test(line)) {
          targetHeadingText = line.replace(/^#+\s+/, '').trim();
          targetLevel = line.match(/^(#{1,6})/)[1].length;
          break;
        }
      }
    }
    
    if (targetHeadingText) {
      // „Éó„É¨„Éì„É•„ÉºÂÜÖ„ÅßË©≤ÂΩì„Åô„ÇãË¶ãÂá∫„Åó„ÇíÊé¢„Åó„Å¶„Çπ„ÇØ„É≠„Éº„É´
      const headings = this.preview.querySelectorAll('h1, h2, h3, h4, h5, h6');
      for (const h of headings) {
        const text = h.textContent.replace(/^[‚ñº‚ñ∂]\s*/, '').trim();
        if (text === targetHeadingText) {
          // „Éó„É¨„Éì„É•„Éº„Ç≥„É≥„ÉÜ„É≥„ÉÑÂÜÖ„Åß„ÅÆ„Çπ„ÇØ„É≠„Éº„É´
          const previewContent = document.getElementById('preview-content');
          const rect = h.getBoundingClientRect();
          const containerRect = previewContent.getBoundingClientRect();
          const scrollOffset = rect.top - containerRect.top + previewContent.scrollTop - 50;
          previewContent.scrollTop = Math.max(0, scrollOffset);
          break;
        }
      }
    }
  },
  
  // ÁõÆÊ¨°„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÁä∂ÊÖã„ÇíÊõ¥Êñ∞
  updateTocActive(lineNum) {
    if (!this.tocContent) return;
    
    const items = this.tocContent.querySelectorAll('.toc-item');
    let activeItem = null;
    
    // ÁèæÂú®Ë°å‰ª•Ââç„ÅßÊúÄ„ÇÇËøë„ÅÑË¶ãÂá∫„Åó„Çí„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´
    items.forEach(item => {
      item.classList.remove('active');
      const itemLine = parseInt(item.dataset.line);
      if (itemLine <= lineNum) {
        activeItem = item;
      }
    });
    
    if (activeItem) {
      activeItem.classList.add('active');
      // ÁõÆÊ¨°ÂÜÖ„Åß„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÈ†ÖÁõÆ„ÅåË¶ã„Åà„Çã„Çà„ÅÜ„Å´„Çπ„ÇØ„É≠„Éº„É´
      activeItem.scrollIntoView({ block: 'nearest' });
    }
  },
  
  // Ë¶ãÂá∫„ÅóË°å„ÅÆ„Éè„Ç§„É©„Ç§„ÉàÊõ¥Êñ∞
  // Ë¶ãÂá∫„ÅóË°å„ÅÆ„Éè„Ç§„É©„Ç§„ÉàÊõ¥Êñ∞
  updateHeadingHighlight() {
    if (!this.headingHighlight) return;
    
    const lines = this.editor.value.split('\n');
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const paddingTop = parseFloat(getComputedStyle(this.editor).paddingTop);
    const paddingLeft = parseFloat(getComputedStyle(this.editor).paddingLeft);
    const scrollTop = this.editor.scrollTop;
    const scrollLeft = this.editor.scrollLeft;
    
    let html = '';
    let inCodeBlock = false;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      if (line.trim().startsWith('```')) {
        inCodeBlock = !inCodeBlock;
        continue;
      }
      if (inCodeBlock) continue;
      
      const match = line.match(/^(#{1,6})\s+/);
      if (match) {
        const level = match[1].length;
        const top = paddingTop + i * lineHeight - scrollTop;
        
        // ÁîªÈù¢ÂÜÖ„ÅÆË°å„ÅÆ„ÅøË°®Á§∫
        if (top > -lineHeight && top < this.editor.clientHeight + lineHeight) {
          // „ÉÜ„Ç≠„Çπ„Éà„Çí„Ç®„Çπ„Ç±„Éº„Éó
          const escapedLine = line
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
          
          html += `<div class="heading-text-overlay h${level}" style="top: ${top}px; left: ${paddingLeft - scrollLeft}px; height: ${lineHeight}px; line-height: ${lineHeight}px;">${escapedLine}</div>`;
        }
      }
    }
    
    this.headingHighlight.innerHTML = html;
  },
  
  // „Éó„É¨„Éì„É•„Éº„ÅÆË¶ãÂá∫„ÅóÊäò„ÇäÁï≥„ÅøÊ©üËÉΩ
  setupHeadingFold() {
    const headings = this.preview.querySelectorAll('h1, h2, h3, h4, h5, h6');
    
    headings.forEach(heading => {
      // Êäò„ÇäÁï≥„Åø„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº„ÇíËøΩÂä†
      if (!heading.querySelector('.fold-indicator')) {
        const indicator = document.createElement('span');
        indicator.className = 'fold-indicator';
        indicator.textContent = '‚ñº';
        heading.insertBefore(indicator, heading.firstChild);
      }
      
      // „ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„Éà
      heading.style.cursor = 'pointer';
      heading.onclick = (e) => {
        e.stopPropagation();
        this.toggleHeadingFold(heading);
      };
    });
  },
  
  toggleHeadingFold(heading) {
    const level = parseInt(heading.tagName[1]);
    const indicator = heading.querySelector('.fold-indicator');
    const isFolded = heading.classList.contains('folded');
    
    if (isFolded) {
      // Â±ïÈñã„Åô„ÇãÂ†¥Âêà - Áõ¥Êé•„ÅÆÂ≠ê„É¨„Éô„É´„ÅÆ„ÅøË°®Á§∫
      heading.classList.remove('folded');
      indicator.textContent = '‚ñº';
      
      let sibling = heading.nextElementSibling;
      let directChildLevel = null; // Áõ¥Êé•„ÅÆÂ≠ê„É¨„Éô„É´
      
      while (sibling) {
        if (/^H[1-6]$/.test(sibling.tagName)) {
          const siblingLevel = parseInt(sibling.tagName[1]);
          
          // Âêå„É¨„Éô„É´‰ª•‰∏ä„ÅÆË¶ãÂá∫„Åó„ÅßÂÅúÊ≠¢
          if (siblingLevel <= level) break;
          
          // ÊúÄÂàù„Å´Ë¶ã„Å§„Åã„Å£„ÅüÂ≠êË¶ãÂá∫„Åó„ÅÆ„É¨„Éô„É´„ÇíÁõ¥Êé•„ÅÆÂ≠ê„É¨„Éô„É´„Å®„Åô„Çã
          if (directChildLevel === null) {
            directChildLevel = siblingLevel;
          }
          
          // Áõ¥Êé•„ÅÆÂ≠ê„É¨„Éô„É´„ÅÆË¶ãÂá∫„Åó„ÅÆ„ÅøË°®Á§∫
          if (siblingLevel === directChildLevel) {
            sibling.style.display = '';
            sibling.classList.remove('heading-hidden');
            // Â≠êË¶ãÂá∫„Åó„ÅØÊäò„Çä„Åü„Åü„Åæ„Çå„ÅüÁä∂ÊÖã„ÇíÁ∂≠ÊåÅ
          }
          // „Åù„Çå‰ª•Â§ñÔºàÂ≠´‰ª•‰∏ãÔºâ„ÅØÈùûË°®Á§∫„ÅÆ„Åæ„Åæ
        } else {
          // Ë¶ãÂá∫„Åó‰ª•Â§ñ„ÅÆË¶ÅÁ¥† - Áõ¥Êé•„ÅÆÂ≠ê„É¨„Éô„É´„ÅåË¶ã„Å§„Åã„ÇãÂâç„Å™„ÇâË°®Á§∫
          if (directChildLevel === null) {
            sibling.style.display = '';
            sibling.classList.remove('heading-hidden');
          }
        }
        sibling = sibling.nextElementSibling;
      }
    } else {
      // Êäò„Çä„Åü„Åü„ÇÄÂ†¥Âêà
      heading.classList.add('folded');
      indicator.textContent = '‚ñ∂';
      
      let sibling = heading.nextElementSibling;
      while (sibling) {
        if (/^H[1-6]$/.test(sibling.tagName)) {
          const siblingLevel = parseInt(sibling.tagName[1]);
          if (siblingLevel <= level) break;
        }
        sibling.style.display = 'none';
        sibling.classList.add('heading-hidden');
        sibling = sibling.nextElementSibling;
      }
    }
  },
  
  // ÂÖ®„Å¶„ÅÆË¶ãÂá∫„Åó„ÇíÊäò„Çä„Åü„Åü„ÇÄ
  foldAllHeadings() {
    const headings = this.preview.querySelectorAll('h1, h2, h3, h4, h5, h6');
    headings.forEach(heading => {
      if (!heading.classList.contains('folded')) {
        this.toggleHeadingFold(heading);
      }
    });
  },
  
  // ÂÖ®„Å¶„ÅÆË¶ãÂá∫„Åó„ÇíÂ±ïÈñã„Åô„Çã
  unfoldAllHeadings() {
    const headings = this.preview.querySelectorAll('h1, h2, h3, h4, h5, h6');
    // ÈÄÜÈ†Ü„ÅßÂ±ïÈñãÔºà„Éç„Çπ„Éà„Åï„Çå„ÅüË¶ãÂá∫„Åó„ÇíÊ≠£„Åó„ÅèÂ±ïÈñã„Åô„Çã„Åü„ÇÅÔºâ
    const headingsArray = Array.from(headings).reverse();
    headingsArray.forEach(heading => {
      if (heading.classList.contains('folded')) {
        this.toggleHeadingFold(heading);
      }
    });
  },
  
  renderMermaid() {
    // Mermaid„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç
    if (typeof mermaid === 'undefined') return;
    
    const mermaidDivs = this.preview.querySelectorAll('.mermaid');
    if (mermaidDivs.length === 0) return;
    
    // ÂêÑMermaidË¶ÅÁ¥†„Å´„É¶„Éã„Éº„ÇØID„Çí‰ªò‰∏é„Åó„Å¶„É¨„É≥„ÉÄ„É™„É≥„Ç∞
    mermaidDivs.forEach((el, i) => {
      el.setAttribute('id', `mermaid-${Date.now()}-${i}`);
    });
    
    try {
      mermaid.run({
        nodes: mermaidDivs
      });
    } catch (e) {
      console.error('Mermaid rendering error:', e);
    }
  },
  
  renderMath() {
    // KaTeX„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç
    if (typeof katex === 'undefined') return;
    
    // „Ç§„É≥„É©„Ç§„É≥Êï∞Âºè„Çí„É¨„É≥„ÉÄ„É™„É≥„Ç∞
    const inlineMath = this.preview.querySelectorAll('.math-inline');
    inlineMath.forEach(el => {
      const formula = el.getAttribute('data-math');
      try {
        katex.render(formula, el, {
          throwOnError: false,
          displayMode: false
        });
      } catch (e) {
        el.innerHTML = `<span class="math-error">${formula}</span>`;
      }
    });
    
    // „Éñ„É≠„ÉÉ„ÇØÊï∞Âºè„Çí„É¨„É≥„ÉÄ„É™„É≥„Ç∞
    const blockMath = this.preview.querySelectorAll('.math-block');
    blockMath.forEach(el => {
      const formula = el.getAttribute('data-math');
      try {
        katex.render(formula, el, {
          throwOnError: false,
          displayMode: true
        });
      } catch (e) {
        el.innerHTML = `<span class="math-error">${formula}</span>`;
      }
    });
  },
  
  syncScroll() {
    const editor = this.editor;
    const preview = document.getElementById('preview-pane');
    const ratio = editor.scrollTop / (editor.scrollHeight - editor.clientHeight || 1);
    preview.scrollTop = ratio * (preview.scrollHeight - preview.clientHeight);
  },
  
  scrollHalfPage(direction) {
    const height = this.editor.clientHeight / 2;
    this.editor.scrollTop += height * direction;
    this.moveCursorToVisibleArea(direction);
  },
  
  scrollFullPage(direction) {
    const height = this.editor.clientHeight;
    this.editor.scrollTop += height * direction;
    this.moveCursorToVisibleArea(direction);
  },
  
  // „Ç´„Éº„ÇΩ„É´„ÇíË°®Á§∫È†òÂüüÂÜÖ„Å´ÁßªÂãï
  moveCursorToVisibleArea(direction) {
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const visibleTop = this.editor.scrollTop;
    const visibleBottom = visibleTop + this.editor.clientHeight;
    
    // ÁèæÂú®„ÅÆ„Ç´„Éº„ÇΩ„É´Ë°å„ÇíË®àÁÆó
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const linesBeforeCursor = text.substring(0, pos).split('\n').length - 1;
    const cursorTop = linesBeforeCursor * lineHeight;
    
    // „Ç´„Éº„ÇΩ„É´„ÅåË¶ã„Åà„Å™„ÅÑÂ†¥Âêà„ÄÅË¶ã„Åà„Çã‰ΩçÁΩÆ„Å´ÁßªÂãï
    if (cursorTop < visibleTop || cursorTop > visibleBottom - lineHeight) {
      const targetLine = Math.floor((direction > 0 ? visibleTop : visibleBottom - lineHeight) / lineHeight);
      const lines = text.split('\n');
      const clampedLine = Math.max(0, Math.min(targetLine, lines.length - 1));
      
      let newPos = 0;
      for (let i = 0; i < clampedLine; i++) {
        newPos += lines[i].length + 1;
      }
      
      this.editor.selectionStart = newPos;
      this.editor.selectionEnd = newPos;
      this.updateCursorPos();
    }
  },
  
  // „Ç´„Éº„ÇΩ„É´‰ΩçÁΩÆ„Å´„Çπ„ÇØ„É≠„Éº„É´
  scrollToCursor() {
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const linesBeforeCursor = text.substring(0, pos).split('\n').length - 1;
    const cursorTop = linesBeforeCursor * lineHeight;
    
    const visibleTop = this.editor.scrollTop;
    const visibleBottom = visibleTop + this.editor.clientHeight;
    
    // „Ç´„Éº„ÇΩ„É´„ÅåË¶ã„Åà„Å™„ÅÑÂ†¥Âêà„ÄÅ‰∏≠Â§Æ‰ªòËøë„Å´„Çπ„ÇØ„É≠„Éº„É´
    if (cursorTop < visibleTop) {
      this.editor.scrollTop = cursorTop - this.editor.clientHeight / 4;
    } else if (cursorTop > visibleBottom - lineHeight * 2) {
      this.editor.scrollTop = cursorTop - this.editor.clientHeight * 3 / 4;
    }
  },
  
  // z Enter, zt - cursor line to top
  scrollCursorToTop() {
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const linesBeforeCursor = text.substring(0, pos).split('\n').length - 1;
    const cursorTop = linesBeforeCursor * lineHeight;
    
    this.editor.scrollTop = cursorTop;
    this.updateCursorPos();
  },
  
  // z. zz - cursor line to center
  scrollCursorToCenter() {
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const linesBeforeCursor = text.substring(0, pos).split('\n').length - 1;
    const cursorTop = linesBeforeCursor * lineHeight;
    
    this.editor.scrollTop = cursorTop - (this.editor.clientHeight / 2) + lineHeight;
    this.updateCursorPos();
  },
  
  // z- zb - cursor line to bottom
  scrollCursorToBottom() {
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const linesBeforeCursor = text.substring(0, pos).split('\n').length - 1;
    const cursorTop = linesBeforeCursor * lineHeight;
    
    this.editor.scrollTop = cursorTop - this.editor.clientHeight + lineHeight * 2;
    this.updateCursorPos();
  }
};

function setViewMode(mode) {
  const container = document.getElementById('main-container');
  
  // „Éì„É•„Éº„É¢„Éº„Éâ„Éú„Çø„É≥„ÅÆ„Åø„ÇíÂØæË±°„Å´„Åô„Çã
  ['edit', 'preview', 'split'].forEach(m => {
    document.getElementById('btn-' + m).classList.remove('active');
  });
  document.getElementById('btn-' + mode).classList.add('active');
  
  container.classList.remove('edit-only', 'preview-only', 'split-view');
  
  if (mode === 'edit') container.classList.add('edit-only');
  else if (mode === 'preview') container.classList.add('preview-only');
  else container.classList.add('split-view');
  
  VimEditor.editor.focus();
}

function setTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme);
  
  // „ÉÜ„Éº„Éû„Éú„Çø„É≥„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÁä∂ÊÖã„ÇíÊõ¥Êñ∞
  ['dark', 'light', 'original'].forEach(t => {
    const btn = document.getElementById('btn-theme-' + t);
    if (btn) btn.classList.remove('active');
  });
  const activeBtn = document.getElementById('btn-theme-' + theme);
  if (activeBtn) activeBtn.classList.add('active');
  
  // „ÉÜ„Éº„ÉûË®≠ÂÆö„Çí‰øùÂ≠ò
  localStorage.setItem('vim-md-theme', theme);
  
  // VimEditor„ÅåÂàùÊúüÂåñ„Åï„Çå„Å¶„ÅÑ„Çå„Å∞ÈÄöÁü•
  if (typeof VimEditor !== 'undefined' && VimEditor.showStatus) {
    VimEditor.showStatus(`Theme: ${theme}`);
  }
}

function loadTheme() {
  const saved = localStorage.getItem('vim-md-theme');
  if (saved && ['dark', 'light', 'original'].includes(saved)) {
    document.documentElement.setAttribute('data-theme', saved);
    // „Éú„Çø„É≥„ÅÆÊõ¥Êñ∞ÔºàDOM„ÅåÊ∫ñÂÇô„Åß„Åç„Å¶„ÅÑ„ÇãÂ†¥ÂêàÔºâ
    const btn = document.getElementById('btn-theme-' + saved);
    if (btn) {
      ['dark', 'light', 'original'].forEach(t => {
        const b = document.getElementById('btn-theme-' + t);
        if (b) b.classList.remove('active');
      });
      btn.classList.add('active');
    }
  }
}

function toggleHelp() {
  document.getElementById('help-modal').classList.toggle('hidden');
  if (document.getElementById('help-modal').classList.contains('hidden')) {
    VimEditor.editor.focus();
  }
}

document.addEventListener('DOMContentLoaded', () => {
  loadTheme();
  VimEditor.init();
  VimEditor.editor.focus();
  
  // Click anywhere to return focus to editor
  document.addEventListener('click', (e) => {
    const target = e.target;
    const isInteractive = target.closest('button, input, select, a, .filename, #command-input, #help-content');
    
    if (VimEditor.mode === 'command') return;
    
    if (!isInteractive) {
      setTimeout(() => {
        VimEditor.editor.focus();
        VimEditor.updateCursorPos();
      }, 0);
    }
  });
});

window.addEventListener('beforeunload', e => {
  if (VimEditor.modified) {
    e.preventDefault();
    e.returnValue = '';
  }
});
  </script>
</body>
<!-- KaTeX JS -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<!-- Mermaid JS -->
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<!-- Highlight.js -->
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
<script>
  mermaid.initialize({ 
    startOnLoad: false,
    theme: 'dark',
    securityLevel: 'loose'
  });
</script>
</html>
