<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>mdvim v0.3.3 - Vimé¢¨ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚¨ãƒ‡ã‚£ã‚¿</title>
  <!-- KaTeX CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <!-- Highlight.js CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css">
  <style>
/* ãƒ†ãƒ¼ãƒå®šç¾© */
:root, [data-theme="dark"] {
  --bg-primary: #1e1e2e;
  --bg-secondary: #313244;
  --bg-tertiary: #45475a;
  --text-primary: #cdd6f4;
  --text-secondary: #a6adc8;
  --accent: #89b4fa;
  --accent-green: #a6e3a1;
  --accent-yellow: #f9e2af;
  --accent-red: #f38ba8;
  --accent-purple: #cba6f7;
  --border: #585b70;
  /* è¦‹å‡ºã—ãƒ¬ãƒ™ãƒ«åˆ¥ã®è‰² */
  --heading-h1: #f38ba8;
  --heading-h2: #fab387;
  --heading-h3: #f9e2af;
  --heading-h4: #a6e3a1;
  --heading-h5: #89b4fa;
  --heading-h6: #cba6f7;
}

[data-theme="light"] {
  --bg-primary: #ffffff;
  --bg-secondary: #f5f5f5;
  --bg-tertiary: #e0e0e0;
  --text-primary: #1a1a1a;
  --text-secondary: #555555;
  --accent: #0066cc;
  --accent-green: #2e7d32;
  --accent-yellow: #f9a825;
  --accent-red: #c62828;
  --accent-purple: #7b1fa2;
  --border: #cccccc;
  /* è¦‹å‡ºã—ãƒ¬ãƒ™ãƒ«åˆ¥ã®è‰² */
  --heading-h1: #c62828;
  --heading-h2: #e65100;
  --heading-h3: #f9a825;
  --heading-h4: #2e7d32;
  --heading-h5: #0066cc;
  --heading-h6: #7b1fa2;
}

[data-theme="original"] {
  --bg-primary: #000000;
  --bg-secondary: #1a1a1a;
  --bg-tertiary: #2d2d2d;
  --text-primary: #00ff00;
  --text-secondary: #00cc00;
  --accent: #00ffff;
  --accent-green: #00ff00;
  --accent-yellow: #ffff00;
  --accent-red: #ff0000;
  --accent-purple: #ff00ff;
  --border: #333333;
  /* è¦‹å‡ºã—ãƒ¬ãƒ™ãƒ«åˆ¥ã®è‰² */
  --heading-h1: #ff0000;
  --heading-h2: #ff8800;
  --heading-h3: #ffff00;
  --heading-h4: #00ff00;
  --heading-h5: #00ffff;
  --heading-h6: #ff00ff;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'JetBrains Mono', 'Fira Code', 'Source Code Pro', Consolas, monospace;
  background: var(--bg-primary);
  color: var(--text-primary);
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.toolbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.5rem 1rem;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
}

.logo { font-weight: bold; font-size: 1.1rem; color: var(--accent); }

.view-controls button {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 0.4rem 1rem;
  margin: 0 0.2rem;
  cursor: pointer;
  border-radius: 4px;
  font-family: inherit;
  font-size: 0.85rem;
  transition: all 0.2s;
}

.view-controls button:hover { background: var(--border); }
.view-controls button.active { background: var(--accent); color: var(--bg-primary); border-color: var(--accent); }
.view-controls button[id^="btn-theme-"] { padding: 0.4rem 0.6rem; font-size: 1rem; }

#font-size-display {
  color: var(--text-secondary);
  font-size: 0.85rem;
  min-width: 3rem;
  text-align: center;
}

.mode-indicator { display: flex; gap: 1rem; font-size: 0.9rem; align-items: center; }
#vim-mode { color: var(--accent-green); padding: 0.2rem 0.4rem; font-weight: bold; min-width: 60px; text-align: center; font-size: 0.85rem; }
#vim-mode.insert { color: var(--accent); }
#vim-mode.visual { color: var(--accent-yellow); }
#vim-mode.command { color: var(--accent-red); }
#vim-mode.recording { color: var(--accent-purple); }
#vim-mode.edit-mode { color: var(--text-secondary); }
#btn-vim-mode { min-width: 50px; }
#btn-vim-mode.active { background: var(--accent-green); color: var(--bg-primary); }
#cursor-pos { color: var(--text-secondary); }
#macro-indicator { color: var(--accent-purple); font-weight: bold; display: none; }
#macro-indicator.active { display: inline; }

#main-container { flex: 1; display: flex; overflow: hidden; }
.pane { flex: 1; display: flex; overflow: hidden; position: relative; }
#editor-pane { border-right: 1px solid var(--border); flex-direction: column; }
#editor-content { display: flex; flex: 1; overflow: hidden; }

#line-numbers {
  min-width: 3rem;
  background: var(--bg-secondary);
  color: var(--text-secondary);
  text-align: right;
  padding: 0.5rem 0.5rem 0.5rem 0;
  font-size: 0.95rem;
  line-height: 1.5;
  overflow: hidden;
  user-select: none;
  white-space: pre;
}

#line-numbers .line-num {
  display: block;
}

#line-numbers .heading-h1 { color: var(--heading-h1); }
#line-numbers .heading-h2 { color: var(--heading-h2); }
#line-numbers .heading-h3 { color: var(--heading-h3); }
#line-numbers .heading-h4 { color: var(--heading-h4); }
#line-numbers .heading-h5 { color: var(--heading-h5); }
#line-numbers .heading-h6 { color: var(--heading-h6); }

#editor-wrapper {
  flex: 1;
  position: relative;
  overflow: hidden;
}

#editor {
  width: 100%;
  height: 100%;
  background: var(--bg-primary);
  color: var(--text-primary);
  border: none;
  padding: 0.5rem;
  font-family: inherit;
  font-size: 0.95rem;
  line-height: 1.5;
  resize: none;
  outline: none;
  overflow: auto;
  white-space: pre;
  tab-size: 4;
  caret-color: transparent;
}

#editor.insert-mode {
  caret-color: var(--accent);
}

#cursor-overlay {
  position: absolute;
  pointer-events: none;
  background: var(--accent-green);
  opacity: 0.8;
  z-index: 10;
}

#cursor-overlay.insert {
  width: 2px !important;
  background: var(--accent);
  opacity: 1;
}

#cursor-overlay.visual {
  background: var(--accent-yellow);
}

#cursor-overlay.command {
  display: none;
}

@keyframes blink {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 0.3; }
}

#cursor-overlay.blink {
  animation: blink 1s ease-in-out infinite;
}

#preview-pane { 
  background: var(--bg-primary); 
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#preview-content { 
  flex: 1;
  overflow: auto;
  padding: 1.5rem; 
}

#preview-content h1 { font-size: 2rem; margin: 1rem 0 0.5rem; color: var(--heading-h1); border-bottom: 2px solid var(--border); padding-bottom: 0.3rem; }
#preview-content h2 { font-size: 1.6rem; margin: 1rem 0 0.5rem; color: var(--heading-h2); }
#preview-content h3 { font-size: 1.3rem; margin: 0.8rem 0 0.4rem; color: var(--heading-h3); }
#preview-content h4 { margin: 0.6rem 0 0.3rem; color: var(--heading-h4); }
#preview-content h5 { margin: 0.6rem 0 0.3rem; color: var(--heading-h5); }
#preview-content h6 { margin: 0.6rem 0 0.3rem; color: var(--heading-h6); }
#preview-content p { margin: 0.6rem 0; line-height: 1.7; }
#preview-content ul, #preview-content ol { margin: 0.5rem 0; padding-left: 1.5rem; }
#preview-content li { margin: 0.3rem 0; }
#preview-content code { background: var(--bg-secondary); padding: 0.15rem 0.4rem; border-radius: 3px; font-size: 0.9em; }
#preview-content pre { background: var(--bg-secondary); padding: 1rem; border-radius: 6px; overflow-x: auto; margin: 0.8rem 0; line-height: 1.4; }
#preview-content pre code { background: none; padding: 0; line-height: 1.4; display: block; }

/* Mermaidå›³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
#preview-content .mermaid {
  background: var(--bg-secondary);
  padding: 1rem;
  border-radius: 6px;
  margin: 0.8rem 0;
  text-align: center;
  overflow-x: auto;
}

#preview-content .mermaid svg {
  max-width: 100%;
  height: auto;
}

/* æŠ˜ã‚Šç•³ã¿ï¼ˆdetailsï¼‰ã®ã‚¹ã‚¿ã‚¤ãƒ« */
#preview-content details.collapsible {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 6px;
  margin: 0.8rem 0;
  overflow: hidden;
}

#preview-content details.collapsible summary {
  background: var(--bg-tertiary);
  padding: 0.6rem 1rem;
  cursor: pointer;
  font-weight: bold;
  user-select: none;
  list-style: none;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

#preview-content details.collapsible summary::-webkit-details-marker {
  display: none;
}

#preview-content details.collapsible summary::before {
  content: "â–¶";
  font-size: 0.8em;
  transition: transform 0.2s;
}

#preview-content details.collapsible[open] summary::before {
  transform: rotate(90deg);
}

#preview-content details.collapsible summary:hover {
  background: var(--border);
}

#preview-content details.collapsible .details-content {
  padding: 1rem;
  border-top: 1px solid var(--border);
}

#preview-content details.collapsible .details-content > :first-child {
  margin-top: 0;
}

#preview-content details.collapsible .details-content > :last-child {
  margin-bottom: 0;
}

/* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¦‹å‡ºã—æŠ˜ã‚Šç•³ã¿ã‚¹ã‚¿ã‚¤ãƒ« */
#preview-content h1,
#preview-content h2,
#preview-content h3,
#preview-content h4,
#preview-content h5,
#preview-content h6 {
  position: relative;
  transition: opacity 0.2s;
}

#preview-content .fold-indicator {
  font-size: 0.7em;
  margin-right: 0.5rem;
  opacity: 0.5;
  transition: transform 0.2s, opacity 0.2s;
  display: inline-block;
}

#preview-content h1:hover .fold-indicator,
#preview-content h2:hover .fold-indicator,
#preview-content h3:hover .fold-indicator,
#preview-content h4:hover .fold-indicator,
#preview-content h5:hover .fold-indicator,
#preview-content h6:hover .fold-indicator {
  opacity: 1;
}

#preview-content .folded .fold-indicator {
  transform: rotate(-90deg);
}

#preview-content .heading-hidden {
  display: none !important;
}

/* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ */
#preview-controls {
  display: flex;
  gap: 0.5rem;
  padding: 0.5rem;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

#preview-controls button {
  padding: 0.3rem 0.8rem;
  font-size: 0.8rem;
  background: var(--bg-tertiary);
  color: var(--text-secondary);
  border: 1px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
}

#preview-controls button:hover {
  background: var(--accent);
  color: var(--bg-primary);
  border-color: var(--accent);
}

/* ã‚¨ãƒ‡ã‚£ã‚¿ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ */
#editor-controls {
  display: flex;
  gap: 0.5rem;
  padding: 0.5rem;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  align-items: center;
}

#editor-controls button {
  padding: 0.3rem 0.8rem;
  font-size: 0.8rem;
  background: var(--bg-tertiary);
  color: var(--text-secondary);
  border: 1px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
}

#editor-controls button:hover {
  background: var(--accent);
  color: var(--bg-primary);
  border-color: var(--accent);
}

#editor-controls button.active {
  background: var(--accent-green);
  color: var(--bg-primary);
  border-color: var(--accent-green);
}

#editor-controls #vim-mode {
  /* ãƒ¢ãƒ¼ãƒ‰è¡¨ç¤º */
}

#editor-controls #cursor-pos {
  color: var(--text-secondary);
  font-size: 0.85rem;
  margin-right: auto;
}

#editor-controls #macro-indicator {
  color: var(--accent-red);
  font-weight: bold;
  font-size: 0.8rem;
  display: none;
}

#editor-controls #macro-indicator.active {
  display: inline;
  animation: blink 1s infinite;
}

/* ç›®æ¬¡ãƒ‘ãƒãƒ« */
#toc-pane {
  width: 200px;
  min-width: 150px;
  max-width: 300px;
  background: var(--bg-secondary);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  transition: width 0.2s, min-width 0.2s;
}

#toc-pane.collapsed {
  width: 0;
  min-width: 0;
  border-right: none;
}

#toc-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem;
  background: var(--bg-tertiary);
  border-bottom: 1px solid var(--border);
  font-weight: bold;
  font-size: 0.85rem;
  color: var(--text-primary);
}

#toc-header button {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.2rem 0.4rem;
  font-size: 0.8rem;
}

#toc-header button:hover {
  color: var(--accent);
}

#toc-content {
  flex: 1;
  overflow-y: auto;
  padding: 0.5rem 0;
}

.toc-item {
  padding: 0.3rem 0.5rem;
  cursor: pointer;
  font-size: 0.85rem;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  border-left: 3px solid transparent;
  transition: all 0.15s;
}

.toc-item:hover {
  background: var(--bg-tertiary);
  color: var(--text-primary);
}

.toc-item.active {
  background: var(--bg-tertiary);
  border-left-color: var(--accent);
  color: var(--text-primary);
}

.toc-item.h1 { padding-left: 0.5rem; color: var(--heading-h1); font-weight: bold; }
.toc-item.h2 { padding-left: 1rem; color: var(--heading-h2); }
.toc-item.h3 { padding-left: 1.5rem; color: var(--heading-h3); }
.toc-item.h4 { padding-left: 2rem; color: var(--heading-h4); }
.toc-item.h5 { padding-left: 2.5rem; color: var(--heading-h5); }
.toc-item.h6 { padding-left: 3rem; color: var(--heading-h6); }

#toc-open-btn {
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-left: none;
  border-radius: 0 4px 4px 0;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.5rem 0.3rem;
  font-size: 0.8rem;
  z-index: 10;
}

#toc-open-btn:hover {
  background: var(--bg-tertiary);
  color: var(--accent);
}

#toc-open-btn.hidden {
  display: none;
}
#preview-content blockquote { border-left: 4px solid var(--accent); padding-left: 1rem; margin: 0.8rem 0; color: var(--text-secondary); font-style: italic; }
#preview-content hr { border: none; border-top: 1px solid var(--border); margin: 1.5rem 0; }
#preview-content a { color: var(--accent); text-decoration: none; }
#preview-content a:hover { text-decoration: underline; }
#preview-content img { max-width: 100%; border-radius: 6px; }
#preview-content table { border-collapse: collapse; margin: 0.8rem 0; width: 100%; }
#preview-content th, #preview-content td { border: 1px solid var(--border); padding: 0.5rem; text-align: left; }
#preview-content th { background: var(--bg-secondary); }

/* KaTeXæ•°å¼ã‚¹ã‚¿ã‚¤ãƒ« */
#preview-content .katex-display {
  margin: 1rem 0;
  overflow-x: auto;
  overflow-y: hidden;
}

#preview-content .katex {
  font-size: 1.1em;
}

#preview-content .math-inline {
  display: inline;
}

#preview-content .math-block {
  display: block;
  text-align: center;
  margin: 1rem 0;
}

#preview-content .math-error {
  color: var(--accent-red);
  font-family: monospace;
  font-size: 0.9em;
}

.edit-only #preview-pane { display: none; }
.edit-only #editor-pane { border-right: none; }
.preview-only #editor-pane { display: none; }

#command-line {
  display: flex;
  align-items: center;
  padding: 0.3rem 0.5rem;
  background: var(--bg-secondary);
  border-top: 1px solid var(--border);
}

#command-line.hidden { display: none; }
#command-prefix { color: var(--accent); font-weight: bold; margin-right: 0.3rem; }
#command-input { flex: 1; background: transparent; border: none; color: var(--text-primary); font-family: inherit; font-size: 0.95rem; outline: none; }

#status-bar {
  display: flex;
  justify-content: space-between;
  padding: 0.3rem 1rem;
  background: var(--bg-tertiary);
  font-size: 0.85rem;
  color: var(--text-secondary);
}

.modal {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal.hidden { display: none; }

.modal-content {
  background: var(--bg-secondary);
  padding: 1.5rem;
  border-radius: 8px;
  max-width: 1000px;
  max-height: 85vh;
  overflow: auto;
}

.modal-content h2 { color: var(--accent); margin-bottom: 1rem; text-align: center; }
.help-columns { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1.5rem; }
.help-section h3 { color: var(--accent-yellow); margin-bottom: 0.5rem; font-size: 1rem; }
.help-section ul { list-style: none; }
.help-section li { margin: 0.3rem 0; font-size: 0.85rem; }
kbd { background: var(--bg-tertiary); padding: 0.1rem 0.4rem; border-radius: 3px; border: 1px solid var(--border); font-family: inherit; font-size: 0.85em; }
.modal-content > button { display: block; margin: 1.5rem auto 0; padding: 0.5rem 2rem; background: var(--accent); color: var(--bg-primary); border: none; border-radius: 4px; font-family: inherit; cursor: pointer; font-size: 1rem; }
.new-feature { color: var(--accent-green); font-size: 0.75em; margin-left: 0.3rem; }

@media (max-width: 900px) {
  .help-columns { grid-template-columns: repeat(2, 1fr); }
}
@media (max-width: 600px) {
  .help-columns { grid-template-columns: 1fr; }
  .toolbar { flex-wrap: wrap; gap: 0.5rem; }
}

/* ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ */
.task-list {
  list-style: none;
  padding-left: 0;
}

.task-item {
  display: flex;
  align-items: flex-start;
  gap: 0.5rem;
}

.task-item input[type="checkbox"] {
  margin-top: 0.3rem;
  accent-color: var(--accent);
}

/* GitHub Alerts */
.alert {
  padding: 1rem;
  margin: 1rem 0;
  border-radius: 6px;
  border-left: 4px solid;
}

.alert-title {
  display: block;
  font-weight: bold;
  margin-bottom: 0.5rem;
}

.alert p {
  margin: 0;
}

.alert-note {
  background: rgba(56, 139, 253, 0.1);
  border-color: #388bfd;
}

.alert-note .alert-title {
  color: #388bfd;
}

.alert-tip {
  background: rgba(46, 160, 67, 0.1);
  border-color: #2ea043;
}

.alert-tip .alert-title {
  color: #2ea043;
}

.alert-important {
  background: rgba(130, 80, 223, 0.1);
  border-color: #8250df;
}

.alert-important .alert-title {
  color: #8250df;
}

.alert-warning {
  background: rgba(210, 153, 34, 0.1);
  border-color: #d29922;
}

.alert-warning .alert-title {
  color: #d29922;
}

.alert-caution {
  background: rgba(248, 81, 73, 0.1);
  border-color: #f85149;
}

.alert-caution .alert-title {
  color: #f85149;
}

/* Highlight.js ã®ã‚¹ã‚¿ã‚¤ãƒ«èª¿æ•´ */
#preview-content pre code.hljs {
  background: transparent;
  padding: 0;
}

/* Qiita noteè¨˜æ³• */
.note {
  display: flex;
  padding: 1rem;
  margin: 1rem 0;
  border-radius: 6px;
  gap: 0.75rem;
}

.note-icon {
  font-size: 1.2rem;
  flex-shrink: 0;
}

.note-content {
  flex: 1;
}

.note-content p:first-child {
  margin-top: 0;
  font-weight: bold;
}

.note-content p:last-child {
  margin-bottom: 0;
}

.note-info {
  background: #e6f6e6;
  border-left: 4px solid #55c500;
}

.note-warn {
  background: #fff9e6;
  border-left: 4px solid #ffc800;
}

.note-alert {
  background: #ffe6e6;
  border-left: 4px solid #dd0000;
}

/* ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒç”¨ */
[data-theme="dark"] .note-info {
  background: rgba(85, 197, 0, 0.15);
}

[data-theme="dark"] .note-warn {
  background: rgba(255, 200, 0, 0.15);
}

[data-theme="dark"] .note-alert {
  background: rgba(221, 0, 0, 0.15);
}
  </style>
</head>
<body>
  <header class="toolbar">
    <div class="logo">ğŸ“ mdvim <span style="font-size: 0.8em; color: var(--accent-green);">v0.3.3</span></div>
    <div class="view-controls">
      <button id="btn-edit" onclick="setViewMode('edit')">ç·¨é›†</button>
      <button id="btn-preview" onclick="setViewMode('preview')">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</button>
      <button id="btn-split" class="active" onclick="setViewMode('split')">åˆ†å‰²</button>
      <span style="margin: 0 0.5rem; color: var(--border);">|</span>
      <button id="btn-theme-dark" class="active" onclick="setTheme('dark')">ğŸŒ™</button>
      <button id="btn-theme-light" onclick="setTheme('light')">â˜€ï¸</button>
      <button id="btn-theme-original" onclick="setTheme('original')">ğŸ’»</button>
      <span style="margin: 0 0.5rem; color: var(--border);">|</span>
      <button onclick="VimEditor.decreaseFontSize()" title="æ–‡å­—ã‚’å°ã•ã">A-</button>
      <span id="font-size-display">100%</span>
      <button onclick="VimEditor.increaseFontSize()" title="æ–‡å­—ã‚’å¤§ãã">A+</button>
    </div>
  </header>
  
  <main id="main-container" class="split-view">
    <div id="toc-pane">
      <div id="toc-header">
        <span>ç›®æ¬¡</span>
        <button id="toc-toggle" onclick="VimEditor.toggleToc()" title="ç›®æ¬¡ã‚’é–‰ã˜ã‚‹">â—€</button>
      </div>
      <div id="toc-content"></div>
    </div>
    <button id="toc-open-btn" class="hidden" onclick="VimEditor.toggleToc()" title="ç›®æ¬¡ã‚’é–‹ã">â–¶</button>
    <div id="editor-pane" class="pane">
      <div id="editor-controls">
        <span id="vim-mode">NORMAL</span>
        <span id="cursor-pos">1:1</span>
        <span id="macro-indicator">â—REC</span>
        <button id="btn-vim-mode" onclick="VimEditor.toggleVimMode()" title="VIM/ç·¨é›†ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿">NOVIM</button>
      </div>
      <div id="editor-content">
        <div id="line-numbers"></div>
        <div id="editor-wrapper">
          <textarea id="editor" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
          <div id="cursor-overlay"></div>
        </div>
      </div>
    </div>
    <div id="preview-pane" class="pane">
      <div id="preview-controls">
        <button onclick="VimEditor.foldAllHeadings()" title="å…¨ã¦æŠ˜ã‚ŠãŸãŸã‚€">â–¶ å…¨ã¦æŠ˜ã‚ŠãŸãŸã‚€</button>
        <button onclick="VimEditor.unfoldAllHeadings()" title="å…¨ã¦å±•é–‹">â–¼ å…¨ã¦å±•é–‹</button>
      </div>
      <div id="preview-content"></div>
    </div>
  </main>
  
  <div id="command-line" class="hidden">
    <span id="command-prefix">:</span>
    <input type="text" id="command-input">
  </div>
  
  <input type="file" id="file-input" accept=".md,.txt,.markdown" style="display: none;">
  
  <footer id="status-bar">
    <span id="file-name">ç„¡é¡Œ</span>
    <span id="file-status"></span>
    <span id="help-hint">? ã§ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º</span>
  </footer>
  
  <div id="help-modal" class="modal hidden">
    <div class="modal-content">
      <h2>âŒ¨ï¸ ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰ãƒ˜ãƒ«ãƒ—ï¼ˆæ‹¡å¼µç‰ˆï¼‰</h2>
      <div class="help-columns">
        <div class="help-section">
          <h3>ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿</h3>
          <ul>
            <li><kbd>i</kbd> æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ï¼ˆã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ï¼‰</li>
            <li><kbd>I</kbd> æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ï¼ˆè¡Œé ­ï¼‰</li>
            <li><kbd>a</kbd> æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ï¼ˆã‚«ãƒ¼ã‚½ãƒ«å¾Œï¼‰</li>
            <li><kbd>A</kbd> æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ï¼ˆè¡Œæœ«ï¼‰</li>
            <li><kbd>o</kbd> ä¸‹ã«æ–°ã—ã„è¡Œã‚’æŒ¿å…¥</li>
            <li><kbd>O</kbd> ä¸Šã«æ–°ã—ã„è¡Œã‚’æŒ¿å…¥</li>
            <li><kbd>v</kbd> ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ‰</li>
            <li><kbd>V</kbd> è¡Œãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ‰</li>
            <li><kbd>Esc</kbd> / <kbd>Ctrl+[</kbd> ãƒãƒ¼ãƒãƒ«ã¸</li>
            <li><kbd>:</kbd> ã‚³ãƒãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰</li>
          </ul>
        </div>
        <div class="help-section">
          <h3>ç§»å‹•</h3>
          <ul>
            <li><kbd>h</kbd>/<kbd>j</kbd>/<kbd>k</kbd>/<kbd>l</kbd> å·¦/ä¸‹/ä¸Š/å³</li>
            <li><kbd>w</kbd>/<kbd>b</kbd> å˜èªç§»å‹•ï¼ˆæ¬¡/å‰ï¼‰</li>
            <li><kbd>e</kbd> å˜èªæœ«å°¾ã¸</li>
            <li><kbd>0</kbd>/<kbd>$</kbd> è¡Œé ­/è¡Œæœ«</li>
            <li><kbd>^</kbd> æœ€åˆã®éç©ºç™½æ–‡å­—ã¸</li>
            <li><kbd>gg</kbd>/<kbd>G</kbd> ãƒ•ã‚¡ã‚¤ãƒ«å…ˆé ­/æœ«å°¾</li>
            <li><kbd>f</kbd><i>x</i> / <kbd>F</kbd><i>x</i> è¡Œå†…ã§<i>x</i>ã¸<span class="new-feature">NEW</span></li>
            <li><kbd>t</kbd><i>x</i> / <kbd>T</kbd><i>x</i> <i>x</i>ã®æ‰‹å‰ã¸<span class="new-feature">NEW</span></li>
            <li><kbd>;</kbd> / <kbd>,</kbd> f/t ã‚’ç¹°ã‚Šè¿”ã—<span class="new-feature">NEW</span></li>
            <li><kbd>%</kbd> å¯¾å¿œæ‹¬å¼§ã¸ã‚¸ãƒ£ãƒ³ãƒ—<span class="new-feature">NEW</span></li>
            <li><kbd>{</kbd> / <kbd>}</kbd> ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ç§»å‹•<span class="new-feature">NEW</span></li>
            <li><kbd>Ctrl+f</kbd>/<kbd>Ctrl+b</kbd> 1ãƒšãƒ¼ã‚¸ç§»å‹•<span class="new-feature">NEW</span></li>
            <li><kbd>Ctrl+d</kbd>/<kbd>Ctrl+u</kbd> åŠãƒšãƒ¼ã‚¸ç§»å‹•</li>
          </ul>
        </div>
        <div class="help-section">
          <h3>ç·¨é›†</h3>
          <ul>
            <li><kbd>x</kbd> / <kbd>X</kbd> æ–‡å­—å‰Šé™¤</li>
            <li><kbd>dd</kbd> / <kbd>dw</kbd> / <kbd>D</kbd> å‰Šé™¤</li>
            <li><kbd>cc</kbd> / <kbd>cw</kbd> / <kbd>C</kbd> / <kbd>S</kbd> å¤‰æ›´</li>
            <li><kbd>yy</kbd> / <kbd>yw</kbd> / <kbd>Y</kbd> ãƒ¤ãƒ³ã‚¯</li>
            <li><kbd>p</kbd> / <kbd>P</kbd> è²¼ã‚Šä»˜ã‘</li>
            <li><kbd>u</kbd> / <kbd>Ctrl+r</kbd> ã‚¢ãƒ³ãƒ‰ã‚¥/ãƒªãƒ‰ã‚¥</li>
            <li><kbd>.</kbd> ç›´å‰ã®ç·¨é›†ã‚’ç¹°ã‚Šè¿”ã—<span class="new-feature">NEW</span></li>
            <li><kbd>~</kbd> å¤§æ–‡å­—/å°æ–‡å­—åˆ‡æ›¿<span class="new-feature">NEW</span></li>
            <li><kbd>J</kbd> è¡Œã‚’çµåˆ</li>
            <li><kbd>r</kbd><i>x</i> 1æ–‡å­—ç½®æ›</li>
            <li><kbd>>></kbd> / <kbd><<</kbd> ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ<span class="new-feature">NEW</span></li>
          </ul>
        </div>
        <div class="help-section">
          <h3>ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ<span class="new-feature">NEW</span></h3>
          <ul>
            <li><kbd>diw</kbd> / <kbd>daw</kbd> å˜èªå‰Šé™¤</li>
            <li><kbd>ciw</kbd> / <kbd>caw</kbd> å˜èªå¤‰æ›´</li>
            <li><kbd>di"</kbd> / <kbd>da"</kbd> "..."å†…ã‚’å‰Šé™¤</li>
            <li><kbd>di'</kbd> / <kbd>da'</kbd> '...'å†…ã‚’å‰Šé™¤</li>
            <li><kbd>di(</kbd> / <kbd>da(</kbd> (...)å†…ã‚’å‰Šé™¤</li>
            <li><kbd>di[</kbd> / <kbd>da[</kbd> [...]å†…ã‚’å‰Šé™¤</li>
            <li><kbd>di{</kbd> / <kbd>da{</kbd> {...}å†…ã‚’å‰Šé™¤</li>
            <li><kbd>di`</kbd> / <kbd>da`</kbd> `...`å†…ã‚’å‰Šé™¤</li>
            <li><kbd>yi</kbd><i>x</i> / <kbd>ci</kbd><i>x</i> ã‚‚åŒæ§˜</li>
          </ul>
        </div>
        <div class="help-section">
          <h3>ãƒãƒ¼ã‚¯<span class="new-feature">NEW</span></h3>
          <ul>
            <li><kbd>m</kbd><i>a-z</i> ä½ç½®ã‚’ãƒãƒ¼ã‚¯</li>
            <li><kbd>'</kbd><i>a-z</i> ãƒãƒ¼ã‚¯è¡Œé ­ã¸</li>
            <li><kbd>`</kbd><i>a-z</i> ãƒãƒ¼ã‚¯ä½ç½®ã¸</li>
            <li><kbd>''</kbd> ç›´å‰ä½ç½®ã¸æˆ»ã‚‹</li>
          </ul>
          <h3 style="margin-top: 1rem;">ãƒã‚¯ãƒ­<span class="new-feature">NEW</span></h3>
          <ul>
            <li><kbd>q</kbd><i>a-z</i> è¨˜éŒ²é–‹å§‹</li>
            <li><kbd>q</kbd> è¨˜éŒ²çµ‚äº†</li>
            <li><kbd>@</kbd><i>a-z</i> ãƒã‚¯ãƒ­å†ç”Ÿ</li>
            <li><kbd>@@</kbd> ç›´å‰ã®ãƒã‚¯ãƒ­å†ç”Ÿ</li>
          </ul>
        </div>
        <div class="help-section">
          <h3>æ¤œç´¢ãƒ»ç½®æ›</h3>
          <ul>
            <li><kbd>/</kbd><i>pattern</i> å‰æ–¹æ¤œç´¢</li>
            <li><kbd>n</kbd> / <kbd>N</kbd> æ¬¡/å‰ã®æ¤œç´¢çµæœ</li>
            <li><kbd>*</kbd> ã‚«ãƒ¼ã‚½ãƒ«ä¸‹ã®å˜èªã‚’æ¤œç´¢</li>
            <li><kbd>:s/old/new/</kbd> ç½®æ›ï¼ˆç¾åœ¨è¡Œï¼‰<span class="new-feature">NEW</span></li>
            <li><kbd>:%s/old/new/g</kbd> å…¨ç½®æ›<span class="new-feature">NEW</span></li>
            <li><kbd>:n,ms/old/new/g</kbd> ç¯„å›²ç½®æ›<span class="new-feature">NEW</span></li>
          </ul>
          <h3 style="margin-top: 1rem;">ã‚³ãƒãƒ³ãƒ‰</h3>
          <ul>
            <li><kbd>:w</kbd> ä¿å­˜ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã<span class="new-feature">NEW</span></li>
            <li><kbd>:w file.md</kbd> æŒ‡å®šåã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</li>
            <li><kbd>:e</kbd> ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã<span class="new-feature">NEW</span></li>
            <li><kbd>:r</kbd> ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«æŒ¿å…¥</li>
            <li><kbd>:new</kbd> æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«<span class="new-feature">NEW</span></li>
            <li><kbd>:ls</kbd> ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜<span class="new-feature">NEW</span></li>
            <li><kbd>:q</kbd> / <kbd>:wq</kbd> çµ‚äº†</li>
            <li><kbd>:set nu/nonu</kbd> è¡Œç•ªå·åˆ‡æ›¿</li>
            <li><kbd>:set vim/novim</kbd> ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿</li>
            <li><kbd>:set autosave=off|1s|5s...</kbd> è‡ªå‹•ä¿å­˜è¨­å®š<span class="new-feature">NEW</span></li>
            <li><kbd>:theme dark/light/original</kbd> ãƒ†ãƒ¼ãƒå¤‰æ›´<span class="new-feature">NEW</span></li>
            <li><kbd>:help</kbd> ãƒ˜ãƒ«ãƒ—è¡¨ç¤º</li>
          </ul>
        </div>
      </div>
      <div class="help-section" style="margin-top: 1rem;">
        <h3>æ•°å¼ï¼ˆLaTeXï¼‰<span class="new-feature">NEW</span></h3>
        <ul style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.3rem;">
          <li><kbd>$...$</kbd> ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³æ•°å¼</li>
          <li><kbd>$$...$$</kbd> ãƒ–ãƒ­ãƒƒã‚¯æ•°å¼</li>
          <li><kbd>\frac{a}{b}</kbd> åˆ†æ•°</li>
          <li><kbd>\sqrt{x}</kbd> å¹³æ–¹æ ¹</li>
          <li><kbd>x^{2}</kbd> ä¸Šä»˜ã</li>
          <li><kbd>x_{i}</kbd> ä¸‹ä»˜ã</li>
          <li><kbd>\sum_{i=0}^{n}</kbd> ç·å’Œ</li>
          <li><kbd>\int_{a}^{b}</kbd> ç©åˆ†</li>
          <li><kbd>\alpha \beta</kbd> ã‚®ãƒªã‚·ãƒ£æ–‡å­—</li>
          <li><kbd>\mathbf{x}</kbd> å¤ªå­—</li>
        </ul>
        <h3 style="margin-top: 1rem;">ãƒ†ãƒ¼ãƒ–ãƒ«<span class="new-feature">NEW</span></h3>
        <ul>
          <li><kbd>| A | B |</kbd> ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œ</li>
          <li><kbd>|---|---|</kbd> åŒºåˆ‡ã‚Šè¡Œ</li>
          <li><kbd>|:--|</kbd> å·¦å¯„ã› <kbd>|:-:|</kbd> ä¸­å¤® <kbd>|--:|</kbd> å³å¯„ã›</li>
        </ul>
        <h3 style="margin-top: 1rem;">Mermaidå›³<span class="new-feature">NEW</span></h3>
        <ul>
          <li><kbd>```mermaid</kbd> å›³ãƒ–ãƒ­ãƒƒã‚¯é–‹å§‹</li>
          <li><kbd>graph TD</kbd> ãƒ•ãƒ­ãƒ¼ãƒãƒ£ãƒ¼ãƒˆï¼ˆä¸Šâ†’ä¸‹ï¼‰</li>
          <li><kbd>graph LR</kbd> ãƒ•ãƒ­ãƒ¼ãƒãƒ£ãƒ¼ãƒˆï¼ˆå·¦â†’å³ï¼‰</li>
          <li><kbd>sequenceDiagram</kbd> ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å›³</li>
          <li><kbd>classDiagram</kbd> ã‚¯ãƒ©ã‚¹å›³</li>
          <li><kbd>gantt</kbd> ã‚¬ãƒ³ãƒˆãƒãƒ£ãƒ¼ãƒˆ</li>
          <li><kbd>pie</kbd> å††ã‚°ãƒ©ãƒ•</li>
        </ul>
        <h3 style="margin-top: 1rem;">æŠ˜ã‚Šç•³ã¿<span class="new-feature">NEW</span></h3>
        <ul>
          <li><kbd>:::details ã‚¿ã‚¤ãƒˆãƒ«</kbd> æŠ˜ã‚Šç•³ã¿é–‹å§‹</li>
          <li><kbd>:::</kbd> æŠ˜ã‚Šç•³ã¿çµ‚äº†</li>
          <li>å†…éƒ¨ã«Markdownè¨˜æ³•ã‚’ä½¿ç”¨å¯èƒ½</li>
        </ul>
        <h3 style="margin-top: 1rem;">è¦‹å‡ºã—æŠ˜ã‚Šç•³ã¿<span class="new-feature">NEW</span></h3>
        <ul>
          <li>ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è¦‹å‡ºã—ã‚’ã‚¯ãƒªãƒƒã‚¯ã§æŠ˜ã‚Šç•³ã¿</li>
          <li>ã€Œå…¨ã¦æŠ˜ã‚ŠãŸãŸã‚€ã€ã€Œå…¨ã¦å±•é–‹ã™ã‚‹ã€ãƒœã‚¿ãƒ³</li>
          <li>åŒãƒ¬ãƒ™ãƒ«ä»¥ä¸Šã®è¦‹å‡ºã—ã¾ã§æŠ˜ã‚Šç•³ã¿</li>
        </ul>
      </div>
      <button onclick="toggleHelp()">é–‰ã˜ã‚‹ (Esc)</button>
    </div>
  </div>
  
  <script>

// Vimã‚¨ãƒ‡ã‚£ã‚¿æ‹¡å¼µç‰ˆ

/**
 * Markdown Parser
 * ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’HTMLã«å¤‰æ›ã™ã‚‹ãƒ‘ãƒ¼ã‚µãƒ¼
 */
const MarkdownParser = {
  escapeHtml(text) {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  },
  
  // ãƒã‚¹ãƒˆã•ã‚ŒãŸãƒªã‚¹ãƒˆã‚’ãƒ‘ãƒ¼ã‚¹
  parseNestedList(items) {
    if (items.length === 0) return '';
    
    const buildList = (items, startIdx, baseIndent) => {
      let html = '';
      let i = startIdx;
      let firstItem = true;
      let listType = items[i].type;
      let isTask = items[i].isTask;
      
      // ãƒªã‚¹ãƒˆé–‹å§‹ã‚¿ã‚°
      if (listType === 'ol') {
        html += '<ol>';
      } else if (isTask) {
        html += '<ul class="task-list">';
      } else {
        html += '<ul>';
      }
      
      while (i < items.length) {
        const item = items[i];
        
        if (item.indent < baseIndent) {
          // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãŒæµ…ããªã£ãŸã‚‰ã€ã“ã®ãƒªã‚¹ãƒˆã‚’çµ‚äº†
          break;
        }
        
        if (item.indent === baseIndent) {
          // åŒã˜ãƒ¬ãƒ™ãƒ«ã®ã‚¢ã‚¤ãƒ†ãƒ 
          if (item.isTask) {
            const checked = item.checked ? 'checked' : '';
            html += `<li class="task-item"><input type="checkbox" ${checked} disabled>${this.parseInline(item.content)}`;
          } else {
            html += `<li>${this.parseInline(item.content)}`;
          }
          
          // æ¬¡ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ˆã‚Šæ·±ã„ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‹ç¢ºèª
          if (i + 1 < items.length && items[i + 1].indent > baseIndent) {
            // ã‚µãƒ–ãƒªã‚¹ãƒˆã‚’å†å¸°çš„ã«å‡¦ç†
            const subResult = buildList(items, i + 1, items[i + 1].indent);
            html += subResult.html;
            i = subResult.endIdx;
          } else {
            i++;
          }
          html += '</li>';
        } else {
          // æ·±ã„ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆï¼ˆé€šå¸¸ã¯å†å¸°ã§å‡¦ç†ã•ã‚Œã‚‹ï¼‰
          i++;
        }
      }
      
      // ãƒªã‚¹ãƒˆçµ‚äº†ã‚¿ã‚°
      html += listType === 'ol' ? '</ol>' : '</ul>';
      
      return { html, endIdx: i };
    };
    
    return buildList(items, 0, items[0].indent).html;
  },
  
  parseInline(text) {
    let result = text;
    
    // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³æ•°å¼ $...$ ã‚’å‡¦ç†ï¼ˆ$$ã‚’é™¤å¤–ï¼‰
    result = result.replace(/(?<!\$)\$(?!\$)([^$\n]+?)\$(?!\$)/g, (match, formula) => {
      return `<span class="math-inline" data-math="${this.escapeHtml(formula)}"></span>`;
    });
    
    result = result.replace(/`([^`]+)`/g, '<code>$1</code>');
    result = result.replace(/~~([^~]+)~~/g, '<del>$1</del>');
    result = result.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    result = result.replace(/__([^_]+)__/g, '<strong>$1</strong>');
    result = result.replace(/\*([^*]+)\*/g, '<em>$1</em>');
    result = result.replace(/_([^_]+)_/g, '<em>$1</em>');
    result = result.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
    result = result.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1">');
    
    // è‡ªå‹•ãƒªãƒ³ã‚¯ï¼ˆURLã‚’è‡ªå‹•ã§ãƒªãƒ³ã‚¯åŒ–ï¼‰
    result = result.replace(/(?<!href="|src="|<a[^>]*>)(https?:\/\/[^\s<>"']+)/g, '<a href="$1">$1</a>');
    
    // çµµæ–‡å­—ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰
    result = this.parseEmoji(result);
    
    return result;
  },
  
  // çµµæ–‡å­—å¤‰æ›
  parseEmoji(text) {
    const emojiMap = {
      ':smile:': 'ğŸ˜„', ':laughing:': 'ğŸ˜†', ':blush:': 'ğŸ˜Š', ':smiley:': 'ğŸ˜ƒ',
      ':relaxed:': 'â˜ºï¸', ':smirk:': 'ğŸ˜', ':heart_eyes:': 'ğŸ˜', ':kissing_heart:': 'ğŸ˜˜',
      ':kissing:': 'ğŸ˜—', ':flushed:': 'ğŸ˜³', ':relieved:': 'ğŸ˜Œ', ':satisfied:': 'ğŸ˜†',
      ':grin:': 'ğŸ˜', ':wink:': 'ğŸ˜‰', ':stuck_out_tongue_winking_eye:': 'ğŸ˜œ',
      ':stuck_out_tongue:': 'ğŸ˜›', ':sleeping:': 'ğŸ˜´', ':worried:': 'ğŸ˜Ÿ',
      ':frowning:': 'ğŸ˜¦', ':anguished:': 'ğŸ˜§', ':open_mouth:': 'ğŸ˜®', ':grimacing:': 'ğŸ˜¬',
      ':confused:': 'ğŸ˜•', ':hushed:': 'ğŸ˜¯', ':expressionless:': 'ğŸ˜‘', ':unamused:': 'ğŸ˜’',
      ':sweat_smile:': 'ğŸ˜…', ':sweat:': 'ğŸ˜“', ':weary:': 'ğŸ˜©', ':pensive:': 'ğŸ˜”',
      ':disappointed:': 'ğŸ˜', ':confounded:': 'ğŸ˜–', ':fearful:': 'ğŸ˜¨', ':cold_sweat:': 'ğŸ˜°',
      ':persevere:': 'ğŸ˜£', ':cry:': 'ğŸ˜¢', ':sob:': 'ğŸ˜­', ':joy:': 'ğŸ˜‚', ':astonished:': 'ğŸ˜²',
      ':scream:': 'ğŸ˜±', ':tired_face:': 'ğŸ˜«', ':angry:': 'ğŸ˜ ', ':rage:': 'ğŸ˜¡',
      ':triumph:': 'ğŸ˜¤', ':sleepy:': 'ğŸ˜ª', ':yum:': 'ğŸ˜‹', ':mask:': 'ğŸ˜·',
      ':sunglasses:': 'ğŸ˜', ':dizzy_face:': 'ğŸ˜µ', ':imp:': 'ğŸ‘¿', ':smiling_imp:': 'ğŸ˜ˆ',
      ':neutral_face:': 'ğŸ˜', ':no_mouth:': 'ğŸ˜¶', ':innocent:': 'ğŸ˜‡', ':alien:': 'ğŸ‘½',
      ':heart:': 'â¤ï¸', ':broken_heart:': 'ğŸ’”', ':star:': 'â­', ':star2:': 'ğŸŒŸ',
      ':sparkles:': 'âœ¨', ':zap:': 'âš¡', ':fire:': 'ğŸ”¥', ':boom:': 'ğŸ’¥',
      ':+1:': 'ğŸ‘', ':thumbsup:': 'ğŸ‘', ':-1:': 'ğŸ‘', ':thumbsdown:': 'ğŸ‘',
      ':ok_hand:': 'ğŸ‘Œ', ':punch:': 'ğŸ‘Š', ':fist:': 'âœŠ', ':v:': 'âœŒï¸',
      ':wave:': 'ğŸ‘‹', ':hand:': 'âœ‹', ':clap:': 'ğŸ‘', ':pray:': 'ğŸ™',
      ':point_up:': 'â˜ï¸', ':point_down:': 'ğŸ‘‡', ':point_left:': 'ğŸ‘ˆ', ':point_right:': 'ğŸ‘‰',
      ':rocket:': 'ğŸš€', ':warning:': 'âš ï¸', ':x:': 'âŒ', ':white_check_mark:': 'âœ…',
      ':heavy_check_mark:': 'âœ”ï¸', ':question:': 'â“', ':exclamation:': 'â—',
      ':bulb:': 'ğŸ’¡', ':memo:': 'ğŸ“', ':book:': 'ğŸ“–', ':bookmark:': 'ğŸ”–',
      ':link:': 'ğŸ”—', ':wrench:': 'ğŸ”§', ':hammer:': 'ğŸ”¨', ':nut_and_bolt:': 'ğŸ”©',
      ':gear:': 'âš™ï¸', ':package:': 'ğŸ“¦', ':tada:': 'ğŸ‰', ':100:': 'ğŸ’¯',
      ':bug:': 'ğŸ›', ':construction:': 'ğŸš§', ':rotating_light:': 'ğŸš¨',
      ':lock:': 'ğŸ”’', ':unlock:': 'ğŸ”“', ':key:': 'ğŸ”‘', ':mag:': 'ğŸ”',
      ':email:': 'ğŸ“§', ':phone:': 'ğŸ“±', ':computer:': 'ğŸ’»', ':desktop_computer:': 'ğŸ–¥ï¸',
      ':folder:': 'ğŸ“', ':file_folder:': 'ğŸ“‚', ':clipboard:': 'ğŸ“‹',
      ':calendar:': 'ğŸ“…', ':clock:': 'ğŸ•', ':hourglass:': 'âŒ›',
      ':sun:': 'â˜€ï¸', ':moon:': 'ğŸŒ™', ':cloud:': 'â˜ï¸', ':umbrella:': 'â˜‚ï¸',
      ':snowflake:': 'â„ï¸', ':coffee:': 'â˜•', ':beer:': 'ğŸº', ':pizza:': 'ğŸ•'
    };
    
    return text.replace(/:([a-z0-9_+-]+):/g, (match, code) => {
      return emojiMap[match] || match;
    });
  },
  
  parse(markdown) {
    // CRLFã‚’LFã«æ­£è¦åŒ–
    markdown = markdown.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    const lines = markdown.split('\n');
    const html = [];
    let inCodeBlock = false;
    let inMathBlock = false;
    let mathBuffer = [];
    let listBuffer = [];
    let tableRows = [];
    let codeLang = '';
    let codeBuffer = [];
    let inDetails = false;
    let detailsBuffer = [];
    let detailsSummary = '';
    let blockquoteBuffer = [];
    let alertType = null;
    let inNote = false;
    let noteType = '';
    let noteBuffer = [];
    
    // ãƒªã‚¹ãƒˆãƒãƒƒãƒ•ã‚¡ã‚’ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
    const flushList = () => {
      if (listBuffer.length > 0) {
        html.push(this.parseNestedList(listBuffer));
        listBuffer = [];
      }
    };
    
    for (const line of lines) {
      // æŠ˜ã‚Šç•³ã¿é–‹å§‹ :::details ã‚¿ã‚¤ãƒˆãƒ«
      const detailsStart = line.match(/^:::details\s*(.*)$/);
      if (detailsStart && !inCodeBlock && !inMathBlock) {
        flushList();
        inDetails = true;
        detailsSummary = detailsStart[1] || 'è©³ç´°';
        detailsBuffer = [];
        continue;
      }
      
      // æŠ˜ã‚Šç•³ã¿çµ‚äº† :::
      if (line.trim() === ':::' && inDetails && !inCodeBlock && !inMathBlock) {
        const innerHtml = this.parse(detailsBuffer.join('\n'));
        html.push(`<details class="collapsible"><summary>${this.parseInline(detailsSummary)}</summary><div class="details-content">${innerHtml}</div></details>`);
        inDetails = false;
        detailsBuffer = [];
        detailsSummary = '';
        continue;
      }
      
      // æŠ˜ã‚Šç•³ã¿å†…éƒ¨
      if (inDetails) {
        detailsBuffer.push(line);
        continue;
      }
      
      // Qiita noteè¨˜æ³•é–‹å§‹ :::note [info|warn|alert]
      const noteStart = line.match(/^:::note\s*(info|warn|alert)?$/i);
      if (noteStart && !inCodeBlock && !inMathBlock && !inNote) {
        flushList();
        inNote = true;
        noteType = (noteStart[1] || 'info').toLowerCase();
        noteBuffer = [];
        continue;
      }
      
      // Qiita noteçµ‚äº† :::
      if (line.trim() === ':::' && inNote && !inCodeBlock && !inMathBlock) {
        const innerHtml = this.parse(noteBuffer.join('\n'));
        const noteIcons = { 'info': 'âœ…', 'warn': 'âš ï¸', 'alert': 'ğŸš«' };
        html.push(`<div class="note note-${noteType}"><span class="note-icon">${noteIcons[noteType]}</span><div class="note-content">${innerHtml}</div></div>`);
        inNote = false;
        noteBuffer = [];
        noteType = '';
        continue;
      }
      
      // noteå†…éƒ¨
      if (inNote) {
        noteBuffer.push(line);
        continue;
      }
      
      // ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯
      if (line.startsWith('```')) {
        if (inCodeBlock) {
          // Mermaidãƒ–ãƒ­ãƒƒã‚¯ã®å ´åˆ
          if (codeLang === 'mermaid') {
            const mermaidCode = codeBuffer.join('\n');
            html.push(`<div class="mermaid">${mermaidCode}</div>`);
          } else {
            // ã‚³ãƒ¼ãƒ‰ãƒãƒƒãƒ•ã‚¡ã‚’çµåˆã—ã¦ä¸€åº¦ã«å‡ºåŠ›
            html.push(`<pre><code class="language-${codeLang}">${codeBuffer.join('\n')}</code></pre>`);
          }
          codeBuffer = [];
          inCodeBlock = false;
          codeLang = '';
        } else {
          codeLang = line.slice(3).trim() || 'text';
          inCodeBlock = true;
        }
        continue;
      }
      
      if (inCodeBlock) {
        if (codeLang === 'mermaid') {
          codeBuffer.push(line);
        } else {
          codeBuffer.push(this.escapeHtml(line));
        }
        continue;
      }
      
      // æ•°å¼ãƒ–ãƒ­ãƒƒã‚¯ $$...$$ 
      if (line.trim() === '$$') {
        if (inMathBlock) {
          const formula = mathBuffer.join('\n');
          html.push(`<div class="math-block" data-math="${this.escapeHtml(formula)}"></div>`);
          mathBuffer = [];
          inMathBlock = false;
        } else {
          flushList();
          inMathBlock = true;
        }
        continue;
      }
      
      // 1è¡Œã®æ•°å¼ãƒ–ãƒ­ãƒƒã‚¯ $$...$$
      const singleLineMath = line.match(/^\$\$(.+)\$\$$/);
      if (singleLineMath) {
        flushList();
        html.push(`<div class="math-block" data-math="${this.escapeHtml(singleLineMath[1])}"></div>`);
        continue;
      }
      
      if (inMathBlock) {
        mathBuffer.push(line);
        continue;
      }
      
      // è¦‹å‡ºã—
      const headingMatch = line.match(/^(#{1,6})\s+(.+)$/);
      if (headingMatch) {
        flushList();
        const level = headingMatch[1].length;
        html.push(`<h${level}>${this.parseInline(headingMatch[2])}</h${level}>`);
        continue;
      }
      
      // æ°´å¹³ç·š
      if (/^(---|\*\*\*|___)$/.test(line.trim())) {
        flushList();
        html.push('<hr>');
        continue;
      }
      
      // å¼•ç”¨ï¼ˆè¤‡æ•°è¡Œå¯¾å¿œ + GitHub Alertsï¼‰
      if (line.startsWith('>')) {
        flushList();
        if (tableRows.length > 0) { html.push(this.parseTable(tableRows)); tableRows = []; }
        
        const content = line.slice(1).trim();
        
        // GitHub Alerts ã®ãƒã‚§ãƒƒã‚¯
        const alertMatch = content.match(/^\[!(NOTE|TIP|IMPORTANT|WARNING|CAUTION)\]$/i);
        if (alertMatch && blockquoteBuffer.length === 0) {
          alertType = alertMatch[1].toUpperCase();
          blockquoteBuffer.push('');
          continue;
        }
        
        blockquoteBuffer.push(content);
        continue;
      } else if (blockquoteBuffer.length > 0) {
        // å¼•ç”¨ãƒ–ãƒ­ãƒƒã‚¯ã‚’å‡ºåŠ›
        const content = blockquoteBuffer.filter(l => l).map(l => this.parseInline(l)).join('<br>');
        if (alertType) {
          const alertIcons = {
            'NOTE': 'â„¹ï¸',
            'TIP': 'ğŸ’¡', 
            'IMPORTANT': 'â—',
            'WARNING': 'âš ï¸',
            'CAUTION': 'ğŸ”´'
          };
          html.push(`<div class="alert alert-${alertType.toLowerCase()}"><span class="alert-title">${alertIcons[alertType]} ${alertType}</span><p>${content}</p></div>`);
        } else {
          html.push(`<blockquote>${content}</blockquote>`);
        }
        blockquoteBuffer = [];
        alertType = null;
      }
      
      // ãƒ†ãƒ¼ãƒ–ãƒ«è¡Œã®æ¤œå‡º
      if (line.trim().startsWith('|') && line.trim().endsWith('|')) {
        flushList();
        tableRows.push(line);
        continue;
      } else if (tableRows.length > 0) {
        html.push(this.parseTable(tableRows));
        tableRows = [];
      }
      
      // ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆï¼ˆãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ï¼‰- ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆå¯¾å¿œ
      const taskMatch = line.match(/^(\s*)([-*+])\s+\[([ xX])\]\s+(.+)$/);
      if (taskMatch) {
        const indent = taskMatch[1].length;
        const checked = taskMatch[3].toLowerCase() === 'x';
        const content = taskMatch[4];
        listBuffer.push({ type: 'ul', indent, content, isTask: true, checked });
        continue;
      }
      
      // é †åºãªã—ãƒªã‚¹ãƒˆ - ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆå¯¾å¿œ
      const ulMatch = line.match(/^(\s*)([-*+])\s+(.+)$/);
      if (ulMatch) {
        const indent = ulMatch[1].length;
        const content = ulMatch[3];
        listBuffer.push({ type: 'ul', indent, content, isTask: false, checked: false });
        continue;
      }
      
      // é †åºã‚ã‚Šãƒªã‚¹ãƒˆ - ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆå¯¾å¿œ
      const olMatch = line.match(/^(\s*)(\d+)\.\s+(.+)$/);
      if (olMatch) {
        const indent = olMatch[1].length;
        const content = olMatch[3];
        listBuffer.push({ type: 'ol', indent, content, isTask: false, checked: false });
        continue;
      }
      
      // ç©ºè¡Œ
      if (line.trim() === '') {
        flushList();
        if (tableRows.length > 0) {
          html.push(this.parseTable(tableRows));
          tableRows = [];
        }
        continue;
      }
      
      // é€šå¸¸ã®ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•
      flushList();
      if (tableRows.length > 0) { html.push(this.parseTable(tableRows)); tableRows = []; }
      html.push(`<p>${this.parseInline(line)}</p>`);
    }
    
    // é–‰ã˜ã‚¿ã‚°ã®å‡¦ç†
    flushList();
    if (inCodeBlock) {
      html.push(`<pre><code class="language-${codeLang || 'text'}">${codeBuffer.join('\n')}</code></pre>`);
    }
    if (tableRows.length > 0) html.push(this.parseTable(tableRows));
    if (blockquoteBuffer.length > 0) {
      const content = blockquoteBuffer.filter(l => l).map(l => this.parseInline(l)).join('<br>');
      if (alertType) {
        const alertIcons = { 'NOTE': 'â„¹ï¸', 'TIP': 'ğŸ’¡', 'IMPORTANT': 'â—', 'WARNING': 'âš ï¸', 'CAUTION': 'ğŸ”´' };
        html.push(`<div class="alert alert-${alertType.toLowerCase()}"><span class="alert-title">${alertIcons[alertType]} ${alertType}</span><p>${content}</p></div>`);
      } else {
        html.push(`<blockquote>${content}</blockquote>`);
      }
    }
    
    return html.join('\n');
  },
  
  parseTable(rows) {
    if (rows.length < 2) return '';
    
    const parseRow = (row) => {
      return row.trim()
        .replace(/^\|/, '')
        .replace(/\|$/, '')
        .split('|')
        .map(cell => cell.trim());
    };
    
    const headerCells = parseRow(rows[0]);
    
    // 2è¡Œç›®ãŒåŒºåˆ‡ã‚Šè¡Œã‹ãƒã‚§ãƒƒã‚¯
    const separatorRow = rows[1].trim();
    if (!/^\|[\s\-:|]+\|$/.test(separatorRow)) {
      return rows.map(row => `<p>${this.parseInline(row)}</p>`).join('\n');
    }
    
    // ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã‚’è§£æ
    const alignments = parseRow(rows[1]).map(cell => {
      if (cell.startsWith(':') && cell.endsWith(':')) return 'center';
      if (cell.endsWith(':')) return 'right';
      return 'left';
    });
    
    let html = '<table><thead><tr>';
    headerCells.forEach((cell, i) => {
      const align = alignments[i] || 'left';
      html += `<th style="text-align: ${align}">${this.parseInline(cell)}</th>`;
    });
    html += '</tr></thead><tbody>';
    
    // ãƒ‡ãƒ¼ã‚¿è¡Œ
    for (let i = 2; i < rows.length; i++) {
      const cells = parseRow(rows[i]);
      html += '<tr>';
      cells.forEach((cell, j) => {
        const align = alignments[j] || 'left';
        html += `<td style="text-align: ${align}">${this.parseInline(cell)}</td>`;
      });
      html += '</tr>';
    }
    
    html += '</tbody></table>';
    return html;
  }
};

const VimEditor = {
  mode: 'normal',
  vimMode: false,              // VIMãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹/ç„¡åŠ¹ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ç„¡åŠ¹ï¼‰
  register: '',
  searchTerm: '',
  undoStack: [],
  redoStack: [],
  visualStart: null,
  visualLine: false,
  visualCursor: null,    // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã§ã®å®Ÿéš›ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®
  visualStartLine: -1,   // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã§ã®é–‹å§‹è¡Œç•ªå·
  count: '',
  pendingKey: '',
  pendingOperator: '',
  modified: false,
  autoSaveInterval: '1s',      // è‡ªå‹•ä¿å­˜é–“éš”: 'off', '1s', '5s', '10s', '30s', '60s'
  
  // æ–°æ©Ÿèƒ½ç”¨ã®çŠ¶æ…‹
  marks: {},                    // ãƒãƒ¼ã‚¯
  macros: {},                   // ãƒã‚¯ãƒ­
  recordingMacro: null,         // è¨˜éŒ²ä¸­ã®ãƒã‚¯ãƒ­å
  macroBuffer: [],              // ãƒã‚¯ãƒ­è¨˜éŒ²ãƒãƒƒãƒ•ã‚¡
  lastMacro: null,              // æœ€å¾Œã«å®Ÿè¡Œã—ãŸãƒã‚¯ãƒ­
  lastFindChar: null,           // f/F/t/T ã®æœ€å¾Œã®æ–‡å­—
  lastFindDirection: 1,         // 1: forward, -1: backward
  lastFindType: 'f',            // 'f' or 't'
  lastEdit: null,               // ãƒ‰ãƒƒãƒˆãƒªãƒ”ãƒ¼ãƒˆç”¨
  lastEditText: '',             // æŒ¿å…¥ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆ
  previousPosition: null,       // '' ã‚¸ãƒ£ãƒ³ãƒ—ç”¨
  currentFileName: 'ç„¡é¡Œ',      // ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«å
  fileInsertMode: false,        // ãƒ•ã‚¡ã‚¤ãƒ«æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰
  currentFileHandle: null,      // File System Access APIç”¨
  
  init() {
    this.editor = document.getElementById('editor');
    this.preview = document.getElementById('preview-content');
    this.modeIndicator = document.getElementById('vim-mode');
    this.cursorPos = document.getElementById('cursor-pos');
    this.commandLine = document.getElementById('command-line');
    this.commandInput = document.getElementById('command-input');
    this.commandPrefix = document.getElementById('command-prefix');
    this.lineNumbers = document.getElementById('line-numbers');
    this.fileStatus = document.getElementById('file-status');
    this.fileName = document.getElementById('file-name');
    this.macroIndicator = document.getElementById('macro-indicator');
    this.cursorOverlay = document.getElementById('cursor-overlay');
    this.fileInput = document.getElementById('file-input');
    this.fontSizeDisplay = document.getElementById('font-size-display');
    
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³IDï¼ˆã‚¿ãƒ–ã”ã¨ã«ç‹¬ç«‹ï¼‰
    this.sessionId = sessionStorage.getItem('vim-md-session-id');
    if (!this.sessionId) {
      this.sessionId = 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      sessionStorage.setItem('vim-md-session-id', this.sessionId);
    }
    
    // ç›®æ¬¡ãƒ‘ãƒãƒ«
    this.tocPane = document.getElementById('toc-pane');
    this.tocContent = document.getElementById('toc-content');
    this.tocOpenBtn = document.getElementById('toc-open-btn');
    this.tocVisible = true;
    
    // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºï¼ˆ%ï¼‰- ã“ã‚Œã¯å…¨ã‚¿ãƒ–å…±é€šã§OK
    this.fontSize = parseInt(localStorage.getItem('vim-md-font-size')) || 100;
    this.applyFontSize();
    
    // VIMãƒ¢ãƒ¼ãƒ‰è¨­å®šã‚’èª­ã¿è¾¼ã¿
    this.vimMode = localStorage.getItem('vim-md-vim-mode') === 'true';
    this.updateVimModeUI();
    
    // è‡ªå‹•ä¿å­˜è¨­å®šã‚’èª­ã¿è¾¼ã¿
    const savedAutoSave = localStorage.getItem('vim-md-autosave');
    if (savedAutoSave && ['off', '1s', '5s', '10s', '30s', '60s'].includes(savedAutoSave)) {
      this.autoSaveInterval = savedAutoSave;
    }
    
    // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã®ã‚¤ãƒ™ãƒ³ãƒˆ
    this.fileInput.addEventListener('change', e => this.handleFileOpen(e));
    
    // ã‚«ãƒ¼ã‚½ãƒ«è¨ˆæ¸¬ç”¨ã®éš ã—è¦ç´ 
    this.measureSpan = document.createElement('span');
    this.measureSpan.style.cssText = `
      position: absolute;
      visibility: hidden;
      white-space: pre;
      font-family: inherit;
      font-size: 0.95rem;
      line-height: 1.5;
    `;
    document.body.appendChild(this.measureSpan);
    
    this.setupEventListeners();
    this.loadFromStorage();
    this.updateLineNumbers();
    this.updatePreview();
    this.updateToc();
    this.saveState();
    this.updateCursorOverlay();
    
    // NOVIMãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€editableãªçŠ¶æ…‹ã«è¨­å®š
    if (!this.vimMode) {
      this.mode = 'insert';
      this.editor.readOnly = false;
      this.editor.classList.add('insert-mode');  // ã‚«ãƒ¼ã‚½ãƒ«ã‚’è¡¨ç¤º
    }
    
    this.editor.focus();
    this.initialized = true;
  },
  
  setupEventListeners() {
    this.editor.addEventListener('keydown', e => this.handleKeydown(e));
    this.editor.addEventListener('input', e => this.onInput(e));
    this.editor.addEventListener('click', () => this.updateCursorPos());
    this.editor.addEventListener('scroll', () => this.syncScroll());
    this.commandInput.addEventListener('keydown', e => this.handleCommandKey(e));
    
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape' && !document.getElementById('help-modal').classList.contains('hidden')) {
        toggleHelp();
      }
    });
    
    this.editor.addEventListener('scroll', () => {
      this.lineNumbers.scrollTop = this.editor.scrollTop;
      this.updateCursorOverlay();
    });
  },
  
  loadFromStorage() {
    // 1. ã¾ãšsessionStorageã‚’ç¢ºèªï¼ˆã‚¿ãƒ–å¾©å¸°æ™‚ï¼‰
    const sessionContent = sessionStorage.getItem('vim-md-content-' + this.sessionId);
    if (sessionContent) {
      this.editor.value = sessionContent;
      // ãƒ•ã‚¡ã‚¤ãƒ«åã¯localStorageã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å¾©å…ƒ
      try {
        const sessionData = JSON.parse(localStorage.getItem('vim-md-session-' + this.sessionId) || '{}');
        if (sessionData.filename) {
          this.currentFileName = sessionData.filename;
          this.fileName.textContent = sessionData.filename;
        }
      } catch (e) {}
      this.showStatus('ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å¾©å…ƒã—ã¾ã—ãŸ');
      return;
    }
    
    // 2. æ–°è¦ã‚¿ãƒ–ã®å ´åˆã€localStorageã‹ã‚‰æœ€æ–°ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å¾©å…ƒ
    let sessions = [];
    try {
      sessions = JSON.parse(localStorage.getItem('vim-md-sessions') || '[]');
    } catch (e) {
      sessions = [];
    }
    
    if (sessions.length > 0) {
      // æœ€æ–°ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’æ¢ã™
      let latestSession = null;
      let latestTimestamp = 0;
      
      for (const sid of sessions) {
        try {
          const data = JSON.parse(localStorage.getItem('vim-md-session-' + sid) || '{}');
          if (data.timestamp && data.timestamp > latestTimestamp && data.content) {
            latestTimestamp = data.timestamp;
            latestSession = data;
          }
        } catch (e) {}
      }
      
      if (latestSession) {
        this.editor.value = latestSession.content;
        this.currentFileName = latestSession.filename || 'ç„¡é¡Œ';
        this.fileName.textContent = this.currentFileName;
        // ç¾åœ¨ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã§ã‚³ãƒ”ãƒ¼ä¿å­˜
        this.saveSessionData();
        this.showStatus('å‰å›ã®å†…å®¹ã‚’å¾©å…ƒã—ã¾ã—ãŸ');
        return;
      }
    }
    
    // 3. æ—§å½¢å¼ã®localStorageã‹ã‚‰ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    const oldContent = localStorage.getItem('vim-md-content');
    if (oldContent) {
      this.editor.value = oldContent;
      const oldFilename = localStorage.getItem('vim-md-filename');
      if (oldFilename) {
        this.currentFileName = oldFilename;
        this.fileName.textContent = oldFilename;
      }
      // ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼šæ–°å½¢å¼ã§ä¿å­˜
      this.saveSessionData();
      // æ—§å½¢å¼ã‚’å‰Šé™¤
      localStorage.removeItem('vim-md-content');
      localStorage.removeItem('vim-md-filename');
      this.showStatus('å‰å›ã®å†…å®¹ã‚’å¾©å…ƒã—ã¾ã—ãŸ');
      return;
    }
    
    // 4. åˆå›èµ·å‹•æ™‚ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå†…å®¹
    this.editor.value = this.getWelcomeContent();
    // ã‚¦ã‚§ãƒ«ã‚«ãƒ å†…å®¹ã‚‚ç¾åœ¨ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§ä¿å­˜
    this.saveSessionData();
  },
  
  // ã‚¦ã‚§ãƒ«ã‚«ãƒ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å–å¾—
  getWelcomeContent() {
    return `# mdvim v0.3.3 ã¸ã‚ˆã†ã“ãï¼

**mdvim** ã¯ Vimé¢¨ã®Markdownã‚¨ãƒ‡ã‚£ã‚¿ã§ã™ã€‚

## ä¸»ãªæ©Ÿèƒ½

### Vimæ“ä½œ
- \`h\`/\`j\`/\`k\`/\`l\` ã§ã‚«ãƒ¼ã‚½ãƒ«ç§»å‹•
- \`i\`/\`a\`/\`o\` ã§æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰
- \`dd\`/\`yy\`/\`p\` ã§å‰Šé™¤ãƒ»ã‚³ãƒ”ãƒ¼ãƒ»è²¼ã‚Šä»˜ã‘
- \`u\`/\`Ctrl+r\` ã§ã‚¢ãƒ³ãƒ‰ã‚¥ãƒ»ãƒªãƒ‰ã‚¥

### æ¤œç´¢ãƒ»ç½®æ›
- \`/pattern\` ã§æ¤œç´¢
- \`:s/old/new/g\` ã§ç½®æ›
- \`:%s/old/new/g\` ã§å…¨ç½®æ›

### ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ
- \`:w\` ã§ä¿å­˜ãƒ€ã‚¤ã‚¢ãƒ­ã‚°
- \`:e\` ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
- \`:new\` ã§æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«

### è¨­å®šã‚³ãƒãƒ³ãƒ‰
- \`:set vim\` / \`:set novim\` ã§ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
- \`:set autosave=off\` ã§è‡ªå‹•ä¿å­˜ç„¡åŠ¹
- \`:set autosave=5s\` ã§5ç§’é–“éš”ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ1ç§’ï¼‰

### æ•°å¼ï¼ˆLaTeXï¼‰

ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³: $E = mc^2$

ãƒ–ãƒ­ãƒƒã‚¯:
$$
\\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}
$$

### ãƒ†ãƒ¼ãƒ–ãƒ«

| ã‚­ãƒ¼ | å‹•ä½œ |
|:-----|:-----|
| \`h\` | å·¦ã¸ç§»å‹• |
| \`j\` | ä¸‹ã¸ç§»å‹• |
| \`k\` | ä¸Šã¸ç§»å‹• |
| \`l\` | å³ã¸ç§»å‹• |

### Mermaidå›³

\`\`\`mermaid
graph LR
    A[mdvim] --> B[Vimæ“ä½œ]
    A --> C[Markdown]
    A --> D[ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼]
\`\`\`

### ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ

- [x] Vimæ“ä½œ
- [x] Markdownãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
- [x] æ•°å¼ã‚µãƒãƒ¼ãƒˆ
- [x] Mermaidå›³
- [ ] ã•ã‚‰ã«æ©Ÿèƒ½è¿½åŠ äºˆå®š

### GitHub Alerts

> [!NOTE]
> ã“ã‚Œã¯è£œè¶³æƒ…å ±ã§ã™ã€‚

> [!WARNING]
> ã“ã‚Œã¯è­¦å‘Šã§ã™ã€‚

### Qiita Noteè¨˜æ³•

:::note info
ã‚¤ãƒ³ãƒ•ã‚©ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
:::

:::note warn
è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
:::

### çµµæ–‡å­—

:smile: :rocket: :star: :+1:

---

\`?\` ã‚­ãƒ¼ã§ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º
`;
  },
  
  // ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ã‚’è¡¨ç¤º
  showWelcome() {
    this.saveState();
    this.editor.value = this.getWelcomeContent();
    this.fileName.textContent = 'welcome.md';
    this.currentFileName = 'welcome.md';
    this.modified = false;
    this.updateFileStatus();
    this.updateLineNumbers();
    this.updatePreview();
    this.updateToc();
    this.editor.selectionStart = 0;
    this.editor.selectionEnd = 0;
    this.updateCursorPos();
    this.showStatus('ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ã‚’è¡¨ç¤ºã—ã¾ã—ãŸ');
  },
  
  // ãƒã‚¯ãƒ­è¨˜éŒ²
  recordKey(key, e) {
    if (this.recordingMacro && key !== 'q') {
      this.macroBuffer.push({ key, ctrlKey: e?.ctrlKey, shiftKey: e?.shiftKey });
    }
  },
  
  handleKeydown(e) {
    // ãƒ‡ãƒãƒƒã‚°: ã‚­ãƒ¼å…¥åŠ›ã¨ãƒ¢ãƒ¼ãƒ‰çŠ¶æ…‹ã‚’å‡ºåŠ›
    
    // NOVIMãƒ¢ãƒ¼ãƒ‰ã®å ´åˆ - ã‚·ãƒ³ãƒ—ãƒ«ã«å‡¦ç†
    if (this.vimMode !== true) {
      
      // Ctrl+` ã§VIMãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
      if (e.ctrlKey && e.code === 'Backquote') {
        e.preventDefault();
        this.setVimMode(true);
        return;
      }
      
      // Ctrl+ã‚­ãƒ¼ã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
      if (e.ctrlKey) {
        switch (e.key.toLowerCase()) {
          case 's':
            e.preventDefault();
            this.downloadFile(this.currentFileName || 'ç„¡é¡Œ');
            return;
          case 'o':
            e.preventDefault();
            this.openFileDialog(false);
            return;
          case 'a':
            e.preventDefault();
            const filename = prompt('ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:', this.currentFileName || 'ç„¡é¡Œ.md');
            if (filename) {
              this.downloadFile(filename);
            }
            return;
          case 'n':
            e.preventDefault();
            if (this.modified) {
              if (confirm('å¤‰æ›´ãŒä¿å­˜ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚æ–°è¦ä½œæˆã—ã¾ã™ã‹ï¼Ÿ')) {
                this.newFile();
              }
            } else {
              this.newFile();
            }
            return;
        }
        // ãã®ä»–ã®Ctrl+ã‚­ãƒ¼ã¯ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œï¼ˆCtrl+Z, Ctrl+Cç­‰ï¼‰
        return;
      }
      
      // Tabã‚­ãƒ¼
      if (e.key === 'Tab') {
        e.preventDefault();
        this.handleTab(e.shiftKey);
        return;
      }
      
      // Enterã‚­ãƒ¼: ã‚ªãƒ¼ãƒˆã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
      if (e.key === 'Enter') {
        e.preventDefault();
        this.handleAutoIndent();
        return;
      }
      
      // Escapeã‚­ãƒ¼
      if (e.key === 'Escape') {
        if (!this.commandLine.classList.contains('hidden')) {
          this.commandLine.classList.add('hidden');
          this.editor.focus();
        }
        return;
      }
      
      // ãã®ä»–å…¨ã¦ã®ã‚­ãƒ¼ï¼ˆçŸ¢å°ã‚­ãƒ¼å«ã‚€ï¼‰ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’è¨±å¯
      return;
    }
    
    // ä»¥ä¸‹ã¯VIMãƒ¢ãƒ¼ãƒ‰ï¼ˆthis.vimMode === trueï¼‰ã®å‡¦ç†
    
    // Ctrl+` ã§NOVIMãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
    if (e.ctrlKey && e.code === 'Backquote') {
      e.preventDefault();
      this.setVimMode(false);
      return;
    }
    
    // Ctrl+[ ã‚’ESCã¨ã—ã¦æ‰±ã†
    if (e.ctrlKey && e.key === '[') {
      e.preventDefault();
      if (this.mode === 'insert') {
        this.exitInsertMode();
      } else if (this.mode === 'visual') {
        this.setMode('normal');
        this.editor.selectionEnd = this.editor.selectionStart;
      }
      return;
    }
    
    if (this.mode === 'insert') {
      if (e.key === 'Escape') {
        e.preventDefault();
        this.exitInsertMode();
      } else if (e.key === 'Tab') {
        e.preventDefault();
        this.handleTab(e.shiftKey);
      } else if (e.key === 'Enter') {
        e.preventDefault();
        this.handleAutoIndent();
      }
      return;
    }
    
    if (this.mode === 'visual') {
      e.preventDefault();
      this.handleVisualMode(e);
      return;
    }
    
    e.preventDefault();
    this.handleNormalMode(e);
  },
  
  // ã‚¿ãƒ–ã‚­ãƒ¼å‡¦ç†ï¼ˆã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ/ã‚¢ãƒ³ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆï¼‰
  handleTab(isShift) {
    const text = this.editor.value;
    const start = this.editor.selectionStart;
    const end = this.editor.selectionEnd;
    const tabChar = '  '; // 2ã‚¹ãƒšãƒ¼ã‚¹ã‚’ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã¨ã—ã¦ä½¿ç”¨
    
    // é¸æŠç¯„å›²ãŒãªã„å ´åˆ
    if (start === end) {
      const lineStart = text.lastIndexOf('\n', start - 1) + 1;
      let lineEnd = text.indexOf('\n', start);
      if (lineEnd === -1) lineEnd = text.length;
      const line = text.substring(lineStart, lineEnd);
      
      // ãƒªã‚¹ãƒˆè¡Œã®åˆ¤å®šï¼ˆç®‡æ¡æ›¸ãã€ç•ªå·ãƒªã‚¹ãƒˆã€ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆï¼‰
      const isListLine = /^(\s*)([-*+]|\d+\.)\s/.test(line);
      
      if (isShift) {
        // Shift+Tab: è¡Œé ­ã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™
        if (line.startsWith(tabChar)) {
          this.editor.value = text.substring(0, lineStart) + text.substring(lineStart + tabChar.length);
          this.editor.selectionStart = this.editor.selectionEnd = Math.max(lineStart, start - tabChar.length);
        } else if (line.startsWith('\t')) {
          this.editor.value = text.substring(0, lineStart) + text.substring(lineStart + 1);
          this.editor.selectionStart = this.editor.selectionEnd = Math.max(lineStart, start - 1);
        }
      } else if (isListLine) {
        // Tab on list line: è¡Œé ­ã«ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆè¿½åŠ 
        this.editor.value = text.substring(0, lineStart) + tabChar + text.substring(lineStart);
        this.editor.selectionStart = this.editor.selectionEnd = start + tabChar.length;
      } else {
        // Tab on non-list line: ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«ã‚¿ãƒ–æŒ¿å…¥
        this.editor.value = text.substring(0, start) + tabChar + text.substring(end);
        this.editor.selectionStart = this.editor.selectionEnd = start + tabChar.length;
      }
    } else {
      // é¸æŠç¯„å›²ãŒã‚ã‚‹å ´åˆ: è¤‡æ•°è¡Œã‚’ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ/ã‚¢ãƒ³ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
      const lineStart = text.lastIndexOf('\n', start - 1) + 1;
      const lineEnd = text.indexOf('\n', end);
      const actualEnd = lineEnd === -1 ? text.length : lineEnd;
      const selectedLines = text.substring(lineStart, actualEnd);
      const lines = selectedLines.split('\n');
      
      let newLines;
      if (isShift) {
        // ã‚¢ãƒ³ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
        newLines = lines.map(line => {
          if (line.startsWith(tabChar)) {
            return line.substring(tabChar.length);
          } else if (line.startsWith('\t')) {
            return line.substring(1);
          }
          return line;
        });
      } else {
        // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
        newLines = lines.map(line => tabChar + line);
      }
      
      const newText = newLines.join('\n');
      this.editor.value = text.substring(0, lineStart) + newText + text.substring(actualEnd);
      
      // é¸æŠç¯„å›²ã‚’ç¶­æŒ
      this.editor.selectionStart = lineStart;
      this.editor.selectionEnd = lineStart + newText.length;
    }
    
    this.modified = true;
    this.updateFileStatus();
    this.onInput();
  },
  
  // ã‚ªãƒ¼ãƒˆã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆå‡¦ç†ï¼ˆEnteræŠ¼ä¸‹æ™‚ï¼‰
  handleAutoIndent() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    // ç¾åœ¨è¡Œã®é–‹å§‹ä½ç½®ã‚’å–å¾—
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    const currentLine = text.substring(lineStart, pos);
    
    // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆï¼ˆå…ˆé ­ã®ã‚¹ãƒšãƒ¼ã‚¹/ã‚¿ãƒ–ï¼‰ã‚’å–å¾—
    const indentMatch = currentLine.match(/^(\s*)/);
    const indent = indentMatch ? indentMatch[1] : '';
    
    // ãƒªã‚¹ãƒˆãƒãƒ¼ã‚«ãƒ¼ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
    const listPatterns = [
      // ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ: - [ ] ã‚„ - [x]
      { regex: /^(\s*)([-*+])\s+\[([ xX])\]\s*(.*)$/, type: 'task' },
      // ç•ªå·ä»˜ããƒªã‚¹ãƒˆ: 1. 2. ãªã©
      { regex: /^(\s*)(\d+)\.\s+(.*)$/, type: 'ordered' },
      // ç®‡æ¡æ›¸ã: - * +
      { regex: /^(\s*)([-*+])\s+(.*)$/, type: 'unordered' },
      // å¼•ç”¨: >
      { regex: /^(\s*)(>+)\s*(.*)$/, type: 'quote' }
    ];
    
    let newLineContent = '\n' + indent;
    let shouldClearLine = false;
    
    for (const pattern of listPatterns) {
      const match = currentLine.match(pattern.regex);
      if (match) {
        if (pattern.type === 'task') {
          const [, lineIndent, marker, , content] = match;
          if (content.trim() === '') {
            // ç©ºã®ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ â†’ ãƒªã‚¹ãƒˆã‚’çµ‚äº†
            shouldClearLine = true;
          } else {
            newLineContent = '\n' + lineIndent + marker + ' [ ] ';
          }
        } else if (pattern.type === 'ordered') {
          const [, lineIndent, num, content] = match;
          if (content.trim() === '') {
            // ç©ºã®ç•ªå·ãƒªã‚¹ãƒˆ â†’ ãƒªã‚¹ãƒˆã‚’çµ‚äº†
            shouldClearLine = true;
          } else {
            const nextNum = parseInt(num) + 1;
            newLineContent = '\n' + lineIndent + nextNum + '. ';
          }
        } else if (pattern.type === 'unordered') {
          const [, lineIndent, marker, content] = match;
          if (content.trim() === '') {
            // ç©ºã®ç®‡æ¡æ›¸ã â†’ ãƒªã‚¹ãƒˆã‚’çµ‚äº†
            shouldClearLine = true;
          } else {
            newLineContent = '\n' + lineIndent + marker + ' ';
          }
        } else if (pattern.type === 'quote') {
          const [, lineIndent, markers, content] = match;
          if (content.trim() === '') {
            // ç©ºã®å¼•ç”¨ â†’ å¼•ç”¨ã‚’çµ‚äº†
            shouldClearLine = true;
          } else {
            newLineContent = '\n' + lineIndent + markers + ' ';
          }
        }
        break;
      }
    }
    
    if (shouldClearLine) {
      // ç©ºã®ãƒªã‚¹ãƒˆ/å¼•ç”¨è¡Œã‚’å‰Šé™¤ã—ã¦æ–°ã—ã„è¡Œã‚’è¿½åŠ 
      this.editor.value = text.substring(0, lineStart) + '\n' + text.substring(pos);
      this.editor.selectionStart = this.editor.selectionEnd = lineStart + 1;
    } else {
      // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆï¼ˆã¨ãƒªã‚¹ãƒˆãƒãƒ¼ã‚«ãƒ¼ï¼‰ã‚’è¿½åŠ ã—ã¦æ–°ã—ã„è¡Œ
      this.editor.value = text.substring(0, pos) + newLineContent + text.substring(pos);
      this.editor.selectionStart = this.editor.selectionEnd = pos + newLineContent.length;
    }
    
    this.modified = true;
    this.updateFileStatus();
    this.onInput();
    this.scrollToCursor();
  },

  exitInsertMode() {
    // æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰çµ‚äº†æ™‚ã®å‡¦ç†
    if (this.lastEdit && this.lastEdit.type === 'insert') {
      this.lastEdit.insertedText = this.lastEditText;
    }
    this.lastEditText = '';
    
    this.setMode('normal');
    if (this.editor.selectionStart > 0) {
      this.editor.selectionStart--;
      this.editor.selectionEnd = this.editor.selectionStart;
    }
  },
  
  handleNormalMode(e) {
    const key = e.key;
    
    this.recordKey(key, e);
    
    // æ•°å€¤ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹
    if (/^[1-9]$/.test(key) || (this.count && /^[0-9]$/.test(key))) {
      this.count += key;
      return;
    }
    
    const count = parseInt(this.count) || 1;
    this.count = '';
    
    // ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼å¾…ã¡çŠ¶æ…‹ï¼ˆd, c, y ã®å¾Œï¼‰
    if (this.pendingOperator) {
      this.handleOperatorPending(key, count, e);
      return;
    }
    
    // ä¿ç•™ä¸­ã®ã‚­ãƒ¼
    if (this.pendingKey) {
      this.handlePendingKey(key, count);
      return;
    }
    
    // Ctrlçµ„ã¿åˆã‚ã›
    if (e.ctrlKey) {
      switch(key) {
        case 'r': this.redo(); return;
        case 'd': this.scrollHalfPage(1); return;
        case 'u': this.scrollHalfPage(-1); return;
        case 'f': this.scrollFullPage(1); return;
        case 'b': this.scrollFullPage(-1); return;
      }
    }
    
    switch(key) {
      // ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
      case 'i': 
        this.setLastEdit('insert', this.editor.selectionStart);
        this.setMode('insert'); 
        break;
      case 'I': 
        this.moveToFirstNonSpace(); 
        this.setLastEdit('insert', this.editor.selectionStart);
        this.setMode('insert'); 
        break;
      case 'a': 
        if (this.editor.selectionStart < this.editor.value.length) {
          this.editor.selectionStart++;
          this.editor.selectionEnd = this.editor.selectionStart;
        }
        this.setLastEdit('insert', this.editor.selectionStart);
        this.setMode('insert'); 
        break;
      case 'A': 
        this.moveToLineEnd(); 
        this.setLastEdit('insert', this.editor.selectionStart);
        this.setMode('insert'); 
        break;
      case 'o': 
        this.saveState();
        this.moveToLineEnd(); 
        this.insertText('\n'); 
        this.setLastEdit('o');
        this.setMode('insert'); 
        break;
      case 'O': 
        this.saveState();
        this.moveToLineStart(); 
        this.insertText('\n'); 
        this.moveCursor(-1); 
        this.setLastEdit('O');
        this.setMode('insert'); 
        break;
      case 's':
        this.saveState();
        this.deleteChar();
        this.setLastEdit('s');
        this.setMode('insert');
        break;
      case 'S':
        this.saveState();
        this.deleteLineContent();
        this.setLastEdit('S');
        this.setMode('insert');
        break;
      case 'v': 
        this.setMode('visual'); 
        this.visualStart = this.editor.selectionStart; 
        this.visualLine = false; 
        break;
      case 'V': 
        this.visualCursor = this.editor.selectionStart;  // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’ä¿å­˜
        // é–‹å§‹è¡Œç•ªå·ã‚’è¨ˆç®—
        const textBeforeCursor = this.editor.value.substring(0, this.editor.selectionStart);
        this.visualStartLine = textBeforeCursor.split('\n').length - 1;
        this.setMode('visual'); 
        this.selectCurrentLine(); 
        this.visualLine = true; 
        break;
      case ':': 
        this.setMode('command'); 
        this.commandPrefix.textContent = ':'; 
        break;
      case '/': 
        this.setMode('command'); 
        this.commandPrefix.textContent = '/'; 
        break;
      case '?': 
        toggleHelp(); 
        break;
      
      // ç§»å‹•
      case 'h': case 'ArrowLeft': this.moveCursor(-count); break;
      case 'l': case 'ArrowRight': this.moveCursor(count); break;
      case 'j': case 'ArrowDown': for (let i = 0; i < count; i++) this.moveVertical(1); break;
      case 'k': case 'ArrowUp': for (let i = 0; i < count; i++) this.moveVertical(-1); break;
      case 'w': for (let i = 0; i < count; i++) this.moveWord(1); break;
      case 'b': for (let i = 0; i < count; i++) this.moveWord(-1); break;
      case 'e': for (let i = 0; i < count; i++) this.moveWordEnd(); break;
      case '0': this.moveToLineStart(); break;
      case '$': this.moveToLineEnd(); break;
      case '^': this.moveToFirstNonSpace(); break;
      case 'g': this.pendingKey = 'g'; break;
      case 'G': if (count > 1) this.gotoLine(count); else this.moveToEnd(); break;
      case 'z': this.pendingKey = 'z'; break;
      
      // è¡Œå†…æ¤œç´¢ (f/F/t/T)
      case 'f': this.pendingKey = 'f'; break;
      case 'F': this.pendingKey = 'F'; break;
      case 't': this.pendingKey = 't'; break;
      case 'T': this.pendingKey = 'T'; break;
      case ';': this.repeatFindChar(1); break;
      case ',': this.repeatFindChar(-1); break;
      
      // æ‹¬å¼§ã‚¸ãƒ£ãƒ³ãƒ—
      case '%': this.jumpToMatchingBracket(); break;
      
      // ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ç§»å‹•
      case '{': for (let i = 0; i < count; i++) this.moveParagraph(-1); break;
      case '}': for (let i = 0; i < count; i++) this.moveParagraph(1); break;
      
      // ãƒãƒ¼ã‚¯
      case 'm': this.pendingKey = 'm'; break;
      case "'": this.pendingKey = "'"; break;
      case '`': this.pendingKey = '`'; break;
      
      // ãƒã‚¯ãƒ­
      case 'q':
        if (this.recordingMacro) {
          this.stopRecordingMacro();
        } else {
          this.pendingKey = 'q_start';
        }
        break;
      case '@': this.pendingKey = '@'; break;
      
      // ç·¨é›†
      case 'x': 
        this.saveState(); 
        for (let i = 0; i < count; i++) this.deleteChar(); 
        this.setLastEdit('x', null, count);
        break;
      case 'X': 
        this.saveState(); 
        for (let i = 0; i < count; i++) this.deleteCharBefore(); 
        this.setLastEdit('X', null, count);
        break;
      case 'd': this.pendingOperator = 'd'; break;
      case 'D': 
        this.saveState(); 
        this.deleteToLineEnd(); 
        this.setLastEdit('D');
        break;
      case 'c': this.pendingOperator = 'c'; break;
      case 'C': 
        this.saveState(); 
        this.deleteToLineEnd(); 
        this.setLastEdit('C');
        this.setMode('insert'); 
        break;
      case 'y': this.pendingOperator = 'y'; break;
      case 'Y': this.yankLine(); break;
      case 'p': this.saveState(); this.paste(); break;
      case 'P': this.saveState(); this.pasteBefore(); break;
      case 'u': this.undo(); break;
      case 'J': this.saveState(); this.joinLines(); this.setLastEdit('J'); break;
      case 'r': this.pendingKey = 'r'; break;
      
      // ãƒ‰ãƒƒãƒˆãƒªãƒ”ãƒ¼ãƒˆ
      case '.': this.repeatLastEdit(count); break;
      
      // å¤§æ–‡å­—/å°æ–‡å­—åˆ‡æ›¿
      case '~': 
        this.saveState(); 
        for (let i = 0; i < count; i++) this.toggleCase(); 
        this.setLastEdit('~', null, count);
        break;
      
      // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
      case '>': this.pendingKey = '>'; break;
      case '<': this.pendingKey = '<'; break;
      
      // æ¤œç´¢
      case 'n': this.findNext(); break;
      case 'N': this.findPrev(); break;
      case '*': this.searchWordUnderCursor(); break;
    }
    
    this.updateCursorPos();
  },
  
  // ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼å¾…ã¡çŠ¶æ…‹ã®å‡¦ç† (d, c, y ã®å¾Œ)
  handleOperatorPending(key, count, e) {
    const op = this.pendingOperator;
    this.pendingOperator = '';
    
    // ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (i/a)
    if (key === 'i' || key === 'a') {
      this.pendingKey = op + key;  // ä¾‹: 'di', 'ca'
      return;
    }
    
    // ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã®é‡è¤‡ (dd, cc, yy)
    if (key === op) {
      this.saveState();
      if (op === 'd') {
        for (let i = 0; i < count; i++) this.deleteLine();
        this.setLastEdit('dd', null, count);
      } else if (op === 'c') {
        this.deleteLineContent();
        this.setLastEdit('cc', null, count);
        this.setMode('insert');
      } else if (op === 'y') {
        this.yankLine();
      }
      return;
    }
    
    // ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³
    this.saveState();
    const startPos = this.editor.selectionStart;
    
    switch(key) {
      case 'w':
        for (let i = 0; i < count; i++) this.moveWord(1);
        break;
      case 'b':
        for (let i = 0; i < count; i++) this.moveWord(-1);
        break;
      case 'e':
        for (let i = 0; i < count; i++) this.moveWordEnd();
        this.editor.selectionStart++;
        this.editor.selectionEnd++;
        break;
      case '$':
        this.moveToLineEnd();
        break;
      case '0':
        this.moveToLineStart();
        break;
      case '^':
        this.moveToFirstNonSpace();
        break;
      case 'G':
        this.moveToEnd();
        break;
      case '{':
        this.moveParagraph(-1);
        break;
      case '}':
        this.moveParagraph(1);
        break;
      case 'g':
        this.pendingKey = op + 'g';
        return;
      default:
        return;
    }
    
    const endPos = this.editor.selectionStart;
    const start = Math.min(startPos, endPos);
    const end = Math.max(startPos, endPos);
    
    this.applyOperator(op, start, end, key, count);
    this.updateCursorPos();
  },
  
  applyOperator(op, start, end, motion, count) {
    const text = this.editor.value.substring(start, end);
    
    if (op === 'y') {
      this.setRegister(text);
      this.editor.selectionStart = start;
      this.editor.selectionEnd = start;
      this.showStatus('ãƒ¤ãƒ³ã‚¯ã—ã¾ã—ãŸ');
    } else if (op === 'd') {
      this.register = text;
      this.editor.value = this.editor.value.substring(0, start) + this.editor.value.substring(end);
      this.editor.selectionStart = start;
      this.editor.selectionEnd = start;
      this.setLastEdit('d' + motion, null, count);
      this.onInput();
    } else if (op === 'c') {
      this.register = text;
      this.editor.value = this.editor.value.substring(0, start) + this.editor.value.substring(end);
      this.editor.selectionStart = start;
      this.editor.selectionEnd = start;
      this.setLastEdit('c' + motion, null, count);
      this.setMode('insert');
      this.onInput();
    }
  },
  
  handlePendingKey(key, count) {
    const pending = this.pendingKey;
    this.pendingKey = '';
    
    switch(pending) {
      case 'g':
        if (key === 'g') this.moveToStart();
        break;
      
      case 'z':
        // z Enter, zt - ã‚«ãƒ¼ã‚½ãƒ«è¡Œã‚’ç”»é¢ä¸Šéƒ¨ã«
        if (key === 'Enter' || key === 't') {
          this.scrollCursorToTop();
        }
        // z. zz - ã‚«ãƒ¼ã‚½ãƒ«è¡Œã‚’ç”»é¢ä¸­å¤®ã«
        else if (key === '.' || key === 'z') {
          this.scrollCursorToCenter();
        }
        // z- zb - ã‚«ãƒ¼ã‚½ãƒ«è¡Œã‚’ç”»é¢ä¸‹éƒ¨ã«
        else if (key === '-' || key === 'b') {
          this.scrollCursorToBottom();
        }
        break;
        
      case 'd':
        this.saveState();
        if (key === 'd') { for (let i = 0; i < count; i++) this.deleteLine(); this.setLastEdit('dd', null, count); }
        else if (key === 'w') { this.deleteWord(); this.setLastEdit('dw'); }
        else if (key === '$') { this.deleteToLineEnd(); this.setLastEdit('d$'); }
        else if (key === '0') { this.deleteToLineStart(); this.setLastEdit('d0'); }
        break;
        
      case 'y':
        if (key === 'y') this.yankLine();
        else if (key === 'w') this.yankWord();
        break;
        
      case 'c':
        this.saveState();
        if (key === 'c') { this.deleteLineContent(); this.setLastEdit('cc'); this.setMode('insert'); }
        else if (key === 'w') { this.deleteWord(); this.setLastEdit('cw'); this.setMode('insert'); }
        break;
        
      case 'r':
        if (key.length === 1) {
          this.saveState();
          this.replaceChar(key);
          this.setLastEdit('r', key);
        }
        break;
        
      // è¡Œå†…æ¤œç´¢
      case 'f':
        if (key.length === 1) {
          this.findCharInLine(key, 1, false);
          this.lastFindChar = key;
          this.lastFindDirection = 1;
          this.lastFindType = 'f';
        }
        break;
      case 'F':
        if (key.length === 1) {
          this.findCharInLine(key, -1, false);
          this.lastFindChar = key;
          this.lastFindDirection = -1;
          this.lastFindType = 'f';
        }
        break;
      case 't':
        if (key.length === 1) {
          this.findCharInLine(key, 1, true);
          this.lastFindChar = key;
          this.lastFindDirection = 1;
          this.lastFindType = 't';
        }
        break;
      case 'T':
        if (key.length === 1) {
          this.findCharInLine(key, -1, true);
          this.lastFindChar = key;
          this.lastFindDirection = -1;
          this.lastFindType = 't';
        }
        break;
        
      // ãƒãƒ¼ã‚¯
      case 'm':
        if (/^[a-z]$/.test(key)) {
          this.marks[key] = this.editor.selectionStart;
          this.showStatus(`ãƒãƒ¼ã‚¯ '${key}' ã‚’è¨­å®š`);
        }
        break;
      case "'":
        if (key === "'") {
          // '' ã§ç›´å‰ä½ç½®ã¸
          if (this.previousPosition !== null) {
            const current = this.editor.selectionStart;
            this.gotoPosition(this.previousPosition);
            this.previousPosition = current;
            this.moveToFirstNonSpace();
          }
        } else if (/^[a-z]$/.test(key) && this.marks[key] !== undefined) {
          this.previousPosition = this.editor.selectionStart;
          this.gotoPosition(this.marks[key]);
          this.moveToFirstNonSpace();
        }
        break;
      case '`':
        if (/^[a-z]$/.test(key) && this.marks[key] !== undefined) {
          this.previousPosition = this.editor.selectionStart;
          this.gotoPosition(this.marks[key]);
        }
        break;
        
      // ãƒã‚¯ãƒ­
      case 'q_start':
        if (/^[a-z]$/.test(key)) {
          this.startRecordingMacro(key);
        }
        break;
      case '@':
        if (key === '@' && this.lastMacro) {
          this.playMacro(this.lastMacro);
        } else if (/^[a-z]$/.test(key) && this.macros[key]) {
          this.playMacro(key);
        }
        break;
        
      // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
      case '>':
        if (key === '>') {
          this.saveState();
          for (let i = 0; i < count; i++) this.indentLine(1);
          this.setLastEdit('>>', null, count);
        }
        break;
      case '<':
        if (key === '<') {
          this.saveState();
          for (let i = 0; i < count; i++) this.indentLine(-1);
          this.setLastEdit('<<', null, count);
        }
        break;
        
      // ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (di, da, ci, ca, yi, ya)
      case 'di': case 'da': case 'ci': case 'ca': case 'yi': case 'ya':
        this.handleTextObject(pending, key);
        break;
        
      // dg, cg, yg
      case 'dg':
        if (key === 'g') {
          this.saveState();
          const pos = this.editor.selectionStart;
          this.register = this.editor.value.substring(0, pos);
          this.editor.value = this.editor.value.substring(pos);
          this.editor.selectionStart = 0;
          this.editor.selectionEnd = 0;
          this.onInput();
        }
        break;
    }
    
    this.updateCursorPos();
  },
  
  // ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‡¦ç†
  handleTextObject(opType, objChar) {
    const op = opType[0];  // 'd', 'c', 'y'
    const inner = opType[1] === 'i';  // true: inner, false: around
    
    let range = null;
    
    switch(objChar) {
      case 'w':
        range = this.getWordRange(inner);
        break;
      case '"':
      case "'":
      case '`':
        range = this.getQuoteRange(objChar, inner);
        break;
      case '(':
      case ')':
      case 'b':
        range = this.getBracketRange('(', ')', inner);
        break;
      case '[':
      case ']':
        range = this.getBracketRange('[', ']', inner);
        break;
      case '{':
      case '}':
      case 'B':
        range = this.getBracketRange('{', '}', inner);
        break;
      case '<':
      case '>':
        range = this.getBracketRange('<', '>', inner);
        break;
    }
    
    if (range) {
      this.saveState();
      const text = this.editor.value.substring(range.start, range.end);
      
      if (op === 'y') {
        this.setRegister(text);
        this.showStatus('ãƒ¤ãƒ³ã‚¯ã—ã¾ã—ãŸ');
      } else {
        this.register = text;
        this.editor.value = this.editor.value.substring(0, range.start) + this.editor.value.substring(range.end);
        this.editor.selectionStart = range.start;
        this.editor.selectionEnd = range.start;
        this.setLastEdit(opType + objChar);
        
        if (op === 'c') {
          this.setMode('insert');
        }
        this.onInput();
      }
    }
  },
  
  getWordRange(inner) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    let start = pos;
    let end = pos;
    
    // å˜èªã®å¢ƒç•Œã‚’è¦‹ã¤ã‘ã‚‹
    while (start > 0 && /\w/.test(text[start - 1])) start--;
    while (end < text.length && /\w/.test(text[end])) end++;
    
    if (!inner) {
      // around: å¾Œç¶šã®ç©ºç™½ã‚‚å«ã‚ã‚‹
      while (end < text.length && /\s/.test(text[end]) && text[end] !== '\n') end++;
    }
    
    if (start === end) return null;
    return { start, end };
  },
  
  getQuoteRange(quote, inner) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    // ç¾åœ¨è¡Œã‚’å–å¾—
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    const line = text.substring(lineStart, lineEnd);
    const colPos = pos - lineStart;
    
    // å¼•ç”¨ç¬¦ã®ãƒšã‚¢ã‚’æ¢ã™
    let start = -1;
    let end = -1;
    let inQuote = false;
    let quoteStart = -1;
    
    for (let i = 0; i < line.length; i++) {
      if (line[i] === quote && (i === 0 || line[i-1] !== '\\')) {
        if (!inQuote) {
          quoteStart = i;
          inQuote = true;
        } else {
          if (colPos >= quoteStart && colPos <= i) {
            start = quoteStart;
            end = i;
            break;
          }
          inQuote = false;
        }
      }
    }
    
    if (start === -1 || end === -1) return null;
    
    if (inner) {
      return { start: lineStart + start + 1, end: lineStart + end };
    } else {
      return { start: lineStart + start, end: lineStart + end + 1 };
    }
  },
  
  getBracketRange(open, close, inner) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    // å¯¾å¿œã™ã‚‹æ‹¬å¼§ã‚’æ¢ã™
    let depth = 0;
    let start = -1;
    let end = -1;
    
    // é–‹ãæ‹¬å¼§ã‚’å¾Œã‚ã«æ¢ã™
    for (let i = pos; i >= 0; i--) {
      if (text[i] === close) depth++;
      else if (text[i] === open) {
        if (depth === 0) {
          start = i;
          break;
        }
        depth--;
      }
    }
    
    if (start === -1) return null;
    
    // é–‰ã˜æ‹¬å¼§ã‚’å‰ã«æ¢ã™
    depth = 0;
    for (let i = start; i < text.length; i++) {
      if (text[i] === open) depth++;
      else if (text[i] === close) {
        depth--;
        if (depth === 0) {
          end = i;
          break;
        }
      }
    }
    
    if (end === -1) return null;
    
    if (inner) {
      return { start: start + 1, end: end };
    } else {
      return { start: start, end: end + 1 };
    }
  },
  
  handleVisualMode(e) {
    const key = e.key;
    
    this.recordKey(key, e);
    
    if (key === 'Escape' || (e.ctrlKey && key === '[')) {
      this.setMode('normal');
      this.editor.selectionEnd = this.editor.selectionStart;
      this.visualCursor = null;
      this.visualStartLine = -1;
      return;
    }
    
    const start = Math.min(this.visualStart, this.editor.selectionStart);
    const end = Math.max(this.visualStart, this.editor.selectionEnd);
    
    // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ‰ã§ã®å®Ÿéš›ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’å–å¾—
    let cursorPos;
    if (this.visualLine && this.visualCursor !== null) {
      // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã§ã¯ä¿å­˜ã—ãŸã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’ä½¿ç”¨
      cursorPos = this.visualCursor;
    } else if (this.editor.selectionStart < this.visualStart) {
      cursorPos = this.editor.selectionStart;
    } else {
      cursorPos = this.editor.selectionEnd;
    }
    
    // ç§»å‹•ç³»ã‚³ãƒãƒ³ãƒ‰ã®å ´åˆã€ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‹ã‚‰ç§»å‹•ã™ã‚‹ãŸã‚ã«ä¸€æ™‚çš„ã«è¨­å®š
    const isMovementKey = ['h', 'l', 'j', 'k', 'w', 'b', '0', '$', 'G', '{', '}', 
                           'ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp'].includes(key);
    if (isMovementKey) {
      this.editor.selectionStart = cursorPos;
      this.editor.selectionEnd = cursorPos;
    }
    
    switch(key) {
      case 'h': case 'ArrowLeft': this.moveCursor(-1); break;
      case 'l': case 'ArrowRight': this.moveCursor(1); break;
      case 'j': case 'ArrowDown': this.moveVertical(1); break;
      case 'k': case 'ArrowUp': this.moveVertical(-1); break;
      case 'w': this.moveWord(1); break;
      case 'b': this.moveWord(-1); break;
      case '0': this.moveToLineStart(); break;
      case '$': this.moveToLineEnd(); break;
      case 'G': this.moveToEnd(); break;
      case 'g': this.pendingKey = 'g'; break;
      case '{': this.moveParagraph(-1); break;
      case '}': this.moveParagraph(1); break;
      
      // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
      case '>':
        this.saveState();
        this.indentSelection(1);
        this.setMode('normal');
        return;
      case '<':
        this.saveState();
        this.indentSelection(-1);
        this.setMode('normal');
        return;
        
      case 'd': case 'x':
        this.saveState();
        this.editor.selectionStart = start;
        this.editor.selectionEnd = end;
        this.register = this.editor.value.substring(start, end);
        this.deleteSelection();
        this.setMode('normal');
        return;
      case 'y':
        this.setRegister(this.editor.value.substring(start, end));
        this.setMode('normal');
        this.editor.selectionEnd = this.editor.selectionStart;
        this.showStatus('ãƒ¤ãƒ³ã‚¯ã—ã¾ã—ãŸ');
        return;
      case 'c':
        this.saveState();
        this.editor.selectionStart = start;
        this.editor.selectionEnd = end;
        this.register = this.editor.value.substring(start, end);
        this.deleteSelection();
        this.setMode('insert');
        return;
      case '~':
        this.saveState();
        this.toggleCaseSelection(start, end);
        this.setMode('normal');
        return;
      case 'U':
        this.saveState();
        this.changeCaseSelection(start, end, 'upper');
        this.setMode('normal');
        return;
      case 'u':
        this.saveState();
        this.changeCaseSelection(start, end, 'lower');
        this.setMode('normal');
        return;
    }
    
    // é¸æŠç¯„å›²ã®æ›´æ–°
    if (this.mode === 'visual') {
      const newCurPos = this.editor.selectionStart;
      if (this.visualLine) {
        // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰: è¡Œç•ªå·ãƒ™ãƒ¼ã‚¹ã§é¸æŠç¯„å›²ã‚’è¨ˆç®—
        this.visualCursor = newCurPos;
        const text = this.editor.value;
        const allLines = text.split('\n');
        
        // ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«è¡Œã‚’è¨ˆç®—
        const textBeforeCursor = text.substring(0, newCurPos);
        const currentLine = textBeforeCursor.split('\n').length - 1;
        
        // é–‹å§‹è¡Œã¨çµ‚äº†è¡Œã‚’æ±ºå®š
        const fromLine = Math.min(this.visualStartLine, currentLine);
        const toLine = Math.max(this.visualStartLine, currentLine);
        
        // è¡Œã®é–‹å§‹ãƒ»çµ‚äº†ä½ç½®ã‚’è¨ˆç®—
        let startPos = 0;
        for (let i = 0; i < fromLine; i++) {
          startPos += allLines[i].length + 1;
        }
        let endPos = startPos;
        for (let i = fromLine; i <= toLine; i++) {
          endPos += allLines[i].length + 1;
        }
        // æœ€å¾Œã®è¡Œã«æ”¹è¡ŒãŒãªã„å ´åˆã®èª¿æ•´
        if (endPos > text.length) endPos = text.length;
        
        this.editor.selectionStart = startPos;
        this.editor.selectionEnd = endPos;
      } else {
        this.editor.selectionStart = Math.min(this.visualStart, newCurPos);
        this.editor.selectionEnd = Math.max(this.visualStart, newCurPos);
      }
    }
    
    this.updateCursorPos();
  },
  
  handleCommandKey(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      const cmd = this.commandInput.value;
      const prefix = this.commandPrefix.textContent;
      this.commandInput.value = '';
      this.setMode('normal');
      
      if (prefix === ':') this.executeCommand(cmd);
      else if (prefix === '/') this.search(cmd);
    } else if (e.key === 'Escape' || (e.ctrlKey && e.key === '[')) {
      e.preventDefault();
      this.commandInput.value = '';
      this.setMode('normal');
    }
  },
  
  executeCommand(cmd) {
    // ç½®æ›ã‚³ãƒãƒ³ãƒ‰ã®ãƒ‘ãƒ¼ã‚¹
    const substituteMatch = cmd.match(/^(%)?s\/(.+?)\/(.*)\/([gic]*)$/);
    if (substituteMatch) {
      this.substitute(substituteMatch);
      return;
    }
    
    // ç¯„å›²æŒ‡å®šç½®æ›
    const rangeSubMatch = cmd.match(/^(\d+),(\d+)s\/(.+?)\/(.*)\/([gic]*)$/);
    if (rangeSubMatch) {
      this.substituteRange(rangeSubMatch);
      return;
    }
    
    const parts = cmd.trim().split(/\s+/);
    const command = parts[0];
    
    switch(command) {
      case 'w':
        if (parts[1]) {
          // ãƒ•ã‚¡ã‚¤ãƒ«åæŒ‡å®šã‚ã‚Š â†’ ç›´æ¥ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
          this.downloadFile(parts[1]);
        } else {
          // ãƒ•ã‚¡ã‚¤ãƒ«åãªã— â†’ ä¸Šæ›¸ãä¿å­˜ï¼ˆãƒãƒ³ãƒ‰ãƒ«ãŒãªã‘ã‚Œã°ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ï¼‰
          this.saveToCurrentFile();
        }
        break;
      case 'q':
        if (this.modified) {
          this.showStatus('ä¿å­˜ã•ã‚Œã¦ã„ãªã„å¤‰æ›´ãŒã‚ã‚Šã¾ã™ï¼ :q! ã§å¼·åˆ¶çµ‚äº†');
        } else {
          this.showStatus('çµ‚äº†ã™ã‚‹ã«ã¯ãƒ–ãƒ©ã‚¦ã‚¶ã‚’é–‰ã˜ã¦ãã ã•ã„');
        }
        break;
      case 'q!':
        this.showStatus('çµ‚äº†ã™ã‚‹ã«ã¯ãƒ–ãƒ©ã‚¦ã‚¶ã‚’é–‰ã˜ã¦ãã ã•ã„');
        break;
      case 'wq': case 'x':
        this.saveWithDialog();
        break;
      case 'e': case 'edit': case 'open':
        if (parts[1]) {
          // ãƒ•ã‚¡ã‚¤ãƒ«åæŒ‡å®š â†’ æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦æ‰±ã†
          if (this.modified) {
            this.showStatus('ä¿å­˜ã•ã‚Œã¦ã„ãªã„å¤‰æ›´ãŒã‚ã‚Šã¾ã™ï¼ :e! ã§å¼·åˆ¶');
          } else {
            this.editor.value = '';
            this.fileName.textContent = parts[1];
            this.currentFileName = parts[1];
            this.modified = false;
            this.updateFileStatus();
            this.onInput();
          }
        } else {
          // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã
          this.openWithDialog();
        }
        break;
      case 'e!':
        // å¼·åˆ¶çš„ã«æ–°è¦/é–‹ã
        if (parts[1]) {
          this.editor.value = '';
          this.fileName.textContent = parts[1];
          this.currentFileName = parts[1];
          this.modified = false;
          this.updateFileStatus();
          this.onInput();
        } else {
          this.openWithDialog();
        }
        break;
      case 'saveas': case 'sav':
        if (parts[1]) {
          this.downloadFile(parts[1]);
        } else {
          this.saveWithDialog();
        }
        break;
      case 'read': case 'r':
        // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ¿å…¥
        this.openFileDialog(true);
        break;
      case 'new':
        // æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«
        if (this.modified) {
          this.showStatus('ä¿å­˜ã•ã‚Œã¦ã„ãªã„å¤‰æ›´ãŒã‚ã‚Šã¾ã™ï¼');
        } else {
          this.newFile();
        }
        break;
      case 'new!':
        this.newFile();
        break;
      case 'welcome':
        // ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ã‚’è¡¨ç¤º
        this.showWelcome();
        break;
      case 'set':
        if (parts[1] === 'nu' || parts[1] === 'number') {
          this.lineNumbers.style.display = 'block';
        } else if (parts[1] === 'nonu' || parts[1] === 'nonumber') {
          this.lineNumbers.style.display = 'none';
        } else if (parts[1] === 'vim') {
          this.setVimMode(true);
        } else if (parts[1] === 'novim') {
          this.setVimMode(false);
        } else if (parts[1] && parts[1].startsWith('theme=')) {
          const theme = parts[1].split('=')[1];
          if (['dark', 'light', 'original'].includes(theme)) {
            setTheme(theme);
          } else {
            this.showStatus('ç„¡åŠ¹ãªãƒ†ãƒ¼ãƒ: dark, light, original ã‹ã‚‰é¸æŠ');
          }
        } else if (parts[1] === 'theme') {
          const current = document.documentElement.getAttribute('data-theme') || 'dark';
          this.showStatus(`ç¾åœ¨ã®ãƒ†ãƒ¼ãƒ: ${current}`);
        } else if (parts[1] && parts[1].startsWith('autosave=')) {
          const value = parts[1].split('=')[1];
          if (['off', '1s', '5s', '10s', '30s', '60s'].includes(value)) {
            this.autoSaveInterval = value;
            localStorage.setItem('vim-md-autosave', value);
            if (value === 'off') {
              this.showStatus('è‡ªå‹•ä¿å­˜: ç„¡åŠ¹');
            } else {
              this.showStatus(`è‡ªå‹•ä¿å­˜: ${value}é–“éš”`);
            }
          } else {
            this.showStatus('ç„¡åŠ¹ãªå€¤: off, 1s, 5s, 10s, 30s, 60s ã‹ã‚‰é¸æŠ');
          }
        } else if (parts[1] === 'autosave') {
          if (this.autoSaveInterval === 'off') {
            this.showStatus('è‡ªå‹•ä¿å­˜: ç„¡åŠ¹');
          } else {
            this.showStatus(`è‡ªå‹•ä¿å­˜: ${this.autoSaveInterval}é–“éš”`);
          }
        }
        break;
      case 'theme':
        if (parts[1] && ['dark', 'light', 'original'].includes(parts[1])) {
          setTheme(parts[1]);
        } else {
          this.showStatus('ä½¿ç”¨æ³•: :theme dark|light|original');
        }
        break;
      case 'dark':
        setTheme('dark');
        break;
      case 'light':
        setTheme('light');
        break;
      case 'original':
        setTheme('original');
        break;
      case 'marks':
        this.showMarks();
        break;
      case 'help': case 'h':
        toggleHelp();
        break;
      case 'ls':
        this.save();
        this.showStatus('ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ã—ã¾ã—ãŸ');
        break;
      default:
        const lineNum = parseInt(command);
        if (!isNaN(lineNum)) {
          this.gotoLine(lineNum);
        } else {
          this.showStatus('ä¸æ˜ãªã‚³ãƒãƒ³ãƒ‰: ' + command);
        }
    }
  },
  
  // ç½®æ›ã‚³ãƒãƒ³ãƒ‰
  substitute(match) {
    const [, global, pattern, replacement, flags] = match;
    const isGlobal = flags.includes('g');
    
    this.saveState();
    
    if (global === '%') {
      // å…¨ç½®æ›
      const regex = new RegExp(pattern, isGlobal ? 'g' : '');
      const oldValue = this.editor.value;
      this.editor.value = oldValue.replace(regex, replacement);
      const count = (oldValue.match(new RegExp(pattern, 'g')) || []).length;
      this.showStatus(`${count} ä»¶ç½®æ›ã—ã¾ã—ãŸ`);
    } else {
      // ç¾åœ¨è¡Œã®ã¿
      const text = this.editor.value;
      const pos = this.editor.selectionStart;
      const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
      let lineEnd = text.indexOf('\n', pos);
      if (lineEnd === -1) lineEnd = text.length;
      
      const line = text.substring(lineStart, lineEnd);
      const regex = new RegExp(pattern, isGlobal ? 'g' : '');
      const newLine = line.replace(regex, replacement);
      
      this.editor.value = text.substring(0, lineStart) + newLine + text.substring(lineEnd);
      this.showStatus('ç½®æ›ã—ã¾ã—ãŸ');
    }
    
    this.onInput();
  },
  
  substituteRange(match) {
    const [, startLine, endLine, pattern, replacement, flags] = match;
    const isGlobal = flags.includes('g');
    const start = parseInt(startLine);
    const end = parseInt(endLine);
    
    this.saveState();
    
    const lines = this.editor.value.split('\n');
    const regex = new RegExp(pattern, isGlobal ? 'g' : '');
    let count = 0;
    
    for (let i = start - 1; i < end && i < lines.length; i++) {
      const matches = lines[i].match(new RegExp(pattern, 'g'));
      if (matches) count += matches.length;
      lines[i] = lines[i].replace(regex, replacement);
    }
    
    this.editor.value = lines.join('\n');
    this.showStatus(`${count} ä»¶ç½®æ›ã—ã¾ã—ãŸ`);
    this.onInput();
  },
  
  showMarks() {
    const markList = Object.entries(this.marks)
      .map(([k, v]) => `'${k}: ${v}`)
      .join(', ');
    this.showStatus(markList || 'ãƒãƒ¼ã‚¯ãªã—');
  },
  
  // è¡Œå†…æ¤œç´¢
  findCharInLine(char, direction, beforeChar) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    
    let newPos = -1;
    
    if (direction > 0) {
      // å‰æ–¹æ¤œç´¢
      for (let i = pos + 1; i < lineEnd; i++) {
        if (text[i] === char) {
          newPos = beforeChar ? i - 1 : i;
          break;
        }
      }
    } else {
      // å¾Œæ–¹æ¤œç´¢
      for (let i = pos - 1; i >= lineStart; i--) {
        if (text[i] === char) {
          newPos = beforeChar ? i + 1 : i;
          break;
        }
      }
    }
    
    if (newPos >= lineStart && newPos < lineEnd) {
      this.editor.selectionStart = newPos;
      this.editor.selectionEnd = newPos;
    }
  },
  
  repeatFindChar(directionMultiplier) {
    if (this.lastFindChar) {
      const direction = this.lastFindDirection * directionMultiplier;
      const beforeChar = this.lastFindType === 't';
      this.findCharInLine(this.lastFindChar, direction, beforeChar);
    }
  },
  
  // ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ç§»å‹•
  moveParagraph(direction) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lines = text.split('\n');
    
    // ç¾åœ¨ã®è¡Œç•ªå·ã‚’è¨ˆç®—
    let currentLine = 0;
    let charCount = 0;
    for (let i = 0; i < lines.length; i++) {
      if (charCount + lines[i].length >= pos) {
        currentLine = i;
        break;
      }
      charCount += lines[i].length + 1;
    }
    
    let targetLine = currentLine;
    
    if (direction > 0) {
      // æ¬¡ã®ç©ºè¡Œã‚’æ¢ã™ï¼ˆ}ï¼‰
      // ã¾ãšç¾åœ¨ã®ç©ºè¡Œãƒ–ãƒ­ãƒƒã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—
      while (targetLine < lines.length && lines[targetLine].trim() === '') {
        targetLine++;
      }
      // æ¬¡ã®ç©ºè¡Œã‚’è¦‹ã¤ã‘ã‚‹
      while (targetLine < lines.length && lines[targetLine].trim() !== '') {
        targetLine++;
      }
    } else {
      // å‰ã®ç©ºè¡Œã‚’æ¢ã™ï¼ˆ{ï¼‰
      // ã¾ãšç¾åœ¨è¡Œã‹ã‚‰1ã¤æˆ»ã‚‹
      targetLine--;
      // ç¾åœ¨ã®ç©ºè¡Œãƒ–ãƒ­ãƒƒã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—
      while (targetLine >= 0 && lines[targetLine].trim() === '') {
        targetLine--;
      }
      // å‰ã®ç©ºè¡Œã‚’è¦‹ã¤ã‘ã‚‹
      while (targetLine >= 0 && lines[targetLine].trim() !== '') {
        targetLine--;
      }
      // è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°å…ˆé ­ã¸
      if (targetLine < 0) targetLine = 0;
    }
    
    // targetLineãŒç¯„å›²å¤–ãªã‚‰è£œæ­£
    targetLine = Math.max(0, Math.min(targetLine, lines.length - 1));
    
    // æ–°ã—ã„ä½ç½®ã‚’è¨ˆç®—
    let newPos = 0;
    for (let i = 0; i < targetLine; i++) {
      newPos += lines[i].length + 1;
    }
    
    this.previousPosition = pos;
    this.editor.selectionStart = newPos;
    this.editor.selectionEnd = newPos;
    this.scrollToCursor();
    this.updateCursorPos();
  },
  
  // æ‹¬å¼§ã‚¸ãƒ£ãƒ³ãƒ—
  jumpToMatchingBracket() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const char = text[pos];
    
    const pairs = { '(': ')', ')': '(', '[': ']', ']': '[', '{': '}', '}': '{', '<': '>', '>': '<' };
    const openBrackets = '([{<';
    
    if (!pairs[char]) {
      // ç¾åœ¨ä½ç½®ã«æ‹¬å¼§ãŒãªã„å ´åˆã€è¡Œå†…ã§æœ€åˆã®æ‹¬å¼§ã‚’æ¢ã™
      const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
      let lineEnd = text.indexOf('\n', pos);
      if (lineEnd === -1) lineEnd = text.length;
      
      for (let i = pos; i < lineEnd; i++) {
        if (pairs[text[i]]) {
          this.editor.selectionStart = i;
          this.editor.selectionEnd = i;
          this.jumpToMatchingBracket();
          return;
        }
      }
      return;
    }
    
    const target = pairs[char];
    const isOpen = openBrackets.includes(char);
    let depth = 0;
    
    if (isOpen) {
      for (let i = pos; i < text.length; i++) {
        if (text[i] === char) depth++;
        else if (text[i] === target) {
          depth--;
          if (depth === 0) {
            this.previousPosition = pos;
            this.editor.selectionStart = i;
            this.editor.selectionEnd = i;
            this.scrollToCursor();
            return;
          }
        }
      }
    } else {
      for (let i = pos; i >= 0; i--) {
        if (text[i] === char) depth++;
        else if (text[i] === target) {
          depth--;
          if (depth === 0) {
            this.previousPosition = pos;
            this.editor.selectionStart = i;
            this.editor.selectionEnd = i;
            this.scrollToCursor();
            return;
          }
        }
      }
    }
  },
  
  // ãƒã‚¯ãƒ­
  startRecordingMacro(name) {
    this.recordingMacro = name;
    this.macroBuffer = [];
    this.macroIndicator.classList.add('active');
    this.modeIndicator.classList.add('recording');
    this.showStatus(`ãƒã‚¯ãƒ­ '${name}' è¨˜éŒ²é–‹å§‹`);
  },
  
  stopRecordingMacro() {
    this.macros[this.recordingMacro] = [...this.macroBuffer];
    this.showStatus(`ãƒã‚¯ãƒ­ '${this.recordingMacro}' è¨˜éŒ²å®Œäº† (${this.macroBuffer.length} ã‚­ãƒ¼)`);
    this.recordingMacro = null;
    this.macroBuffer = [];
    this.macroIndicator.classList.remove('active');
    this.modeIndicator.classList.remove('recording');
  },
  
  playMacro(name) {
    const macro = this.macros[name];
    if (!macro || macro.length === 0) return;
    
    this.lastMacro = name;
    
    // ãƒã‚¯ãƒ­å†ç”Ÿä¸­ã¯è¨˜éŒ²ã—ãªã„
    const wasRecording = this.recordingMacro;
    this.recordingMacro = null;
    
    for (const keyInfo of macro) {
      const event = new KeyboardEvent('keydown', {
        key: keyInfo.key,
        ctrlKey: keyInfo.ctrlKey || false,
        shiftKey: keyInfo.shiftKey || false
      });
      
      if (this.mode === 'insert') {
        if (keyInfo.key === 'Escape') {
          this.exitInsertMode();
        } else if (keyInfo.key.length === 1) {
          this.insertText(keyInfo.key);
        }
      } else {
        this.handleNormalMode(event);
      }
    }
    
    this.recordingMacro = wasRecording;
  },
  
  // ãƒ‰ãƒƒãƒˆãƒªãƒ”ãƒ¼ãƒˆ
  setLastEdit(type, char = null, count = 1) {
    this.lastEdit = { type, char, count, insertedText: '' };
  },
  
  repeatLastEdit(count) {
    if (!this.lastEdit) return;
    
    const repeat = count || this.lastEdit.count || 1;
    
    for (let i = 0; i < repeat; i++) {
      this.saveState();
      
      switch(this.lastEdit.type) {
        case 'x':
          this.deleteChar();
          break;
        case 'X':
          this.deleteCharBefore();
          break;
        case 'dd':
          this.deleteLine();
          break;
        case 'dw':
          this.deleteWord();
          break;
        case 'd$':
        case 'D':
          this.deleteToLineEnd();
          break;
        case 'd0':
          this.deleteToLineStart();
          break;
        case 'cc':
        case 'S':
          this.deleteLineContent();
          this.insertText(this.lastEdit.insertedText || '');
          break;
        case 'cw':
          this.deleteWord();
          this.insertText(this.lastEdit.insertedText || '');
          break;
        case 'C':
          this.deleteToLineEnd();
          this.insertText(this.lastEdit.insertedText || '');
          break;
        case 'r':
          this.replaceChar(this.lastEdit.char);
          break;
        case 's':
          this.deleteChar();
          this.insertText(this.lastEdit.insertedText || '');
          break;
        case 'o':
          this.moveToLineEnd();
          this.insertText('\n' + (this.lastEdit.insertedText || ''));
          break;
        case 'O':
          this.moveToLineStart();
          this.insertText((this.lastEdit.insertedText || '') + '\n');
          this.moveVertical(-1);
          break;
        case 'insert':
          this.insertText(this.lastEdit.insertedText || '');
          break;
        case '~':
          this.toggleCase();
          break;
        case '>>':
          this.indentLine(1);
          break;
        case '<<':
          this.indentLine(-1);
          break;
        case 'J':
          this.joinLines();
          break;
        // ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        case 'diw': case 'daw': case 'ciw': case 'caw':
        case 'di"': case 'da"': case "di'": case "da'":
        case 'di(': case 'da(': case 'di[': case 'da[':
        case 'di{': case 'da{': case 'di`': case 'da`':
          const op = this.lastEdit.type[0];
          const inner = this.lastEdit.type[1] === 'i';
          const objChar = this.lastEdit.type[2];
          this.handleTextObject(op + (inner ? 'i' : 'a'), objChar);
          if (op === 'c') {
            this.insertText(this.lastEdit.insertedText || '');
          }
          break;
      }
    }
  },
  
  // å¤§æ–‡å­—/å°æ–‡å­—åˆ‡æ›¿
  toggleCase() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    if (pos < text.length) {
      const char = text[pos];
      let newChar;
      if (char === char.toLowerCase()) {
        newChar = char.toUpperCase();
      } else {
        newChar = char.toLowerCase();
      }
      
      this.editor.value = text.substring(0, pos) + newChar + text.substring(pos + 1);
      this.editor.selectionStart = pos + 1;
      this.editor.selectionEnd = pos + 1;
      this.onInput();
    }
  },
  
  toggleCaseSelection(start, end) {
    const text = this.editor.value;
    let result = '';
    
    for (let i = start; i < end; i++) {
      const char = text[i];
      if (char === char.toLowerCase()) {
        result += char.toUpperCase();
      } else {
        result += char.toLowerCase();
      }
    }
    
    this.editor.value = text.substring(0, start) + result + text.substring(end);
    this.editor.selectionStart = start;
    this.editor.selectionEnd = start;
    this.onInput();
  },
  
  changeCaseSelection(start, end, caseType) {
    const text = this.editor.value;
    const selected = text.substring(start, end);
    const changed = caseType === 'upper' ? selected.toUpperCase() : selected.toLowerCase();
    
    this.editor.value = text.substring(0, start) + changed + text.substring(end);
    this.editor.selectionStart = start;
    this.editor.selectionEnd = start;
    this.onInput();
  },
  
  // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
  indentLine(direction) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    
    const line = text.substring(lineStart, lineEnd);
    let newLine;
    
    if (direction > 0) {
      newLine = '  ' + line;
    } else {
      newLine = line.replace(/^  /, '').replace(/^\t/, '');
    }
    
    this.editor.value = text.substring(0, lineStart) + newLine + text.substring(lineEnd);
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineStart;
    this.onInput();
  },
  
  indentSelection(direction) {
    const text = this.editor.value;
    const start = this.editor.selectionStart;
    const end = this.editor.selectionEnd;
    
    const lineStart = text.lastIndexOf('\n', start - 1) + 1;
    let lineEnd = text.indexOf('\n', end - 1);
    if (lineEnd === -1) lineEnd = text.length;
    
    const selectedLines = text.substring(lineStart, lineEnd).split('\n');
    const newLines = selectedLines.map(line => {
      if (direction > 0) {
        return '  ' + line;
      } else {
        return line.replace(/^  /, '').replace(/^\t/, '');
      }
    });
    
    this.editor.value = text.substring(0, lineStart) + newLines.join('\n') + text.substring(lineEnd);
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineStart;
    this.onInput();
  },
  
  // ç§»å‹•ç³»
  moveCursor(delta) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const newPos = Math.max(0, Math.min(text.length, pos + delta));
    this.editor.selectionStart = newPos;
    this.editor.selectionEnd = newPos;
  },
  
  moveVertical(direction) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lines = text.substring(0, pos).split('\n');
    const currentLine = lines.length - 1;
    const currentCol = lines[lines.length - 1].length;
    const allLines = text.split('\n');
    
    const targetLine = currentLine + direction;
    if (targetLine < 0 || targetLine >= allLines.length) return;
    
    let newPos = 0;
    for (let i = 0; i < targetLine; i++) newPos += allLines[i].length + 1;
    newPos += Math.min(currentCol, allLines[targetLine].length);
    
    this.editor.selectionStart = newPos;
    this.editor.selectionEnd = newPos;
  },
  
  moveWord(direction) {
    const text = this.editor.value;
    let pos = this.editor.selectionStart;
    
    if (direction > 0) {
      const match = text.substring(pos).match(/^\s*\S+\s*/);
      if (match) pos += match[0].length;
    } else {
      const before = text.substring(0, pos);
      const match = before.match(/\S+\s*$/);
      if (match) pos -= match[0].length;
    }
    
    this.editor.selectionStart = pos;
    this.editor.selectionEnd = pos;
  },
  
  moveWordEnd() {
    const text = this.editor.value;
    let pos = this.editor.selectionStart;
    const match = text.substring(pos + 1).match(/^\s*\S*/);
    if (match) pos += match[0].length;
    this.editor.selectionStart = pos;
    this.editor.selectionEnd = pos;
  },
  
  moveToLineStart() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineStart;
  },
  
  moveToLineEnd() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    this.editor.selectionStart = lineEnd;
    this.editor.selectionEnd = lineEnd;
  },
  
  moveToFirstNonSpace() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    const line = text.substring(lineStart, lineEnd);
    const match = line.match(/^\s*/);
    const newPos = lineStart + (match ? match[0].length : 0);
    this.editor.selectionStart = newPos;
    this.editor.selectionEnd = newPos;
  },
  
  moveToStart() { 
    this.previousPosition = this.editor.selectionStart;
    this.editor.selectionStart = 0; 
    this.editor.selectionEnd = 0;
    this.editor.scrollTop = 0;
  },
  
  moveToEnd() { 
    this.previousPosition = this.editor.selectionStart;
    const len = this.editor.value.length; 
    this.editor.selectionStart = len; 
    this.editor.selectionEnd = len;
    this.editor.scrollTop = this.editor.scrollHeight;
  },
  
  gotoLine(lineNum) {
    this.previousPosition = this.editor.selectionStart;
    const lines = this.editor.value.split('\n');
    const targetLine = Math.min(Math.max(1, lineNum), lines.length) - 1;
    let pos = 0;
    for (let i = 0; i < targetLine; i++) pos += lines[i].length + 1;
    this.editor.selectionStart = pos;
    this.editor.selectionEnd = pos;
    this.scrollToCursor();
    this.editor.focus();
    this.updateCursorPos();
  },
  
  gotoPosition(pos) {
    this.editor.selectionStart = pos;
    this.editor.selectionEnd = pos;
    this.scrollToCursor();
    this.editor.focus();
    this.updateCursorPos();
  },
  
  selectCurrentLine() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    else lineEnd++;
    this.visualStart = lineStart;
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineEnd;
  },
  
  // ç·¨é›†ç³»
  insertText(text) {
    const pos = this.editor.selectionStart;
    const before = this.editor.value.substring(0, pos);
    const after = this.editor.value.substring(this.editor.selectionEnd);
    this.editor.value = before + text + after;
    this.editor.selectionStart = pos + text.length;
    this.editor.selectionEnd = this.editor.selectionStart;
    this.onInput();
  },
  
  deleteChar() {
    const pos = this.editor.selectionStart;
    const text = this.editor.value;
    if (pos < text.length) {
      // æ”¹è¡Œã‚’å‰Šé™¤ã™ã‚‹å ´åˆã‚‚è€ƒæ…®
      this.editor.value = text.substring(0, pos) + text.substring(pos + 1);
      this.editor.selectionStart = pos;
      this.editor.selectionEnd = pos;
      this.onInput();
    }
    this.editor.focus();
    this.updateCursorPos();
  },
  
  deleteCharBefore() {
    const pos = this.editor.selectionStart;
    if (pos > 0) {
      this.editor.value = this.editor.value.substring(0, pos - 1) + this.editor.value.substring(pos);
      this.editor.selectionStart = pos - 1;
      this.editor.selectionEnd = pos - 1;
      this.onInput();
    }
    this.editor.focus();
    this.updateCursorPos();
  },
  
  deleteLine() {
    const text = this.editor.value;
    if (text.length === 0) return; // ç©ºã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ä½•ã‚‚ã—ãªã„
    
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    
    if (lineEnd === -1) {
      // æœ€çµ‚è¡Œã®å ´åˆ
      lineEnd = text.length;
      // å‰ã®è¡ŒãŒã‚ã‚‹å ´åˆã€å‰ã®æ”¹è¡Œã‚‚å‰Šé™¤
      if (lineStart > 0) {
        this.register = text.substring(lineStart, lineEnd) + '\n';
        this.editor.value = text.substring(0, lineStart - 1);
        this.editor.selectionStart = Math.max(0, lineStart - 1);
        this.editor.selectionEnd = this.editor.selectionStart;
      } else {
        // 1è¡Œç›®ã‹ã¤æœ€çµ‚è¡Œï¼ˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«1è¡Œã—ã‹ãªã„ï¼‰
        this.register = text.substring(lineStart, lineEnd) + '\n';
        this.editor.value = '';
        this.editor.selectionStart = 0;
        this.editor.selectionEnd = 0;
      }
    } else {
      // æœ€çµ‚è¡Œã§ã¯ãªã„å ´åˆã€æ”¹è¡Œã‚‚å«ã‚ã¦å‰Šé™¤
      lineEnd++;
      this.register = text.substring(lineStart, lineEnd);
      this.editor.value = text.substring(0, lineStart) + text.substring(lineEnd);
      // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’èª¿æ•´ï¼ˆå‰Šé™¤å¾Œã®ãƒ†ã‚­ã‚¹ãƒˆé•·ã‚’è¶…ãˆãªã„ã‚ˆã†ã«ï¼‰
      const newPos = Math.min(lineStart, this.editor.value.length);
      this.editor.selectionStart = newPos;
      this.editor.selectionEnd = newPos;
    }
    
    this.editor.focus();
    this.onInput();
    this.updateCursorPos();
  },
  
  deleteLineContent() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    
    // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’ä¿æŒ
    const line = text.substring(lineStart, lineEnd);
    const indent = line.match(/^\s*/)[0];
    
    this.register = line;
    this.editor.value = text.substring(0, lineStart) + indent + text.substring(lineEnd);
    this.editor.selectionStart = lineStart + indent.length;
    this.editor.selectionEnd = lineStart + indent.length;
    this.onInput();
  },
  
  deleteWord() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const match = text.substring(pos).match(/^\S*\s*/);
    if (match) {
      this.register = match[0];
      this.editor.value = text.substring(0, pos) + text.substring(pos + match[0].length);
      this.onInput();
    }
  },
  
  deleteToLineEnd() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    
    this.register = text.substring(pos, lineEnd);
    this.editor.value = text.substring(0, pos) + text.substring(lineEnd);
    this.onInput();
  },
  
  deleteToLineStart() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    
    this.register = text.substring(lineStart, pos);
    this.editor.value = text.substring(0, lineStart) + text.substring(pos);
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineStart;
    this.onInput();
  },
  
  deleteSelection() {
    const start = this.editor.selectionStart;
    const end = this.editor.selectionEnd;
    this.editor.value = this.editor.value.substring(0, start) + this.editor.value.substring(end);
    this.editor.selectionStart = start;
    this.editor.selectionEnd = start;
    this.onInput();
  },
  
  replaceChar(char) {
    const pos = this.editor.selectionStart;
    const text = this.editor.value;
    if (pos < text.length) {
      this.editor.value = text.substring(0, pos) + char + text.substring(pos + 1);
      this.onInput();
    }
  },
  
  joinLines() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) return;
    
    // æ¬¡ã®è¡Œã®å…ˆé ­ã®ç©ºç™½ã‚’å–å¾—
    const nextLineStart = lineEnd + 1;
    const nextLineMatch = text.substring(nextLineStart).match(/^\s*/);
    const nextLineIndent = nextLineMatch ? nextLineMatch[0].length : 0;
    
    this.editor.value = text.substring(0, lineEnd) + ' ' + text.substring(nextLineStart + nextLineIndent);
    this.editor.selectionStart = lineEnd;
    this.editor.selectionEnd = lineEnd;
    this.onInput();
  },
  
  // ãƒ¤ãƒ³ã‚¯/ãƒšãƒ¼ã‚¹ãƒˆ
  // registerã«ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿å­˜ã—ã€ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚‚ã‚³ãƒ”ãƒ¼
  setRegister(text) {
    this.register = text;
    navigator.clipboard.writeText(text).catch(() => {});
  },
  
  yankLine() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    else lineEnd++;
    
    this.setRegister(text.substring(lineStart, lineEnd));
    this.showStatus('1è¡Œãƒ¤ãƒ³ã‚¯ã—ã¾ã—ãŸ');
  },
  
  yankWord() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const match = text.substring(pos).match(/^\S+/);
    if (match) {
      this.setRegister(match[0]);
      this.showStatus('ãƒ¤ãƒ³ã‚¯ã—ã¾ã—ãŸ');
    }
  },
  
  paste() {
    if (!this.register) return;
    
    if (this.register.endsWith('\n')) {
      let lineEnd = this.editor.value.indexOf('\n', this.editor.selectionStart);
      if (lineEnd === -1) lineEnd = this.editor.value.length;
      this.editor.selectionStart = lineEnd;
      this.editor.selectionEnd = lineEnd;
      this.insertText('\n' + this.register.slice(0, -1));
    } else {
      this.moveCursor(1);
      this.insertText(this.register);
    }
  },
  
  pasteBefore() {
    if (!this.register) return;
    
    if (this.register.endsWith('\n')) {
      this.moveToLineStart();
      this.insertText(this.register);
      this.moveToLineStart();
    } else {
      this.insertText(this.register);
    }
  },
  
  // ã‚¢ãƒ³ãƒ‰ã‚¥/ãƒªãƒ‰ã‚¥
  saveState() {
    this.undoStack.push({ text: this.editor.value, pos: this.editor.selectionStart });
    this.redoStack = [];
    if (this.undoStack.length > 100) this.undoStack.shift();
  },
  
  undo() {
    if (this.undoStack.length === 0) { this.showStatus('ã“ã‚Œä»¥ä¸Šæˆ»ã‚Œã¾ã›ã‚“'); return; }
    this.redoStack.push({ text: this.editor.value, pos: this.editor.selectionStart });
    const state = this.undoStack.pop();
    this.editor.value = state.text;
    this.editor.selectionStart = state.pos;
    this.editor.selectionEnd = state.pos;
    this.onInput();
    this.showStatus('ã‚¢ãƒ³ãƒ‰ã‚¥ã—ã¾ã—ãŸ');
  },
  
  redo() {
    if (this.redoStack.length === 0) { this.showStatus('ã“ã‚Œä»¥ä¸Šã‚„ã‚Šç›´ã›ã¾ã›ã‚“'); return; }
    this.undoStack.push({ text: this.editor.value, pos: this.editor.selectionStart });
    const state = this.redoStack.pop();
    this.editor.value = state.text;
    this.editor.selectionStart = state.pos;
    this.editor.selectionEnd = state.pos;
    this.onInput();
    this.showStatus('ãƒªãƒ‰ã‚¥ã—ã¾ã—ãŸ');
  },
  
  // æ¤œç´¢
  search(term) { this.searchTerm = term; this.findNext(); },
  
  searchWordUnderCursor() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    let start = pos;
    let end = pos;
    while (start > 0 && /\w/.test(text[start - 1])) start--;
    while (end < text.length && /\w/.test(text[end])) end++;
    
    if (start < end) {
      this.searchTerm = text.substring(start, end);
      this.findNext();
    }
  },
  
  findNext() {
    if (!this.searchTerm) return;
    const text = this.editor.value;
    const pos = this.editor.selectionStart + 1;
    let idx = text.indexOf(this.searchTerm, pos);
    
    if (idx === -1) idx = text.indexOf(this.searchTerm);
    
    if (idx !== -1) {
      this.previousPosition = this.editor.selectionStart;
      this.editor.selectionStart = idx;
      this.editor.selectionEnd = idx + this.searchTerm.length;
      this.scrollToCursor();
      this.showStatus('/' + this.searchTerm);
    } else {
      this.showStatus('è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ' + this.searchTerm);
    }
    this.editor.focus();
    this.updateCursorPos();
  },
  
  findPrev() {
    if (!this.searchTerm) return;
    const text = this.editor.value;
    const pos = this.editor.selectionStart - 1;
    let idx = text.lastIndexOf(this.searchTerm, pos);
    
    if (idx === -1) idx = text.lastIndexOf(this.searchTerm);
    
    if (idx !== -1) {
      this.previousPosition = this.editor.selectionStart;
      this.editor.selectionStart = idx;
      this.editor.selectionEnd = idx + this.searchTerm.length;
      this.scrollToCursor();
      this.showStatus('/' + this.searchTerm);
    } else {
      this.showStatus('è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ' + this.searchTerm);
    }
    this.editor.focus();
    this.updateCursorPos();
  },
  
  // ä¿å­˜
  save() {
    this.saveSessionData();
    this.modified = false;
    this.updateFileStatus();
    this.showStatus('ä¿å­˜ã—ã¾ã—ãŸ');
  },
  
  // ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
  saveSessionData() {
    // sessionStorageã«ä¿å­˜ï¼ˆã‚¿ãƒ–å¾©å¸°ç”¨ï¼‰
    sessionStorage.setItem('vim-md-content-' + this.sessionId, this.editor.value);
    
    // localStorageã«ã‚»ãƒƒã‚·ãƒ§ãƒ³ã”ã¨ã«ä¿å­˜
    const sessionData = {
      content: this.editor.value,
      filename: this.currentFileName || 'ç„¡é¡Œ',
      timestamp: Date.now()
    };
    localStorage.setItem('vim-md-session-' + this.sessionId, JSON.stringify(sessionData));
    
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒªã‚¹ãƒˆã‚’æ›´æ–°
    let sessions = [];
    try {
      sessions = JSON.parse(localStorage.getItem('vim-md-sessions') || '[]');
    } catch (e) {
      sessions = [];
    }
    if (!sessions.includes(this.sessionId)) {
      sessions.push(this.sessionId);
      localStorage.setItem('vim-md-sessions', JSON.stringify(sessions));
    }
    
    // å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆ7æ—¥ä»¥ä¸Šå‰ï¼‰
    this.cleanupOldSessions();
  },
  
  // å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤
  cleanupOldSessions() {
    const maxAge = 7 * 24 * 60 * 60 * 1000; // 7æ—¥
    const now = Date.now();
    let sessions = [];
    try {
      sessions = JSON.parse(localStorage.getItem('vim-md-sessions') || '[]');
    } catch (e) {
      return;
    }
    
    const validSessions = sessions.filter(sid => {
      if (sid === this.sessionId) return true; // ç¾åœ¨ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¯ä¿æŒ
      try {
        const data = JSON.parse(localStorage.getItem('vim-md-session-' + sid) || '{}');
        if (data.timestamp && (now - data.timestamp) > maxAge) {
          localStorage.removeItem('vim-md-session-' + sid);
          return false;
        }
        return true;
      } catch (e) {
        localStorage.removeItem('vim-md-session-' + sid);
        return false;
      }
    });
    
    if (validSessions.length !== sessions.length) {
      localStorage.setItem('vim-md-sessions', JSON.stringify(validSessions));
    }
  },
  
  // è‡ªå‹•ä¿å­˜
  autoSave() {
    this.saveSessionData();
  },
  
  // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§ä¿å­˜
  // ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¸Šæ›¸ãä¿å­˜
  async saveToCurrentFile() {
    if (!this.currentFileHandle) {
      // ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒ³ãƒ‰ãƒ«ãŒãªã„å ´åˆã¯ä¿å­˜ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã
      return this.saveWithDialog();
    }
    
    try {
      const writable = await this.currentFileHandle.createWritable();
      await writable.write(this.editor.value);
      await writable.close();
      
      this.modified = false;
      this.updateFileStatus();
      this.showStatus(`"${this.currentFileName}" ã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
    } catch (err) {
      // æ¨©é™ã‚¨ãƒ©ãƒ¼ãªã©ã®å ´åˆã¯ä¿å­˜ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      if (err.name === 'NotAllowedError') {
        this.showStatus('æ›¸ãè¾¼ã¿æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚åˆ¥åã§ä¿å­˜ã—ã¾ã™...');
        return this.saveWithDialog();
      }
      this.showStatus('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
      console.error('Save error:', err);
    }
  },
  
  async saveWithDialog() {
    // File System Access API ãŒä½¿ãˆã‚‹ã‹ç¢ºèª
    if ('showSaveFilePicker' in window) {
      try {
        const handle = await window.showSaveFilePicker({
          suggestedName: this.currentFileName || 'document.md',
          types: [{
            description: 'Markdown Files',
            accept: { 'text/markdown': ['.md', '.markdown'] }
          }, {
            description: 'Text Files',
            accept: { 'text/plain': ['.txt'] }
          }]
        });
        
        const writable = await handle.createWritable();
        await writable.write(this.editor.value);
        await writable.close();
        
        this.currentFileName = handle.name;
        this.fileName.textContent = handle.name;
        this.currentFileHandle = handle;
        this.modified = false;
        this.updateFileStatus();
        this.showStatus(`"${handle.name}" ã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
      } catch (err) {
        if (err.name !== 'AbortError') {
          this.showStatus('ä¿å­˜ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ');
        }
      }
    } else {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å…¥åŠ›
      const filename = prompt('ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:', this.currentFileName || 'document.md');
      if (filename) {
        this.downloadFile(filename);
      }
    }
  },
  
  // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
  async openWithDialog() {
    // File System Access API ãŒä½¿ãˆã‚‹ã‹ç¢ºèª
    if ('showOpenFilePicker' in window) {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{
            description: 'Markdown Files',
            accept: { 'text/markdown': ['.md', '.markdown'] }
          }, {
            description: 'Text Files',
            accept: { 'text/plain': ['.txt'] }
          }],
          multiple: false
        });
        
        const file = await handle.getFile();
        const content = await file.text();
        
        this.undoStack = [];
        this.redoStack = [];
        this.editor.value = content;
        this.fileName.textContent = file.name;
        this.currentFileName = file.name;
        this.currentFileHandle = handle;
        this.modified = false;
        this.updateFileStatus();
        this.updateLineNumbers();
        this.updatePreview();
        this.updateToc();  // ç›®æ¬¡æ›´æ–°
        this.editor.selectionStart = 0;
        this.editor.selectionEnd = 0;
        this.updateCursorPos();
        this.saveState();
        this.showStatus(`"${file.name}" ã‚’é–‹ãã¾ã—ãŸ`);
      } catch (err) {
        if (err.name !== 'AbortError') {
          this.showStatus('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã‘ã¾ã›ã‚“ã§ã—ãŸ');
        }
      }
    } else {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: inputè¦ç´ ã‚’ä½¿ç”¨
      this.openFileDialog(false);
    }
  },
  
  // æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«
  newFile() {
    this.undoStack = [];
    this.redoStack = [];
    this.editor.value = '';
    this.fileName.textContent = 'ç„¡é¡Œ';
    this.currentFileName = 'ç„¡é¡Œ';
    this.currentFileHandle = null;
    this.modified = false;
    this.updateFileStatus();
    this.updateLineNumbers();
    this.updatePreview();
    this.updateToc();  // ç›®æ¬¡æ›´æ–°
    this.editor.selectionStart = 0;
    this.editor.selectionEnd = 0;
    this.updateCursorPos();
    this.saveState();
    this.showStatus('æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«');
  },
  
  // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
  downloadFile(filename) {
    // æ‹¡å¼µå­ãŒãªã‘ã‚Œã° .md ã‚’è¿½åŠ 
    if (!filename.includes('.')) {
      filename += '.md';
    }
    
    const blob = new Blob([this.editor.value], { type: 'text/markdown;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    this.fileName.textContent = filename;
    this.currentFileName = filename;
    this.modified = false;
    this.updateFileStatus();
    this.showStatus(`"${filename}" ã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
  },
  
  // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã
  openFileDialog(insertMode = false) {
    this.fileInsertMode = insertMode;
    this.fileInput.click();
  },
  
  // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
  handleFileOpen(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      const content = event.target.result;
      
      if (this.fileInsertMode) {
        // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«æŒ¿å…¥
        this.saveState();
        this.insertText(content);
        this.updateToc();  // ç›®æ¬¡æ›´æ–°
        this.showStatus(`"${file.name}" ã‚’æŒ¿å…¥ã—ã¾ã—ãŸ`);
      } else {
        // ãƒ•ã‚¡ã‚¤ãƒ«å…¨ä½“ã‚’ç½®ãæ›ãˆ
        this.undoStack = [];
        this.redoStack = [];
        this.editor.value = content;
        this.fileName.textContent = file.name;
        this.currentFileName = file.name;
        this.modified = false;
        this.updateFileStatus();
        this.updateLineNumbers();
        this.updatePreview();
        this.updateToc();  // ç›®æ¬¡æ›´æ–°
        this.editor.selectionStart = 0;
        this.editor.selectionEnd = 0;
        this.updateCursorPos();
        this.saveState();
        this.showStatus(`"${file.name}" ã‚’é–‹ãã¾ã—ãŸ`);
      }
      
      this.fileInsertMode = false;
    };
    
    reader.onerror = () => {
      this.showStatus('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
    };
    
    reader.readAsText(file);
    
    // åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†åº¦é¸æŠã§ãã‚‹ã‚ˆã†ã«ãƒªã‚»ãƒƒãƒˆ
    this.fileInput.value = '';
  },
  
  // UI
  setMode(mode) {
    this.mode = mode;
    if (this.vimMode) {
      this.modeIndicator.textContent = mode.toUpperCase();
      this.modeIndicator.className = mode;
      this.modeIndicator.style.opacity = '';
      if (this.recordingMacro) this.modeIndicator.classList.add('recording');
    }
    
    if (mode === 'command') {
      this.commandLine.classList.remove('hidden');
      this.commandInput.focus();
    } else {
      this.commandLine.classList.add('hidden');
      this.editor.focus();
    }
    
    // VIMãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã®ã¿readOnlyã‚’åˆ¶å¾¡
    if (this.vimMode) {
      this.editor.readOnly = (mode !== 'insert');
    } else {
      this.editor.readOnly = false;
    }
    
    // ã‚«ãƒ¼ã‚½ãƒ«è¡¨ç¤ºã®æ›´æ–°
    if (mode === 'insert') {
      this.editor.classList.add('insert-mode');
    } else {
      this.editor.classList.remove('insert-mode');
    }
    this.updateCursorOverlay();
  },
  
  onInput(e) {
    this.modified = true;
    this.updateFileStatus();
    
    // è»½ã„å‡¦ç†ã¯å³åº§ã«å®Ÿè¡Œ
    this.updateCursorPos();
    
    // é‡ã„å‡¦ç†ã¯ãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼ˆ150msï¼‰
    clearTimeout(this.heavyUpdateTimer);
    this.heavyUpdateTimer = setTimeout(() => {
      this.updateLineNumbers();
      this.updatePreview();
      this.updateToc();
    }, 150);
    
    // æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ã§ã®ãƒ†ã‚­ã‚¹ãƒˆè¿½è·¡
    if (this.mode === 'insert' && e && e.data) {
      this.lastEditText += e.data;
    }
    
    // è‡ªå‹•ä¿å­˜ï¼ˆè¨­å®šã«å¿œã˜ãŸé–“éš”ï¼‰
    clearTimeout(this.autoSaveTimer);
    const intervals = {
      'off': null,
      '1s': 1000,
      '5s': 5000,
      '10s': 10000,
      '30s': 30000,
      '60s': 60000
    };
    const interval = intervals[this.autoSaveInterval];
    if (interval) {
      this.autoSaveTimer = setTimeout(() => this.autoSave(), interval);
    }
  },
  
  updateCursorPos() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lines = text.substring(0, pos).split('\n');
    const line = lines.length;
    const col = lines[lines.length - 1].length + 1;
    this.cursorPos.textContent = `${line}:${col}`;
    this.updateCursorOverlay();
    
    // VIMãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€ã‚«ãƒ¼ã‚½ãƒ«ãŒè¦‹ãˆã‚‹ä½ç½®ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
    if (this.vimMode) {
      this.scrollToCursor();
    }
    
    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ç¾åœ¨è¡Œã«åŒæœŸ
    this.syncPreviewToLine(line - 1);
    
    // ç›®æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
    this.updateTocActive(line - 1);
  },
  
  updateCursorOverlay() {
    if (!this.cursorOverlay) return;
    
    // NOVIMãƒ¢ãƒ¼ãƒ‰ã§ã¯ã‚«ãƒ¼ã‚½ãƒ«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’éè¡¨ç¤º
    if (!this.vimMode) {
      this.cursorOverlay.style.display = 'none';
      return;
    }
    
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    // ç¾åœ¨è¡Œã¨ã‚«ãƒ©ãƒ ã‚’è¨ˆç®—
    const textBeforeCursor = text.substring(0, pos);
    const lines = textBeforeCursor.split('\n');
    const currentLineIndex = lines.length - 1;
    const currentCol = lines[currentLineIndex];
    
    // è¡Œã®é«˜ã•ã¨ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’å–å¾—
    const style = getComputedStyle(this.editor);
    const lineHeight = parseFloat(style.lineHeight);
    const paddingTop = parseFloat(style.paddingTop);
    const paddingLeft = parseFloat(style.paddingLeft);
    
    // æ–‡å­—å¹…ã‚’æ¸¬å®š
    this.measureSpan.textContent = currentCol || ' ';
    const charWidth = this.measureSpan.getBoundingClientRect().width / (currentCol.length || 1);
    const textWidth = currentCol.length * charWidth;
    
    // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’è¨ˆç®—
    const top = paddingTop + (currentLineIndex * lineHeight) - this.editor.scrollTop;
    const left = paddingLeft + textWidth - this.editor.scrollLeft;
    
    // ã‚«ãƒ¼ã‚½ãƒ«ã®æ–‡å­—ï¼ˆãƒ–ãƒ­ãƒƒã‚¯ã‚«ãƒ¼ã‚½ãƒ«ç”¨ï¼‰
    const charAtCursor = text[pos] || ' ';
    const cursorWidth = charAtCursor === '\n' || charAtCursor === ' ' || pos >= text.length 
      ? charWidth 
      : charWidth;
    
    // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’é…ç½®
    this.cursorOverlay.style.top = `${top}px`;
    this.cursorOverlay.style.left = `${left}px`;
    this.cursorOverlay.style.width = `${cursorWidth}px`;
    this.cursorOverlay.style.height = `${lineHeight}px`;
    
    // ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦ã‚¯ãƒ©ã‚¹ã‚’è¨­å®š
    this.cursorOverlay.className = this.mode;
    
    // ç”»é¢å¤–ãªã‚‰éè¡¨ç¤º
    if (top < 0 || top > this.editor.clientHeight) {
      this.cursorOverlay.style.display = 'none';
    } else {
      this.cursorOverlay.style.display = 'block';
    }
  },
  
  updateFileStatus() { this.fileStatus.textContent = this.modified ? '[+]' : ''; },
  
  // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
  showStatus(message, duration = 2000) {
    const helpHint = document.getElementById('help-hint');
    if (helpHint) {
      const originalText = '? ã§ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º';
      helpHint.textContent = message;
      if (this.statusTimeout) {
        clearTimeout(this.statusTimeout);
      }
      this.statusTimeout = setTimeout(() => {
        helpHint.textContent = originalText;
      }, duration);
    }
  },
  
  updateLineNumbers() {
    const lines = this.editor.value.split('\n');
    let html = '';
    let inCodeBlock = false;
    
    for (let i = 0; i < lines.length; i++) {
      const lineNum = i + 1;
      const line = lines[i];
      
      // ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®é–‹å§‹/çµ‚äº†ã‚’è¿½è·¡
      if (line.trim().startsWith('```')) {
        inCodeBlock = !inCodeBlock;
      }
      
      // ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å¤–ã§è¦‹å‡ºã—è¡Œã‹ã©ã†ã‹åˆ¤å®š
      const headingMatch = !inCodeBlock && line.match(/^(#{1,6})\s+.+/);
      
      if (headingMatch) {
        const level = headingMatch[1].length;
        html += `<span class="line-num heading-h${level}">${lineNum}</span>`;
      } else {
        html += `<span class="line-num">${lineNum}</span>`;
      }
    }
    
    this.lineNumbers.innerHTML = html;
  },

  updatePreview() {
    this.preview.innerHTML = MarkdownParser.parse(this.editor.value);
    this.renderMath();
    this.renderMermaid();
    this.setupHeadingFold();
    this.highlightCode();
  },
  
  // ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  highlightCode() {
    if (typeof hljs !== 'undefined') {
      this.preview.querySelectorAll('pre code').forEach(block => {
        hljs.highlightElement(block);
      });
    }
  },
  
  // ç›®æ¬¡ã‚’æ›´æ–°
  updateToc() {
    if (!this.tocContent) return;
    
    const lines = this.editor.value.split('\n');
    let html = '';
    let inCodeBlock = false;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      if (line.trim().startsWith('```')) {
        inCodeBlock = !inCodeBlock;
        continue;
      }
      if (inCodeBlock) continue;
      
      const match = line.match(/^(#{1,6})\s+(.+)/);
      if (match) {
        const level = match[1].length;
        const text = match[2].trim();
        html += `<div class="toc-item h${level}" data-line="${i}" title="${text}">${text}</div>`;
      }
    }
    
    this.tocContent.innerHTML = html || '<div style="padding: 0.5rem; color: var(--text-secondary); font-size: 0.85rem;">è¦‹å‡ºã—ãŒã‚ã‚Šã¾ã›ã‚“</div>';
    
    // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
    this.tocContent.querySelectorAll('.toc-item').forEach(item => {
      item.addEventListener('click', () => {
        const lineNum = parseInt(item.dataset.line);
        this.jumpToLine(lineNum);
      });
    });
  },
  
  // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’é©ç”¨
  applyFontSize() {
    const scale = this.fontSize / 100;
    const baseFontSize = 0.95 * scale;
    const basePreviewSize = 1 * scale;
    
    if (this.editor) {
      this.editor.style.fontSize = `${baseFontSize}rem`;
    }
    if (this.lineNumbers) {
      this.lineNumbers.style.fontSize = `${baseFontSize}rem`;
    }
    if (this.preview) {
      this.preview.style.fontSize = `${basePreviewSize}rem`;
    }
    
    if (this.fontSizeDisplay) {
      this.fontSizeDisplay.textContent = `${this.fontSize}%`;
    }
    
    // åˆæœŸåŒ–å®Œäº†å¾Œã®ã¿è¡¨ç¤ºã‚’æ›´æ–°
    if (this.initialized) {
      this.updateCursorOverlay();
    }
  },
  
  // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’å¤§ãã
  increaseFontSize() {
    if (this.fontSize < 200) {
      this.fontSize += 10;
      this.applyFontSize();
      localStorage.setItem('vim-md-font-size', this.fontSize);
    }
  },
  
  // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’å°ã•ã
  decreaseFontSize() {
    if (this.fontSize > 50) {
      this.fontSize -= 10;
      this.applyFontSize();
      localStorage.setItem('vim-md-font-size', this.fontSize);
    }
  },
  
  // VIMãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®š
  setVimMode(enabled) {
    this.vimMode = enabled;
    localStorage.setItem('vim-md-vim-mode', enabled);
    if (enabled) {
      this.mode = 'normal';
      this.editor.classList.remove('insert-mode');
      this.showStatus('VIMãƒ¢ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹åŒ–');
    } else {
      this.mode = 'insert';
      this.editor.classList.add('insert-mode');
      this.showStatus('é€šå¸¸ç·¨é›†ãƒ¢ãƒ¼ãƒ‰');
    }
    this.updateVimModeUI();
    this.updateCursorOverlay();  // ã‚«ãƒ¼ã‚½ãƒ«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æ›´æ–°
    this.editor.focus();
  },
  
  // VIMãƒ¢ãƒ¼ãƒ‰UIã‚’æ›´æ–°
  updateVimModeUI() {
    const btn = document.getElementById('btn-vim-mode');
    if (btn) {
      btn.textContent = this.vimMode ? 'VIM' : 'NOVIM';
      btn.classList.toggle('active', this.vimMode);
    }
    if (this.modeIndicator) {
      if (this.vimMode) {
        this.modeIndicator.textContent = this.mode.toUpperCase();
        this.modeIndicator.className = this.mode;
      } else {
        this.modeIndicator.textContent = 'EDIT';
        this.modeIndicator.className = 'edit-mode';
      }
    }
    // NOVIMãƒ¢ãƒ¼ãƒ‰ã§ã¯readOnlyã‚’å¸¸ã«falseã«ã€ã‚«ãƒ¼ã‚½ãƒ«ã‚’è¡¨ç¤º
    if (this.editor) {
      if (this.vimMode) {
        this.editor.readOnly = (this.mode !== 'insert');
        if (this.mode === 'insert') {
          this.editor.classList.add('insert-mode');
        } else {
          this.editor.classList.remove('insert-mode');
        }
      } else {
        this.editor.readOnly = false;
        this.editor.classList.add('insert-mode');  // NOVIMãƒ¢ãƒ¼ãƒ‰ã§ã¯å¸¸ã«ã‚«ãƒ¼ã‚½ãƒ«è¡¨ç¤º
      }
    }
  },
  
  // VIMãƒ¢ãƒ¼ãƒ‰ã‚’ãƒˆã‚°ãƒ«
  toggleVimMode() {
    this.setVimMode(!this.vimMode);
  },
  
  // ç›®æ¬¡ã®é–‹é–‰
  toggleToc() {
    this.tocVisible = !this.tocVisible;
    
    if (this.tocVisible) {
      this.tocPane.classList.remove('collapsed');
      this.tocOpenBtn.classList.add('hidden');
    } else {
      this.tocPane.classList.add('collapsed');
      this.tocOpenBtn.classList.remove('hidden');
    }
  },
  
  // æŒ‡å®šè¡Œã«ã‚¸ãƒ£ãƒ³ãƒ—
  jumpToLine(lineNum) {
    const lines = this.editor.value.split('\n');
    
    // è¡Œã®å…ˆé ­ä½ç½®ã‚’è¨ˆç®—
    let pos = 0;
    for (let i = 0; i < lineNum; i++) {
      pos += lines[i].length + 1;
    }
    
    // ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç§»å‹•
    this.editor.focus();
    this.editor.setSelectionRange(pos, pos);
    
    // ã‚¨ãƒ‡ã‚£ã‚¿ã‚’ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const scrollTop = lineNum * lineHeight - this.editor.clientHeight / 3;
    this.editor.scrollTop = Math.max(0, scrollTop);
    
    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚‚åŒæœŸ
    this.syncPreviewToLine(lineNum);
    
    // ç›®æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
    this.updateTocActive(lineNum);
    
    // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ›´æ–°
    this.updateCursorPos();
    this.updateCursorOverlay();
  },
  
  // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æŒ‡å®šè¡Œã«åŒæœŸ
  // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æŒ‡å®šè¡Œã«åŒæœŸ
  syncPreviewToLine(lineNum) {
    const lines = this.editor.value.split('\n');
    let targetHeadingText = null;
    let targetLevel = null;
    let inCodeBlock = false;
    
    // æŒ‡å®šè¡ŒãŒè¦‹å‡ºã—ã‹ãƒã‚§ãƒƒã‚¯
    const currentLine = lines[lineNum];
    if (currentLine && /^#{1,6}\s+/.test(currentLine)) {
      targetHeadingText = currentLine.replace(/^#+\s+/, '').trim();
      targetLevel = currentLine.match(/^(#{1,6})/)[1].length;
    } else {
      // æŒ‡å®šè¡Œä»¥å‰ã§æœ€ã‚‚è¿‘ã„è¦‹å‡ºã—ã‚’æ¢ã™
      for (let i = lineNum; i >= 0; i--) {
        const line = lines[i];
        if (line.trim().startsWith('```')) {
          inCodeBlock = !inCodeBlock;
        }
        if (!inCodeBlock && /^#{1,6}\s+/.test(line)) {
          targetHeadingText = line.replace(/^#+\s+/, '').trim();
          targetLevel = line.match(/^(#{1,6})/)[1].length;
          break;
        }
      }
    }
    
    if (targetHeadingText) {
      // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†…ã§è©²å½“ã™ã‚‹è¦‹å‡ºã—ã‚’æ¢ã—ã¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
      const headings = this.preview.querySelectorAll('h1, h2, h3, h4, h5, h6');
      for (const h of headings) {
        const text = h.textContent.replace(/^[â–¼â–¶]\s*/, '').trim();
        if (text === targetHeadingText) {
          // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å†…ã§ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
          const previewContent = document.getElementById('preview-content');
          const rect = h.getBoundingClientRect();
          const containerRect = previewContent.getBoundingClientRect();
          const scrollOffset = rect.top - containerRect.top + previewContent.scrollTop - 50;
          previewContent.scrollTop = Math.max(0, scrollOffset);
          break;
        }
      }
    }
  },
  
  // ç›®æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
  updateTocActive(lineNum) {
    if (!this.tocContent) return;
    
    const items = this.tocContent.querySelectorAll('.toc-item');
    let activeItem = null;
    
    // ç¾åœ¨è¡Œä»¥å‰ã§æœ€ã‚‚è¿‘ã„è¦‹å‡ºã—ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«
    items.forEach(item => {
      item.classList.remove('active');
      const itemLine = parseInt(item.dataset.line);
      if (itemLine <= lineNum) {
        activeItem = item;
      }
    });
    
    if (activeItem) {
      activeItem.classList.add('active');
      // ç›®æ¬¡å†…ã§ã‚¢ã‚¯ãƒ†ã‚£ãƒ–é …ç›®ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
      activeItem.scrollIntoView({ block: 'nearest' });
    }
  },
  
  // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è¦‹å‡ºã—æŠ˜ã‚Šç•³ã¿æ©Ÿèƒ½
  setupHeadingFold() {
    const headings = this.preview.querySelectorAll('h1, h2, h3, h4, h5, h6');
    
    headings.forEach(heading => {
      // æŠ˜ã‚Šç•³ã¿ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’è¿½åŠ 
      if (!heading.querySelector('.fold-indicator')) {
        const indicator = document.createElement('span');
        indicator.className = 'fold-indicator';
        indicator.textContent = 'â–¼';
        heading.insertBefore(indicator, heading.firstChild);
      }
      
      // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
      heading.style.cursor = 'pointer';
      heading.onclick = (e) => {
        e.stopPropagation();
        this.toggleHeadingFold(heading);
      };
    });
  },
  
  toggleHeadingFold(heading) {
    const level = parseInt(heading.tagName[1]);
    const indicator = heading.querySelector('.fold-indicator');
    const isFolded = heading.classList.contains('folded');
    
    if (isFolded) {
      // å±•é–‹ã™ã‚‹å ´åˆ - ç›´æ¥ã®å­ãƒ¬ãƒ™ãƒ«ã®ã¿è¡¨ç¤º
      heading.classList.remove('folded');
      indicator.textContent = 'â–¼';
      
      let sibling = heading.nextElementSibling;
      let directChildLevel = null; // ç›´æ¥ã®å­ãƒ¬ãƒ™ãƒ«
      
      while (sibling) {
        if (/^H[1-6]$/.test(sibling.tagName)) {
          const siblingLevel = parseInt(sibling.tagName[1]);
          
          // åŒãƒ¬ãƒ™ãƒ«ä»¥ä¸Šã®è¦‹å‡ºã—ã§åœæ­¢
          if (siblingLevel <= level) break;
          
          // æœ€åˆã«è¦‹ã¤ã‹ã£ãŸå­è¦‹å‡ºã—ã®ãƒ¬ãƒ™ãƒ«ã‚’ç›´æ¥ã®å­ãƒ¬ãƒ™ãƒ«ã¨ã™ã‚‹
          if (directChildLevel === null) {
            directChildLevel = siblingLevel;
          }
          
          // ç›´æ¥ã®å­ãƒ¬ãƒ™ãƒ«ã®è¦‹å‡ºã—ã®ã¿è¡¨ç¤º
          if (siblingLevel === directChildLevel) {
            sibling.style.display = '';
            sibling.classList.remove('heading-hidden');
            // å­è¦‹å‡ºã—ã¯æŠ˜ã‚ŠãŸãŸã¾ã‚ŒãŸçŠ¶æ…‹ã‚’ç¶­æŒ
          }
          // ãã‚Œä»¥å¤–ï¼ˆå­«ä»¥ä¸‹ï¼‰ã¯éè¡¨ç¤ºã®ã¾ã¾
        } else {
          // è¦‹å‡ºã—ä»¥å¤–ã®è¦ç´  - ç›´æ¥ã®å­ãƒ¬ãƒ™ãƒ«ãŒè¦‹ã¤ã‹ã‚‹å‰ãªã‚‰è¡¨ç¤º
          if (directChildLevel === null) {
            sibling.style.display = '';
            sibling.classList.remove('heading-hidden');
          }
        }
        sibling = sibling.nextElementSibling;
      }
    } else {
      // æŠ˜ã‚ŠãŸãŸã‚€å ´åˆ
      heading.classList.add('folded');
      indicator.textContent = 'â–¶';
      
      let sibling = heading.nextElementSibling;
      while (sibling) {
        if (/^H[1-6]$/.test(sibling.tagName)) {
          const siblingLevel = parseInt(sibling.tagName[1]);
          if (siblingLevel <= level) break;
        }
        sibling.style.display = 'none';
        sibling.classList.add('heading-hidden');
        sibling = sibling.nextElementSibling;
      }
    }
  },
  
  // å…¨ã¦ã®è¦‹å‡ºã—ã‚’æŠ˜ã‚ŠãŸãŸã‚€
  foldAllHeadings() {
    const headings = this.preview.querySelectorAll('h1, h2, h3, h4, h5, h6');
    headings.forEach(heading => {
      if (!heading.classList.contains('folded')) {
        this.toggleHeadingFold(heading);
      }
    });
  },
  
  // å…¨ã¦ã®è¦‹å‡ºã—ã‚’å±•é–‹ã™ã‚‹
  unfoldAllHeadings() {
    const headings = this.preview.querySelectorAll('h1, h2, h3, h4, h5, h6');
    // é€†é †ã§å±•é–‹ï¼ˆãƒã‚¹ãƒˆã•ã‚ŒãŸè¦‹å‡ºã—ã‚’æ­£ã—ãå±•é–‹ã™ã‚‹ãŸã‚ï¼‰
    const headingsArray = Array.from(headings).reverse();
    headingsArray.forEach(heading => {
      if (heading.classList.contains('folded')) {
        this.toggleHeadingFold(heading);
      }
    });
  },
  
  renderMermaid() {
    // MermaidãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
    if (typeof mermaid === 'undefined') return;
    
    const mermaidDivs = this.preview.querySelectorAll('.mermaid');
    if (mermaidDivs.length === 0) return;
    
    // å„Mermaidè¦ç´ ã«ãƒ¦ãƒ‹ãƒ¼ã‚¯IDã‚’ä»˜ä¸ã—ã¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    mermaidDivs.forEach((el, i) => {
      el.setAttribute('id', `mermaid-${Date.now()}-${i}`);
    });
    
    try {
      mermaid.run({
        nodes: mermaidDivs
      });
    } catch (e) {
      console.error('Mermaid rendering error:', e);
    }
  },
  
  renderMath() {
    // KaTeXãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
    if (typeof katex === 'undefined') return;
    
    // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³æ•°å¼ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    const inlineMath = this.preview.querySelectorAll('.math-inline');
    inlineMath.forEach(el => {
      const formula = el.getAttribute('data-math');
      try {
        katex.render(formula, el, {
          throwOnError: false,
          displayMode: false
        });
      } catch (e) {
        el.innerHTML = `<span class="math-error">${formula}</span>`;
      }
    });
    
    // ãƒ–ãƒ­ãƒƒã‚¯æ•°å¼ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    const blockMath = this.preview.querySelectorAll('.math-block');
    blockMath.forEach(el => {
      const formula = el.getAttribute('data-math');
      try {
        katex.render(formula, el, {
          throwOnError: false,
          displayMode: true
        });
      } catch (e) {
        el.innerHTML = `<span class="math-error">${formula}</span>`;
      }
    });
  },
  
  syncScroll() {
    const editor = this.editor;
    const preview = document.getElementById('preview-pane');
    const ratio = editor.scrollTop / (editor.scrollHeight - editor.clientHeight || 1);
    preview.scrollTop = ratio * (preview.scrollHeight - preview.clientHeight);
  },
  
  scrollHalfPage(direction) {
    const height = this.editor.clientHeight / 2;
    this.editor.scrollTop += height * direction;
    this.moveCursorToVisibleArea(direction);
  },
  
  scrollFullPage(direction) {
    const height = this.editor.clientHeight;
    this.editor.scrollTop += height * direction;
    this.moveCursorToVisibleArea(direction);
  },
  
  // ã‚«ãƒ¼ã‚½ãƒ«ã‚’è¡¨ç¤ºé ˜åŸŸå†…ã«ç§»å‹•
  moveCursorToVisibleArea(direction) {
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const visibleTop = this.editor.scrollTop;
    const visibleBottom = visibleTop + this.editor.clientHeight;
    
    // ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«è¡Œã‚’è¨ˆç®—
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const linesBeforeCursor = text.substring(0, pos).split('\n').length - 1;
    const cursorTop = linesBeforeCursor * lineHeight;
    
    // ã‚«ãƒ¼ã‚½ãƒ«ãŒè¦‹ãˆãªã„å ´åˆã€è¦‹ãˆã‚‹ä½ç½®ã«ç§»å‹•
    if (cursorTop < visibleTop || cursorTop > visibleBottom - lineHeight) {
      const targetLine = Math.floor((direction > 0 ? visibleTop : visibleBottom - lineHeight) / lineHeight);
      const lines = text.split('\n');
      const clampedLine = Math.max(0, Math.min(targetLine, lines.length - 1));
      
      let newPos = 0;
      for (let i = 0; i < clampedLine; i++) {
        newPos += lines[i].length + 1;
      }
      
      this.editor.selectionStart = newPos;
      this.editor.selectionEnd = newPos;
      this.updateCursorPos();
    }
  },
  
  // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
  scrollToCursor() {
    const style = getComputedStyle(this.editor);
    const lineHeight = parseFloat(style.lineHeight);
    const paddingLeft = parseFloat(style.paddingLeft);
    const text = this.editor.value;
    
    // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€visualStartã®åå¯¾å´ãŒã‚«ãƒ¼ã‚½ãƒ«ä½ç½®
    let pos;
    if (this.mode === 'visual' && this.visualStart !== undefined) {
      if (this.editor.selectionStart < this.visualStart) {
        pos = this.editor.selectionStart;
      } else {
        pos = this.editor.selectionEnd;
      }
    } else {
      pos = this.editor.selectionStart;
    }
    
    const lines = text.substring(0, pos).split('\n');
    const linesBeforeCursor = lines.length - 1;
    const cursorTop = linesBeforeCursor * lineHeight;
    
    // === ç¸¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« ===
    const visibleTop = this.editor.scrollTop;
    const visibleBottom = visibleTop + this.editor.clientHeight;
    
    if (cursorTop < visibleTop) {
      this.editor.scrollTop = cursorTop - this.editor.clientHeight / 4;
    } else if (cursorTop > visibleBottom - lineHeight * 2) {
      this.editor.scrollTop = cursorTop - this.editor.clientHeight * 3 / 4;
    }
    
    // === æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« ===
    const currentLineText = lines[lines.length - 1];
    
    // æ–‡å­—å¹…ã‚’æ¸¬å®š
    this.measureSpan.textContent = currentLineText || 'M';
    const textWidth = this.measureSpan.getBoundingClientRect().width;
    const cursorLeft = currentLineText.length > 0 ? textWidth : 0;
    
    const visibleLeft = this.editor.scrollLeft;
    const visibleRight = visibleLeft + this.editor.clientWidth - paddingLeft - 20;
    
    // ã‚«ãƒ¼ã‚½ãƒ«ãŒå³ç«¯ã‚’è¶…ãˆãŸå ´åˆ
    if (cursorLeft > visibleRight) {
      this.editor.scrollLeft = cursorLeft - this.editor.clientWidth + paddingLeft + 100;
    }
    // ã‚«ãƒ¼ã‚½ãƒ«ãŒå·¦ç«¯ã‚ˆã‚Šå·¦ã«ã‚ã‚‹å ´åˆ
    else if (cursorLeft < visibleLeft) {
      this.editor.scrollLeft = Math.max(0, cursorLeft - 50);
    }
  },
  
  // z Enter, zt - ã‚«ãƒ¼ã‚½ãƒ«è¡Œã‚’ç”»é¢ä¸Šéƒ¨ã«
  scrollCursorToTop() {
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const linesBeforeCursor = text.substring(0, pos).split('\n').length - 1;
    const cursorTop = linesBeforeCursor * lineHeight;
    
    this.editor.scrollTop = cursorTop;
    this.updateCursorPos();
  },
  
  // z. zz - ã‚«ãƒ¼ã‚½ãƒ«è¡Œã‚’ç”»é¢ä¸­å¤®ã«
  scrollCursorToCenter() {
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const linesBeforeCursor = text.substring(0, pos).split('\n').length - 1;
    const cursorTop = linesBeforeCursor * lineHeight;
    
    this.editor.scrollTop = cursorTop - (this.editor.clientHeight / 2) + lineHeight;
    this.updateCursorPos();
  },
  
  // z- zb - ã‚«ãƒ¼ã‚½ãƒ«è¡Œã‚’ç”»é¢ä¸‹éƒ¨ã«
  scrollCursorToBottom() {
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const linesBeforeCursor = text.substring(0, pos).split('\n').length - 1;
    const cursorTop = linesBeforeCursor * lineHeight;
    
    this.editor.scrollTop = cursorTop - this.editor.clientHeight + lineHeight * 2;
    this.updateCursorPos();
  }
};

function setViewMode(mode) {
  const container = document.getElementById('main-container');
  
  // ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®ã¿ã‚’å¯¾è±¡ã«ã™ã‚‹
  ['edit', 'preview', 'split'].forEach(m => {
    document.getElementById('btn-' + m).classList.remove('active');
  });
  document.getElementById('btn-' + mode).classList.add('active');
  
  container.classList.remove('edit-only', 'preview-only', 'split-view');
  
  if (mode === 'edit') container.classList.add('edit-only');
  else if (mode === 'preview') container.classList.add('preview-only');
  else container.classList.add('split-view');
  
  VimEditor.editor.focus();
}

function setTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme);
  
  // ãƒ†ãƒ¼ãƒãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
  ['dark', 'light', 'original'].forEach(t => {
    const btn = document.getElementById('btn-theme-' + t);
    if (btn) btn.classList.remove('active');
  });
  const activeBtn = document.getElementById('btn-theme-' + theme);
  if (activeBtn) activeBtn.classList.add('active');
  
  // ãƒ†ãƒ¼ãƒè¨­å®šã‚’ä¿å­˜
  localStorage.setItem('vim-md-theme', theme);
  
  // VimEditorãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚Œã°é€šçŸ¥
  if (typeof VimEditor !== 'undefined' && VimEditor.showStatus) {
    VimEditor.showStatus(`ãƒ†ãƒ¼ãƒ: ${theme}`);
  }
}

function loadTheme() {
  const saved = localStorage.getItem('vim-md-theme');
  if (saved && ['dark', 'light', 'original'].includes(saved)) {
    document.documentElement.setAttribute('data-theme', saved);
    // ãƒœã‚¿ãƒ³ã®æ›´æ–°ï¼ˆDOMãŒæº–å‚™ã§ãã¦ã„ã‚‹å ´åˆï¼‰
    const btn = document.getElementById('btn-theme-' + saved);
    if (btn) {
      ['dark', 'light', 'original'].forEach(t => {
        const b = document.getElementById('btn-theme-' + t);
        if (b) b.classList.remove('active');
      });
      btn.classList.add('active');
    }
  }
}

function toggleHelp() {
  document.getElementById('help-modal').classList.toggle('hidden');
  if (document.getElementById('help-modal').classList.contains('hidden')) {
    VimEditor.editor.focus();
  }
}

document.addEventListener('DOMContentLoaded', () => {
  loadTheme();
  VimEditor.init();
  VimEditor.editor.focus();
  
  // ã©ã“ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚‚ã‚¨ãƒ‡ã‚£ã‚¿ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’æˆ»ã™
  document.addEventListener('click', (e) => {
    // é™¤å¤–ã™ã‚‹è¦ç´ ï¼šãƒœã‚¿ãƒ³ã€å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã€selectã€ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã€ãƒ•ã‚¡ã‚¤ãƒ«å
    const target = e.target;
    const isInteractive = target.closest('button, input, select, a, .filename, #command-input, #help-content');
    
    // ã‚³ãƒãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (VimEditor.mode === 'command') return;
    
    // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªè¦ç´ ã§ãªã‘ã‚Œã°ã‚¨ãƒ‡ã‚£ã‚¿ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
    if (!isInteractive) {
      // å°‘ã—é…å»¶ã•ã›ã¦ã‚¯ãƒªãƒƒã‚¯å‡¦ç†ãŒå®Œäº†ã—ã¦ã‹ã‚‰ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
      setTimeout(() => {
        VimEditor.editor.focus();
        VimEditor.updateCursorPos();
      }, 0);
    }
  });
});

window.addEventListener('beforeunload', e => {
  if (VimEditor.modified) {
    e.preventDefault();
    e.returnValue = '';
  }
});
  </script>
</body>
<!-- KaTeX JS -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<!-- Mermaid JS -->
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<!-- Highlight.js -->
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
<script>
  mermaid.initialize({ 
    startOnLoad: false,
    theme: 'dark',
    securityLevel: 'loose'
  });
</script>
</html>
