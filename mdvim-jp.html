<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>mdvim v0.1 - Vimé¢¨ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚¨ãƒ‡ã‚£ã‚¿</title>
  <!-- KaTeX CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <!-- Highlight.js CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css">
  <style>
/* ãƒ†ãƒ¼ãƒå®šç¾© */
:root, [data-theme="dark"] {
  --bg-primary: #1e1e2e;
  --bg-secondary: #313244;
  --bg-tertiary: #45475a;
  --text-primary: #cdd6f4;
  --text-secondary: #a6adc8;
  --accent: #89b4fa;
  --accent-green: #a6e3a1;
  --accent-yellow: #f9e2af;
  --accent-red: #f38ba8;
  --accent-purple: #cba6f7;
  --border: #585b70;
  /* è¦‹å‡ºã—ãƒ¬ãƒ™ãƒ«åˆ¥ã®è‰² */
  --heading-h1: #f38ba8;
  --heading-h2: #fab387;
  --heading-h3: #f9e2af;
  --heading-h4: #a6e3a1;
  --heading-h5: #89b4fa;
  --heading-h6: #cba6f7;
}

[data-theme="light"] {
  --bg-primary: #ffffff;
  --bg-secondary: #f5f5f5;
  --bg-tertiary: #e0e0e0;
  --text-primary: #1a1a1a;
  --text-secondary: #555555;
  --accent: #0066cc;
  --accent-green: #2e7d32;
  --accent-yellow: #f9a825;
  --accent-red: #c62828;
  --accent-purple: #7b1fa2;
  --border: #cccccc;
  /* è¦‹å‡ºã—ãƒ¬ãƒ™ãƒ«åˆ¥ã®è‰² */
  --heading-h1: #c62828;
  --heading-h2: #e65100;
  --heading-h3: #f9a825;
  --heading-h4: #2e7d32;
  --heading-h5: #0066cc;
  --heading-h6: #7b1fa2;
}

[data-theme="original"] {
  --bg-primary: #000000;
  --bg-secondary: #1a1a1a;
  --bg-tertiary: #2d2d2d;
  --text-primary: #00ff00;
  --text-secondary: #00cc00;
  --accent: #00ffff;
  --accent-green: #00ff00;
  --accent-yellow: #ffff00;
  --accent-red: #ff0000;
  --accent-purple: #ff00ff;
  --border: #333333;
  /* è¦‹å‡ºã—ãƒ¬ãƒ™ãƒ«åˆ¥ã®è‰² */
  --heading-h1: #ff0000;
  --heading-h2: #ff8800;
  --heading-h3: #ffff00;
  --heading-h4: #00ff00;
  --heading-h5: #00ffff;
  --heading-h6: #ff00ff;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'JetBrains Mono', 'Fira Code', 'Source Code Pro', Consolas, monospace;
  background: var(--bg-primary);
  color: var(--text-primary);
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.toolbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.5rem 1rem;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
}

.logo { font-weight: bold; font-size: 1.1rem; color: var(--accent); }

.view-controls button {
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 0.4rem 1rem;
  margin: 0 0.2rem;
  cursor: pointer;
  border-radius: 4px;
  font-family: inherit;
  font-size: 0.85rem;
  transition: all 0.2s;
}

.view-controls button:hover { background: var(--border); }
.view-controls button.active { background: var(--accent); color: var(--bg-primary); border-color: var(--accent); }
.view-controls button[id^="btn-theme-"] { padding: 0.4rem 0.6rem; font-size: 1rem; }

#font-size-display {
  color: var(--text-secondary);
  font-size: 0.85rem;
  min-width: 3rem;
  text-align: center;
}

.mode-indicator { display: flex; gap: 1rem; font-size: 0.9rem; align-items: center; }
#vim-mode { background: var(--accent-green); color: var(--bg-primary); padding: 0.2rem 0.6rem; border-radius: 3px; font-weight: bold; min-width: 80px; text-align: center; }
#vim-mode.insert { background: var(--accent); }
#vim-mode.visual { background: var(--accent-yellow); color: #1e1e2e; }
#vim-mode.command { background: var(--accent-red); }
#vim-mode.recording { background: var(--accent-purple); }
#cursor-pos { color: var(--text-secondary); }
#macro-indicator { color: var(--accent-purple); font-weight: bold; display: none; }
#macro-indicator.active { display: inline; }

#main-container { flex: 1; display: flex; overflow: hidden; }
.pane { flex: 1; display: flex; overflow: hidden; position: relative; }
#editor-pane { border-right: 1px solid var(--border); }

#line-numbers {
  min-width: 3rem;
  background: var(--bg-secondary);
  color: var(--text-secondary);
  text-align: right;
  padding: 0.5rem 0.5rem 0.5rem 0;
  font-size: 0.9rem;
  line-height: 1.5;
  overflow: hidden;
  user-select: none;
  white-space: pre;
}

#line-numbers .line-num {
  display: block;
}

#line-numbers .heading-h1 { color: var(--heading-h1); font-weight: bold; }
#line-numbers .heading-h2 { color: var(--heading-h2); font-weight: bold; }
#line-numbers .heading-h3 { color: var(--heading-h3); font-weight: bold; }
#line-numbers .heading-h4 { color: var(--heading-h4); font-weight: bold; }
#line-numbers .heading-h5 { color: var(--heading-h5); font-weight: bold; }
#line-numbers .heading-h6 { color: var(--heading-h6); font-weight: bold; }

#editor-wrapper {
  flex: 1;
  position: relative;
  overflow: hidden;
}

#editor {
  width: 100%;
  height: 100%;
  background: var(--bg-primary);
  color: var(--text-primary);
  border: none;
  padding: 0.5rem;
  font-family: inherit;
  font-size: 0.95rem;
  line-height: 1.5;
  resize: none;
  outline: none;
  overflow: auto;
  white-space: pre;
  tab-size: 4;
  caret-color: transparent;
}

#editor.insert-mode {
  caret-color: var(--accent);
}

#cursor-overlay {
  position: absolute;
  pointer-events: none;
  background: var(--accent-green);
  opacity: 0.8;
  z-index: 10;
}

#cursor-overlay.insert {
  width: 2px !important;
  background: var(--accent);
  opacity: 1;
}

#cursor-overlay.visual {
  background: var(--accent-yellow);
}

#cursor-overlay.command {
  display: none;
}

@keyframes blink {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 0.3; }
}

#cursor-overlay.blink {
  animation: blink 1s ease-in-out infinite;
}

#preview-pane { 
  background: var(--bg-primary); 
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#preview-content { 
  flex: 1;
  overflow: auto;
  padding: 1.5rem; 
}

#preview-content h1 { font-size: 2rem; margin: 1rem 0 0.5rem; color: var(--heading-h1); border-bottom: 2px solid var(--border); padding-bottom: 0.3rem; }
#preview-content h2 { font-size: 1.6rem; margin: 1rem 0 0.5rem; color: var(--heading-h2); }
#preview-content h3 { font-size: 1.3rem; margin: 0.8rem 0 0.4rem; color: var(--heading-h3); }
#preview-content h4 { margin: 0.6rem 0 0.3rem; color: var(--heading-h4); }
#preview-content h5 { margin: 0.6rem 0 0.3rem; color: var(--heading-h5); }
#preview-content h6 { margin: 0.6rem 0 0.3rem; color: var(--heading-h6); }
#preview-content p { margin: 0.6rem 0; line-height: 1.7; }
#preview-content ul, #preview-content ol { margin: 0.5rem 0; padding-left: 1.5rem; }
#preview-content li { margin: 0.3rem 0; }
#preview-content code { background: var(--bg-secondary); padding: 0.15rem 0.4rem; border-radius: 3px; font-size: 0.9em; }
#preview-content pre { background: var(--bg-secondary); padding: 1rem; border-radius: 6px; overflow-x: auto; margin: 0.8rem 0; }
#preview-content pre code { background: none; padding: 0; }

/* Mermaidå›³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
#preview-content .mermaid {
  background: var(--bg-secondary);
  padding: 1rem;
  border-radius: 6px;
  margin: 0.8rem 0;
  text-align: center;
  overflow-x: auto;
}

#preview-content .mermaid svg {
  max-width: 100%;
  height: auto;
}

/* æŠ˜ã‚Šç•³ã¿ï¼ˆdetailsï¼‰ã®ã‚¹ã‚¿ã‚¤ãƒ« */
#preview-content details.collapsible {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 6px;
  margin: 0.8rem 0;
  overflow: hidden;
}

#preview-content details.collapsible summary {
  background: var(--bg-tertiary);
  padding: 0.6rem 1rem;
  cursor: pointer;
  font-weight: bold;
  user-select: none;
  list-style: none;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

#preview-content details.collapsible summary::-webkit-details-marker {
  display: none;
}

#preview-content details.collapsible summary::before {
  content: "â–¶";
  font-size: 0.8em;
  transition: transform 0.2s;
}

#preview-content details.collapsible[open] summary::before {
  transform: rotate(90deg);
}

#preview-content details.collapsible summary:hover {
  background: var(--border);
}

#preview-content details.collapsible .details-content {
  padding: 1rem;
  border-top: 1px solid var(--border);
}

#preview-content details.collapsible .details-content > :first-child {
  margin-top: 0;
}

#preview-content details.collapsible .details-content > :last-child {
  margin-bottom: 0;
}

/* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¦‹å‡ºã—æŠ˜ã‚Šç•³ã¿ã‚¹ã‚¿ã‚¤ãƒ« */
#preview-content h1,
#preview-content h2,
#preview-content h3,
#preview-content h4,
#preview-content h5,
#preview-content h6 {
  position: relative;
  transition: opacity 0.2s;
}

#preview-content .fold-indicator {
  font-size: 0.7em;
  margin-right: 0.5rem;
  opacity: 0.5;
  transition: transform 0.2s, opacity 0.2s;
  display: inline-block;
}

#preview-content h1:hover .fold-indicator,
#preview-content h2:hover .fold-indicator,
#preview-content h3:hover .fold-indicator,
#preview-content h4:hover .fold-indicator,
#preview-content h5:hover .fold-indicator,
#preview-content h6:hover .fold-indicator {
  opacity: 1;
}

#preview-content .folded .fold-indicator {
  transform: rotate(-90deg);
}

#preview-content .heading-hidden {
  display: none !important;
}

/* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ */
#preview-controls {
  display: flex;
  gap: 0.5rem;
  padding: 0.5rem;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

#preview-controls button {
  padding: 0.3rem 0.8rem;
  font-size: 0.8rem;
  background: var(--bg-tertiary);
  color: var(--text-secondary);
  border: 1px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
}

#preview-controls button:hover {
  background: var(--accent);
  color: var(--bg-primary);
  border-color: var(--accent);
}

/* ç›®æ¬¡ãƒ‘ãƒãƒ« */
#toc-pane {
  width: 200px;
  min-width: 150px;
  max-width: 300px;
  background: var(--bg-secondary);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  transition: width 0.2s, min-width 0.2s;
}

#toc-pane.collapsed {
  width: 0;
  min-width: 0;
  border-right: none;
}

#toc-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem;
  background: var(--bg-tertiary);
  border-bottom: 1px solid var(--border);
  font-weight: bold;
  font-size: 0.85rem;
  color: var(--text-primary);
}

#toc-header button {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.2rem 0.4rem;
  font-size: 0.8rem;
}

#toc-header button:hover {
  color: var(--accent);
}

#toc-content {
  flex: 1;
  overflow-y: auto;
  padding: 0.5rem 0;
}

.toc-item {
  padding: 0.3rem 0.5rem;
  cursor: pointer;
  font-size: 0.85rem;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  border-left: 3px solid transparent;
  transition: all 0.15s;
}

.toc-item:hover {
  background: var(--bg-tertiary);
  color: var(--text-primary);
}

.toc-item.active {
  background: var(--bg-tertiary);
  border-left-color: var(--accent);
  color: var(--text-primary);
}

.toc-item.h1 { padding-left: 0.5rem; color: var(--heading-h1); font-weight: bold; }
.toc-item.h2 { padding-left: 1rem; color: var(--heading-h2); }
.toc-item.h3 { padding-left: 1.5rem; color: var(--heading-h3); }
.toc-item.h4 { padding-left: 2rem; color: var(--heading-h4); }
.toc-item.h5 { padding-left: 2.5rem; color: var(--heading-h5); }
.toc-item.h6 { padding-left: 3rem; color: var(--heading-h6); }

#toc-open-btn {
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-left: none;
  border-radius: 0 4px 4px 0;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.5rem 0.3rem;
  font-size: 0.8rem;
  z-index: 10;
}

#toc-open-btn:hover {
  background: var(--bg-tertiary);
  color: var(--accent);
}

#toc-open-btn.hidden {
  display: none;
}

/* è¦‹å‡ºã—è¡Œãƒã‚¤ãƒ©ã‚¤ãƒˆ */
#heading-highlight {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  overflow: hidden;
  font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
  font-size: 0.95rem;
}

.heading-text-overlay {
  position: absolute;
  white-space: pre;
  font-weight: bold;
}

.heading-text-overlay.h1 { color: var(--heading-h1); }
.heading-text-overlay.h2 { color: var(--heading-h2); }
.heading-text-overlay.h3 { color: var(--heading-h3); }
.heading-text-overlay.h4 { color: var(--heading-h4); }
.heading-text-overlay.h5 { color: var(--heading-h5); }
.heading-text-overlay.h6 { color: var(--heading-h6); }

#preview-content blockquote { border-left: 4px solid var(--accent); padding-left: 1rem; margin: 0.8rem 0; color: var(--text-secondary); font-style: italic; }
#preview-content hr { border: none; border-top: 1px solid var(--border); margin: 1.5rem 0; }
#preview-content a { color: var(--accent); text-decoration: none; }
#preview-content a:hover { text-decoration: underline; }
#preview-content img { max-width: 100%; border-radius: 6px; }
#preview-content table { border-collapse: collapse; margin: 0.8rem 0; width: 100%; }
#preview-content th, #preview-content td { border: 1px solid var(--border); padding: 0.5rem; text-align: left; }
#preview-content th { background: var(--bg-secondary); }

/* KaTeXæ•°å¼ã‚¹ã‚¿ã‚¤ãƒ« */
#preview-content .katex-display {
  margin: 1rem 0;
  overflow-x: auto;
  overflow-y: hidden;
}

#preview-content .katex {
  font-size: 1.1em;
}

#preview-content .math-inline {
  display: inline;
}

#preview-content .math-block {
  display: block;
  text-align: center;
  margin: 1rem 0;
}

#preview-content .math-error {
  color: var(--accent-red);
  font-family: monospace;
  font-size: 0.9em;
}

.edit-only #preview-pane { display: none; }
.edit-only #editor-pane { border-right: none; }
.preview-only #editor-pane { display: none; }

#command-line {
  display: flex;
  align-items: center;
  padding: 0.3rem 0.5rem;
  background: var(--bg-secondary);
  border-top: 1px solid var(--border);
}

#command-line.hidden { display: none; }
#command-prefix { color: var(--accent); font-weight: bold; margin-right: 0.3rem; }
#command-input { flex: 1; background: transparent; border: none; color: var(--text-primary); font-family: inherit; font-size: 0.95rem; outline: none; }

#status-bar {
  display: flex;
  justify-content: space-between;
  padding: 0.3rem 1rem;
  background: var(--bg-tertiary);
  font-size: 0.85rem;
  color: var(--text-secondary);
}

.modal {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal.hidden { display: none; }

.modal-content {
  background: var(--bg-secondary);
  padding: 1.5rem;
  border-radius: 8px;
  max-width: 1000px;
  max-height: 85vh;
  overflow: auto;
}

.modal-content h2 { color: var(--accent); margin-bottom: 1rem; text-align: center; }
.help-columns { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1.5rem; }
.help-section h3 { color: var(--accent-yellow); margin-bottom: 0.5rem; font-size: 1rem; }
.help-section ul { list-style: none; }
.help-section li { margin: 0.3rem 0; font-size: 0.85rem; }
kbd { background: var(--bg-tertiary); padding: 0.1rem 0.4rem; border-radius: 3px; border: 1px solid var(--border); font-family: inherit; font-size: 0.85em; }
.modal-content > button { display: block; margin: 1.5rem auto 0; padding: 0.5rem 2rem; background: var(--accent); color: var(--bg-primary); border: none; border-radius: 4px; font-family: inherit; cursor: pointer; font-size: 1rem; }
.new-feature { color: var(--accent-green); font-size: 0.75em; margin-left: 0.3rem; }

@media (max-width: 900px) {
  .help-columns { grid-template-columns: repeat(2, 1fr); }
}
@media (max-width: 600px) {
  .help-columns { grid-template-columns: 1fr; }
  .toolbar { flex-wrap: wrap; gap: 0.5rem; }
}

/* ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ */
.task-list {
  list-style: none;
  padding-left: 0;
}

.task-item {
  display: flex;
  align-items: flex-start;
  gap: 0.5rem;
}

.task-item input[type="checkbox"] {
  margin-top: 0.3rem;
  accent-color: var(--accent);
}

/* GitHub Alerts */
.alert {
  padding: 1rem;
  margin: 1rem 0;
  border-radius: 6px;
  border-left: 4px solid;
}

.alert-title {
  display: block;
  font-weight: bold;
  margin-bottom: 0.5rem;
}

.alert p {
  margin: 0;
}

.alert-note {
  background: rgba(56, 139, 253, 0.1);
  border-color: #388bfd;
}

.alert-note .alert-title {
  color: #388bfd;
}

.alert-tip {
  background: rgba(46, 160, 67, 0.1);
  border-color: #2ea043;
}

.alert-tip .alert-title {
  color: #2ea043;
}

.alert-important {
  background: rgba(130, 80, 223, 0.1);
  border-color: #8250df;
}

.alert-important .alert-title {
  color: #8250df;
}

.alert-warning {
  background: rgba(210, 153, 34, 0.1);
  border-color: #d29922;
}

.alert-warning .alert-title {
  color: #d29922;
}

.alert-caution {
  background: rgba(248, 81, 73, 0.1);
  border-color: #f85149;
}

.alert-caution .alert-title {
  color: #f85149;
}

/* Highlight.js ã®ã‚¹ã‚¿ã‚¤ãƒ«èª¿æ•´ */
#preview-content pre code.hljs {
  background: transparent;
  padding: 0;
}

/* Qiita noteè¨˜æ³• */
.note {
  display: flex;
  padding: 1rem;
  margin: 1rem 0;
  border-radius: 6px;
  gap: 0.75rem;
}

.note-icon {
  font-size: 1.2rem;
  flex-shrink: 0;
}

.note-content {
  flex: 1;
}

.note-content p:first-child {
  margin-top: 0;
  font-weight: bold;
}

.note-content p:last-child {
  margin-bottom: 0;
}

.note-info {
  background: #e6f6e6;
  border-left: 4px solid #55c500;
}

.note-warn {
  background: #fff9e6;
  border-left: 4px solid #ffc800;
}

.note-alert {
  background: #ffe6e6;
  border-left: 4px solid #dd0000;
}

/* ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒç”¨ */
[data-theme="dark"] .note-info {
  background: rgba(85, 197, 0, 0.15);
}

[data-theme="dark"] .note-warn {
  background: rgba(255, 200, 0, 0.15);
}

[data-theme="dark"] .note-alert {
  background: rgba(221, 0, 0, 0.15);
}
  </style>
</head>
<body>
  <header class="toolbar">
    <div class="logo">ğŸ“ mdvim <span style="font-size: 0.8em; color: var(--accent-green);">v0.1</span></div>
    <div class="view-controls">
      <button id="btn-edit" class="active" onclick="setViewMode('edit')">ç·¨é›†</button>
      <button id="btn-preview" onclick="setViewMode('preview')">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</button>
      <button id="btn-split" onclick="setViewMode('split')">åˆ†å‰²</button>
      <span style="margin: 0 0.5rem; color: var(--border);">|</span>
      <button id="btn-theme-dark" class="active" onclick="setTheme('dark')">ğŸŒ™</button>
      <button id="btn-theme-light" onclick="setTheme('light')">â˜€ï¸</button>
      <button id="btn-theme-original" onclick="setTheme('original')">ğŸ’»</button>
      <span style="margin: 0 0.5rem; color: var(--border);">|</span>
      <button onclick="VimEditor.decreaseFontSize()" title="æ–‡å­—ã‚’å°ã•ã">A-</button>
      <span id="font-size-display">100%</span>
      <button onclick="VimEditor.increaseFontSize()" title="æ–‡å­—ã‚’å¤§ãã">A+</button>
    </div>
    <div class="mode-indicator">
      <span id="vim-mode">NORMAL</span>
      <span id="macro-indicator">â—REC</span>
      <span id="cursor-pos">1:1</span>
    </div>
  </header>
  
  <main id="main-container" class="split-view">
    <div id="toc-pane">
      <div id="toc-header">
        <span>ç›®æ¬¡</span>
        <button id="toc-toggle" onclick="VimEditor.toggleToc()" title="ç›®æ¬¡ã‚’é–‰ã˜ã‚‹">â—€</button>
      </div>
      <div id="toc-content"></div>
    </div>
    <button id="toc-open-btn" class="hidden" onclick="VimEditor.toggleToc()" title="ç›®æ¬¡ã‚’é–‹ã">â–¶</button>
    <div id="editor-pane" class="pane">
      <div id="line-numbers"></div>
      <div id="editor-wrapper">
        <textarea id="editor" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
        <div id="cursor-overlay"></div>
      </div>
    </div>
    <div id="preview-pane" class="pane">
      <div id="preview-controls">
        <button onclick="VimEditor.foldAllHeadings()" title="å…¨ã¦æŠ˜ã‚ŠãŸãŸã‚€">â–¶ å…¨ã¦æŠ˜ã‚ŠãŸãŸã‚€</button>
        <button onclick="VimEditor.unfoldAllHeadings()" title="å…¨ã¦å±•é–‹">â–¼ å…¨ã¦å±•é–‹</button>
      </div>
      <div id="preview-content"></div>
    </div>
  </main>
  
  <div id="command-line" class="hidden">
    <span id="command-prefix">:</span>
    <input type="text" id="command-input">
  </div>
  
  <input type="file" id="file-input" accept=".md,.txt,.markdown" style="display: none;">
  
  <footer id="status-bar">
    <span id="file-name">ç„¡é¡Œ</span>
    <span id="file-status"></span>
    <span id="help-hint">? ã§ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º</span>
  </footer>
  
  <div id="help-modal" class="modal hidden">
    <div class="modal-content">
      <h2>âŒ¨ï¸ ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰ãƒ˜ãƒ«ãƒ—ï¼ˆæ‹¡å¼µç‰ˆï¼‰</h2>
      <div class="help-columns">
        <div class="help-section">
          <h3>ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿</h3>
          <ul>
            <li><kbd>i</kbd> æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ï¼ˆã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ï¼‰</li>
            <li><kbd>I</kbd> æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ï¼ˆè¡Œé ­ï¼‰</li>
            <li><kbd>a</kbd> æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ï¼ˆã‚«ãƒ¼ã‚½ãƒ«å¾Œï¼‰</li>
            <li><kbd>A</kbd> æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ï¼ˆè¡Œæœ«ï¼‰</li>
            <li><kbd>o</kbd> ä¸‹ã«æ–°ã—ã„è¡Œã‚’æŒ¿å…¥</li>
            <li><kbd>O</kbd> ä¸Šã«æ–°ã—ã„è¡Œã‚’æŒ¿å…¥</li>
            <li><kbd>v</kbd> ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ‰</li>
            <li><kbd>V</kbd> è¡Œãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ‰</li>
            <li><kbd>Esc</kbd> / <kbd>Ctrl+[</kbd> ãƒãƒ¼ãƒãƒ«ã¸</li>
            <li><kbd>:</kbd> ã‚³ãƒãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰</li>
          </ul>
        </div>
        <div class="help-section">
          <h3>ç§»å‹•</h3>
          <ul>
            <li><kbd>h</kbd>/<kbd>j</kbd>/<kbd>k</kbd>/<kbd>l</kbd> å·¦/ä¸‹/ä¸Š/å³</li>
            <li><kbd>w</kbd>/<kbd>b</kbd> å˜èªç§»å‹•ï¼ˆæ¬¡/å‰ï¼‰</li>
            <li><kbd>e</kbd> å˜èªæœ«å°¾ã¸</li>
            <li><kbd>0</kbd>/<kbd>$</kbd> è¡Œé ­/è¡Œæœ«</li>
            <li><kbd>^</kbd> æœ€åˆã®éç©ºç™½æ–‡å­—ã¸</li>
            <li><kbd>gg</kbd>/<kbd>G</kbd> ãƒ•ã‚¡ã‚¤ãƒ«å…ˆé ­/æœ«å°¾</li>
            <li><kbd>f</kbd><i>x</i> / <kbd>F</kbd><i>x</i> è¡Œå†…ã§<i>x</i>ã¸<span class="new-feature">NEW</span></li>
            <li><kbd>t</kbd><i>x</i> / <kbd>T</kbd><i>x</i> <i>x</i>ã®æ‰‹å‰ã¸<span class="new-feature">NEW</span></li>
            <li><kbd>;</kbd> / <kbd>,</kbd> f/t ã‚’ç¹°ã‚Šè¿”ã—<span class="new-feature">NEW</span></li>
            <li><kbd>%</kbd> å¯¾å¿œæ‹¬å¼§ã¸ã‚¸ãƒ£ãƒ³ãƒ—<span class="new-feature">NEW</span></li>
            <li><kbd>{</kbd> / <kbd>}</kbd> ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ç§»å‹•<span class="new-feature">NEW</span></li>
            <li><kbd>Ctrl+f</kbd>/<kbd>Ctrl+b</kbd> 1ãƒšãƒ¼ã‚¸ç§»å‹•<span class="new-feature">NEW</span></li>
            <li><kbd>Ctrl+d</kbd>/<kbd>Ctrl+u</kbd> åŠãƒšãƒ¼ã‚¸ç§»å‹•</li>
          </ul>
        </div>
        <div class="help-section">
          <h3>ç·¨é›†</h3>
          <ul>
            <li><kbd>x</kbd> / <kbd>X</kbd> æ–‡å­—å‰Šé™¤</li>
            <li><kbd>dd</kbd> / <kbd>dw</kbd> / <kbd>D</kbd> å‰Šé™¤</li>
            <li><kbd>cc</kbd> / <kbd>cw</kbd> / <kbd>C</kbd> / <kbd>S</kbd> å¤‰æ›´</li>
            <li><kbd>yy</kbd> / <kbd>yw</kbd> / <kbd>Y</kbd> ãƒ¤ãƒ³ã‚¯</li>
            <li><kbd>p</kbd> / <kbd>P</kbd> è²¼ã‚Šä»˜ã‘</li>
            <li><kbd>u</kbd> / <kbd>Ctrl+r</kbd> ã‚¢ãƒ³ãƒ‰ã‚¥/ãƒªãƒ‰ã‚¥</li>
            <li><kbd>.</kbd> ç›´å‰ã®ç·¨é›†ã‚’ç¹°ã‚Šè¿”ã—<span class="new-feature">NEW</span></li>
            <li><kbd>~</kbd> å¤§æ–‡å­—/å°æ–‡å­—åˆ‡æ›¿<span class="new-feature">NEW</span></li>
            <li><kbd>J</kbd> è¡Œã‚’çµåˆ</li>
            <li><kbd>r</kbd><i>x</i> 1æ–‡å­—ç½®æ›</li>
            <li><kbd>>></kbd> / <kbd><<</kbd> ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ<span class="new-feature">NEW</span></li>
          </ul>
        </div>
        <div class="help-section">
          <h3>ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ<span class="new-feature">NEW</span></h3>
          <ul>
            <li><kbd>diw</kbd> / <kbd>daw</kbd> å˜èªå‰Šé™¤</li>
            <li><kbd>ciw</kbd> / <kbd>caw</kbd> å˜èªå¤‰æ›´</li>
            <li><kbd>di"</kbd> / <kbd>da"</kbd> "..."å†…ã‚’å‰Šé™¤</li>
            <li><kbd>di'</kbd> / <kbd>da'</kbd> '...'å†…ã‚’å‰Šé™¤</li>
            <li><kbd>di(</kbd> / <kbd>da(</kbd> (...)å†…ã‚’å‰Šé™¤</li>
            <li><kbd>di[</kbd> / <kbd>da[</kbd> [...]å†…ã‚’å‰Šé™¤</li>
            <li><kbd>di{</kbd> / <kbd>da{</kbd> {...}å†…ã‚’å‰Šé™¤</li>
            <li><kbd>di`</kbd> / <kbd>da`</kbd> `...`å†…ã‚’å‰Šé™¤</li>
            <li><kbd>yi</kbd><i>x</i> / <kbd>ci</kbd><i>x</i> ã‚‚åŒæ§˜</li>
          </ul>
        </div>
        <div class="help-section">
          <h3>ãƒãƒ¼ã‚¯<span class="new-feature">NEW</span></h3>
          <ul>
            <li><kbd>m</kbd><i>a-z</i> ä½ç½®ã‚’ãƒãƒ¼ã‚¯</li>
            <li><kbd>'</kbd><i>a-z</i> ãƒãƒ¼ã‚¯è¡Œé ­ã¸</li>
            <li><kbd>`</kbd><i>a-z</i> ãƒãƒ¼ã‚¯ä½ç½®ã¸</li>
            <li><kbd>''</kbd> ç›´å‰ä½ç½®ã¸æˆ»ã‚‹</li>
          </ul>
          <h3 style="margin-top: 1rem;">ãƒã‚¯ãƒ­<span class="new-feature">NEW</span></h3>
          <ul>
            <li><kbd>q</kbd><i>a-z</i> è¨˜éŒ²é–‹å§‹</li>
            <li><kbd>q</kbd> è¨˜éŒ²çµ‚äº†</li>
            <li><kbd>@</kbd><i>a-z</i> ãƒã‚¯ãƒ­å†ç”Ÿ</li>
            <li><kbd>@@</kbd> ç›´å‰ã®ãƒã‚¯ãƒ­å†ç”Ÿ</li>
          </ul>
        </div>
        <div class="help-section">
          <h3>æ¤œç´¢ãƒ»ç½®æ›</h3>
          <ul>
            <li><kbd>/</kbd><i>pattern</i> å‰æ–¹æ¤œç´¢</li>
            <li><kbd>n</kbd> / <kbd>N</kbd> æ¬¡/å‰ã®æ¤œç´¢çµæœ</li>
            <li><kbd>*</kbd> ã‚«ãƒ¼ã‚½ãƒ«ä¸‹ã®å˜èªã‚’æ¤œç´¢</li>
            <li><kbd>:s/old/new/</kbd> ç½®æ›ï¼ˆç¾åœ¨è¡Œï¼‰<span class="new-feature">NEW</span></li>
            <li><kbd>:%s/old/new/g</kbd> å…¨ç½®æ›<span class="new-feature">NEW</span></li>
            <li><kbd>:n,ms/old/new/g</kbd> ç¯„å›²ç½®æ›<span class="new-feature">NEW</span></li>
          </ul>
          <h3 style="margin-top: 1rem;">ã‚³ãƒãƒ³ãƒ‰</h3>
          <ul>
            <li><kbd>:w</kbd> ä¿å­˜ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã<span class="new-feature">NEW</span></li>
            <li><kbd>:w file.md</kbd> æŒ‡å®šåã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</li>
            <li><kbd>:e</kbd> ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã<span class="new-feature">NEW</span></li>
            <li><kbd>:r</kbd> ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«æŒ¿å…¥</li>
            <li><kbd>:new</kbd> æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«<span class="new-feature">NEW</span></li>
            <li><kbd>:ls</kbd> ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜<span class="new-feature">NEW</span></li>
            <li><kbd>:q</kbd> / <kbd>:wq</kbd> çµ‚äº†</li>
            <li><kbd>:set nu/nonu</kbd> è¡Œç•ªå·åˆ‡æ›¿</li>
            <li><kbd>:theme dark/light/original</kbd> ãƒ†ãƒ¼ãƒå¤‰æ›´<span class="new-feature">NEW</span></li>
            <li><kbd>:help</kbd> ãƒ˜ãƒ«ãƒ—è¡¨ç¤º</li>
          </ul>
        </div>
      </div>
      <div class="help-section" style="margin-top: 1rem;">
        <h3>æ•°å¼ï¼ˆLaTeXï¼‰<span class="new-feature">NEW</span></h3>
        <ul style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.3rem;">
          <li><kbd>$...$</kbd> ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³æ•°å¼</li>
          <li><kbd>$$...$$</kbd> ãƒ–ãƒ­ãƒƒã‚¯æ•°å¼</li>
          <li><kbd>\frac{a}{b}</kbd> åˆ†æ•°</li>
          <li><kbd>\sqrt{x}</kbd> å¹³æ–¹æ ¹</li>
          <li><kbd>x^{2}</kbd> ä¸Šä»˜ã</li>
          <li><kbd>x_{i}</kbd> ä¸‹ä»˜ã</li>
          <li><kbd>\sum_{i=0}^{n}</kbd> ç·å’Œ</li>
          <li><kbd>\int_{a}^{b}</kbd> ç©åˆ†</li>
          <li><kbd>\alpha \beta</kbd> ã‚®ãƒªã‚·ãƒ£æ–‡å­—</li>
          <li><kbd>\mathbf{x}</kbd> å¤ªå­—</li>
        </ul>
        <h3 style="margin-top: 1rem;">ãƒ†ãƒ¼ãƒ–ãƒ«<span class="new-feature">NEW</span></h3>
        <ul>
          <li><kbd>| A | B |</kbd> ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œ</li>
          <li><kbd>|---|---|</kbd> åŒºåˆ‡ã‚Šè¡Œ</li>
          <li><kbd>|:--|</kbd> å·¦å¯„ã› <kbd>|:-:|</kbd> ä¸­å¤® <kbd>|--:|</kbd> å³å¯„ã›</li>
        </ul>
        <h3 style="margin-top: 1rem;">Mermaidå›³<span class="new-feature">NEW</span></h3>
        <ul>
          <li><kbd>```mermaid</kbd> å›³ãƒ–ãƒ­ãƒƒã‚¯é–‹å§‹</li>
          <li><kbd>graph TD</kbd> ãƒ•ãƒ­ãƒ¼ãƒãƒ£ãƒ¼ãƒˆï¼ˆä¸Šâ†’ä¸‹ï¼‰</li>
          <li><kbd>graph LR</kbd> ãƒ•ãƒ­ãƒ¼ãƒãƒ£ãƒ¼ãƒˆï¼ˆå·¦â†’å³ï¼‰</li>
          <li><kbd>sequenceDiagram</kbd> ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å›³</li>
          <li><kbd>classDiagram</kbd> ã‚¯ãƒ©ã‚¹å›³</li>
          <li><kbd>gantt</kbd> ã‚¬ãƒ³ãƒˆãƒãƒ£ãƒ¼ãƒˆ</li>
          <li><kbd>pie</kbd> å††ã‚°ãƒ©ãƒ•</li>
        </ul>
        <h3 style="margin-top: 1rem;">æŠ˜ã‚Šç•³ã¿<span class="new-feature">NEW</span></h3>
        <ul>
          <li><kbd>:::details ã‚¿ã‚¤ãƒˆãƒ«</kbd> æŠ˜ã‚Šç•³ã¿é–‹å§‹</li>
          <li><kbd>:::</kbd> æŠ˜ã‚Šç•³ã¿çµ‚äº†</li>
          <li>å†…éƒ¨ã«Markdownè¨˜æ³•ã‚’ä½¿ç”¨å¯èƒ½</li>
        </ul>
        <h3 style="margin-top: 1rem;">è¦‹å‡ºã—æŠ˜ã‚Šç•³ã¿<span class="new-feature">NEW</span></h3>
        <ul>
          <li>ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è¦‹å‡ºã—ã‚’ã‚¯ãƒªãƒƒã‚¯ã§æŠ˜ã‚Šç•³ã¿</li>
          <li>ã€Œå…¨ã¦æŠ˜ã‚ŠãŸãŸã‚€ã€ã€Œå…¨ã¦å±•é–‹ã™ã‚‹ã€ãƒœã‚¿ãƒ³</li>
          <li>åŒãƒ¬ãƒ™ãƒ«ä»¥ä¸Šã®è¦‹å‡ºã—ã¾ã§æŠ˜ã‚Šç•³ã¿</li>
        </ul>
      </div>
      <button onclick="toggleHelp()">é–‰ã˜ã‚‹ (Esc)</button>
    </div>
  </div>
  
  <script>

// Vimã‚¨ãƒ‡ã‚£ã‚¿æ‹¡å¼µç‰ˆ

/**
 * Markdown Parser
 * ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’HTMLã«å¤‰æ›ã™ã‚‹ãƒ‘ãƒ¼ã‚µãƒ¼
 */
const MarkdownParser = {
  escapeHtml(text) {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  },
  
  parseInline(text) {
    let result = text;
    
    // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³æ•°å¼ $...$ ã‚’å‡¦ç†ï¼ˆ$$ã‚’é™¤å¤–ï¼‰
    result = result.replace(/(?<!\$)\$(?!\$)([^$\n]+?)\$(?!\$)/g, (match, formula) => {
      return `<span class="math-inline" data-math="${this.escapeHtml(formula)}"></span>`;
    });
    
    result = result.replace(/`([^`]+)`/g, '<code>$1</code>');
    result = result.replace(/~~([^~]+)~~/g, '<del>$1</del>');
    result = result.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    result = result.replace(/__([^_]+)__/g, '<strong>$1</strong>');
    result = result.replace(/\*([^*]+)\*/g, '<em>$1</em>');
    result = result.replace(/_([^_]+)_/g, '<em>$1</em>');
    result = result.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
    result = result.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1">');
    
    // è‡ªå‹•ãƒªãƒ³ã‚¯ï¼ˆURLã‚’è‡ªå‹•ã§ãƒªãƒ³ã‚¯åŒ–ï¼‰
    result = result.replace(/(?<!href="|src="|<a[^>]*>)(https?:\/\/[^\s<>"']+)/g, '<a href="$1">$1</a>');
    
    // çµµæ–‡å­—ã‚·ãƒ§ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰
    result = this.parseEmoji(result);
    
    return result;
  },
  
  // çµµæ–‡å­—å¤‰æ›
  parseEmoji(text) {
    const emojiMap = {
      ':smile:': 'ğŸ˜„', ':laughing:': 'ğŸ˜†', ':blush:': 'ğŸ˜Š', ':smiley:': 'ğŸ˜ƒ',
      ':relaxed:': 'â˜ºï¸', ':smirk:': 'ğŸ˜', ':heart_eyes:': 'ğŸ˜', ':kissing_heart:': 'ğŸ˜˜',
      ':kissing:': 'ğŸ˜—', ':flushed:': 'ğŸ˜³', ':relieved:': 'ğŸ˜Œ', ':satisfied:': 'ğŸ˜†',
      ':grin:': 'ğŸ˜', ':wink:': 'ğŸ˜‰', ':stuck_out_tongue_winking_eye:': 'ğŸ˜œ',
      ':stuck_out_tongue:': 'ğŸ˜›', ':sleeping:': 'ğŸ˜´', ':worried:': 'ğŸ˜Ÿ',
      ':frowning:': 'ğŸ˜¦', ':anguished:': 'ğŸ˜§', ':open_mouth:': 'ğŸ˜®', ':grimacing:': 'ğŸ˜¬',
      ':confused:': 'ğŸ˜•', ':hushed:': 'ğŸ˜¯', ':expressionless:': 'ğŸ˜‘', ':unamused:': 'ğŸ˜’',
      ':sweat_smile:': 'ğŸ˜…', ':sweat:': 'ğŸ˜“', ':weary:': 'ğŸ˜©', ':pensive:': 'ğŸ˜”',
      ':disappointed:': 'ğŸ˜', ':confounded:': 'ğŸ˜–', ':fearful:': 'ğŸ˜¨', ':cold_sweat:': 'ğŸ˜°',
      ':persevere:': 'ğŸ˜£', ':cry:': 'ğŸ˜¢', ':sob:': 'ğŸ˜­', ':joy:': 'ğŸ˜‚', ':astonished:': 'ğŸ˜²',
      ':scream:': 'ğŸ˜±', ':tired_face:': 'ğŸ˜«', ':angry:': 'ğŸ˜ ', ':rage:': 'ğŸ˜¡',
      ':triumph:': 'ğŸ˜¤', ':sleepy:': 'ğŸ˜ª', ':yum:': 'ğŸ˜‹', ':mask:': 'ğŸ˜·',
      ':sunglasses:': 'ğŸ˜', ':dizzy_face:': 'ğŸ˜µ', ':imp:': 'ğŸ‘¿', ':smiling_imp:': 'ğŸ˜ˆ',
      ':neutral_face:': 'ğŸ˜', ':no_mouth:': 'ğŸ˜¶', ':innocent:': 'ğŸ˜‡', ':alien:': 'ğŸ‘½',
      ':heart:': 'â¤ï¸', ':broken_heart:': 'ğŸ’”', ':star:': 'â­', ':star2:': 'ğŸŒŸ',
      ':sparkles:': 'âœ¨', ':zap:': 'âš¡', ':fire:': 'ğŸ”¥', ':boom:': 'ğŸ’¥',
      ':+1:': 'ğŸ‘', ':thumbsup:': 'ğŸ‘', ':-1:': 'ğŸ‘', ':thumbsdown:': 'ğŸ‘',
      ':ok_hand:': 'ğŸ‘Œ', ':punch:': 'ğŸ‘Š', ':fist:': 'âœŠ', ':v:': 'âœŒï¸',
      ':wave:': 'ğŸ‘‹', ':hand:': 'âœ‹', ':clap:': 'ğŸ‘', ':pray:': 'ğŸ™',
      ':point_up:': 'â˜ï¸', ':point_down:': 'ğŸ‘‡', ':point_left:': 'ğŸ‘ˆ', ':point_right:': 'ğŸ‘‰',
      ':rocket:': 'ğŸš€', ':warning:': 'âš ï¸', ':x:': 'âŒ', ':white_check_mark:': 'âœ…',
      ':heavy_check_mark:': 'âœ”ï¸', ':question:': 'â“', ':exclamation:': 'â—',
      ':bulb:': 'ğŸ’¡', ':memo:': 'ğŸ“', ':book:': 'ğŸ“–', ':bookmark:': 'ğŸ”–',
      ':link:': 'ğŸ”—', ':wrench:': 'ğŸ”§', ':hammer:': 'ğŸ”¨', ':nut_and_bolt:': 'ğŸ”©',
      ':gear:': 'âš™ï¸', ':package:': 'ğŸ“¦', ':tada:': 'ğŸ‰', ':100:': 'ğŸ’¯',
      ':bug:': 'ğŸ›', ':construction:': 'ğŸš§', ':rotating_light:': 'ğŸš¨',
      ':lock:': 'ğŸ”’', ':unlock:': 'ğŸ”“', ':key:': 'ğŸ”‘', ':mag:': 'ğŸ”',
      ':email:': 'ğŸ“§', ':phone:': 'ğŸ“±', ':computer:': 'ğŸ’»', ':desktop_computer:': 'ğŸ–¥ï¸',
      ':folder:': 'ğŸ“', ':file_folder:': 'ğŸ“‚', ':clipboard:': 'ğŸ“‹',
      ':calendar:': 'ğŸ“…', ':clock:': 'ğŸ•', ':hourglass:': 'âŒ›',
      ':sun:': 'â˜€ï¸', ':moon:': 'ğŸŒ™', ':cloud:': 'â˜ï¸', ':umbrella:': 'â˜‚ï¸',
      ':snowflake:': 'â„ï¸', ':coffee:': 'â˜•', ':beer:': 'ğŸº', ':pizza:': 'ğŸ•'
    };
    
    return text.replace(/:([a-z0-9_+-]+):/g, (match, code) => {
      return emojiMap[match] || match;
    });
  },
  
  parse(markdown) {
    const lines = markdown.split('\n');
    const html = [];
    let inCodeBlock = false;
    let inMathBlock = false;
    let mathBuffer = [];
    let inList = null;
    let tableRows = [];
    let codeLang = '';
    let codeBuffer = [];
    let inDetails = false;
    let detailsBuffer = [];
    let detailsSummary = '';
    let blockquoteBuffer = [];
    let alertType = null;
    let inNote = false;
    let noteType = '';
    let noteBuffer = [];
    
    for (const line of lines) {
      // æŠ˜ã‚Šç•³ã¿é–‹å§‹ :::details ã‚¿ã‚¤ãƒˆãƒ«
      const detailsStart = line.match(/^:::details\s*(.*)$/);
      if (detailsStart && !inCodeBlock && !inMathBlock) {
        if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
        inDetails = true;
        detailsSummary = detailsStart[1] || 'è©³ç´°';
        detailsBuffer = [];
        continue;
      }
      
      // æŠ˜ã‚Šç•³ã¿çµ‚äº† :::
      if (line.trim() === ':::' && inDetails && !inCodeBlock && !inMathBlock) {
        const innerHtml = this.parse(detailsBuffer.join('\n'));
        html.push(`<details class="collapsible"><summary>${this.parseInline(detailsSummary)}</summary><div class="details-content">${innerHtml}</div></details>`);
        inDetails = false;
        detailsBuffer = [];
        detailsSummary = '';
        continue;
      }
      
      // æŠ˜ã‚Šç•³ã¿å†…éƒ¨
      if (inDetails) {
        detailsBuffer.push(line);
        continue;
      }
      
      // Qiita noteè¨˜æ³•é–‹å§‹ :::note [info|warn|alert]
      const noteStart = line.match(/^:::note\s*(info|warn|alert)?$/i);
      if (noteStart && !inCodeBlock && !inMathBlock && !inNote) {
        if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
        inNote = true;
        noteType = (noteStart[1] || 'info').toLowerCase();
        noteBuffer = [];
        continue;
      }
      
      // Qiita noteçµ‚äº† :::
      if (line.trim() === ':::' && inNote && !inCodeBlock && !inMathBlock) {
        const innerHtml = this.parse(noteBuffer.join('\n'));
        const noteIcons = { 'info': 'âœ…', 'warn': 'âš ï¸', 'alert': 'ğŸš«' };
        html.push(`<div class="note note-${noteType}"><span class="note-icon">${noteIcons[noteType]}</span><div class="note-content">${innerHtml}</div></div>`);
        inNote = false;
        noteBuffer = [];
        noteType = '';
        continue;
      }
      
      // noteå†…éƒ¨
      if (inNote) {
        noteBuffer.push(line);
        continue;
      }
      
      // ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯
      if (line.startsWith('```')) {
        if (inCodeBlock) {
          // Mermaidãƒ–ãƒ­ãƒƒã‚¯ã®å ´åˆ
          if (codeLang === 'mermaid') {
            const mermaidCode = codeBuffer.join('\n');
            html.push(`<div class="mermaid">${mermaidCode}</div>`);
          } else {
            html.push('</code></pre>');
          }
          codeBuffer = [];
          inCodeBlock = false;
        } else {
          codeLang = line.slice(3).trim() || 'text';
          if (codeLang !== 'mermaid') {
            html.push(`<pre><code class="language-${codeLang}">`);
          }
          inCodeBlock = true;
        }
        continue;
      }
      
      if (inCodeBlock) {
        if (codeLang === 'mermaid') {
          codeBuffer.push(line);
        } else {
          html.push(this.escapeHtml(line));
          html.push('\n');
        }
        continue;
      }
      
      // æ•°å¼ãƒ–ãƒ­ãƒƒã‚¯ $$...$$ 
      if (line.trim() === '$$') {
        if (inMathBlock) {
          const formula = mathBuffer.join('\n');
          html.push(`<div class="math-block" data-math="${this.escapeHtml(formula)}"></div>`);
          mathBuffer = [];
          inMathBlock = false;
        } else {
          if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
          inMathBlock = true;
        }
        continue;
      }
      
      // 1è¡Œã®æ•°å¼ãƒ–ãƒ­ãƒƒã‚¯ $$...$$
      const singleLineMath = line.match(/^\$\$(.+)\$\$$/);
      if (singleLineMath) {
        if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
        html.push(`<div class="math-block" data-math="${this.escapeHtml(singleLineMath[1])}"></div>`);
        continue;
      }
      
      if (inMathBlock) {
        mathBuffer.push(line);
        continue;
      }
      
      // è¦‹å‡ºã—
      const headingMatch = line.match(/^(#{1,6})\s+(.+)$/);
      if (headingMatch) {
        if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
        const level = headingMatch[1].length;
        html.push(`<h${level}>${this.parseInline(headingMatch[2])}</h${level}>`);
        continue;
      }
      
      // æ°´å¹³ç·š
      if (/^(---|\*\*\*|___)$/.test(line.trim())) {
        if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
        html.push('<hr>');
        continue;
      }
      
      // å¼•ç”¨ï¼ˆè¤‡æ•°è¡Œå¯¾å¿œ + GitHub Alertsï¼‰
      if (line.startsWith('>')) {
        if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
        if (tableRows.length > 0) { html.push(this.parseTable(tableRows)); tableRows = []; }
        
        const content = line.slice(1).trim();
        
        // GitHub Alerts ã®ãƒã‚§ãƒƒã‚¯
        const alertMatch = content.match(/^\[!(NOTE|TIP|IMPORTANT|WARNING|CAUTION)\]$/i);
        if (alertMatch && blockquoteBuffer.length === 0) {
          alertType = alertMatch[1].toUpperCase();
          blockquoteBuffer.push('');
          continue;
        }
        
        blockquoteBuffer.push(content);
        continue;
      } else if (blockquoteBuffer.length > 0) {
        // å¼•ç”¨ãƒ–ãƒ­ãƒƒã‚¯ã‚’å‡ºåŠ›
        const content = blockquoteBuffer.filter(l => l).map(l => this.parseInline(l)).join('<br>');
        if (alertType) {
          const alertIcons = {
            'NOTE': 'â„¹ï¸',
            'TIP': 'ğŸ’¡', 
            'IMPORTANT': 'â—',
            'WARNING': 'âš ï¸',
            'CAUTION': 'ğŸ”´'
          };
          html.push(`<div class="alert alert-${alertType.toLowerCase()}"><span class="alert-title">${alertIcons[alertType]} ${alertType}</span><p>${content}</p></div>`);
        } else {
          html.push(`<blockquote>${content}</blockquote>`);
        }
        blockquoteBuffer = [];
        alertType = null;
      }
      
      // ãƒ†ãƒ¼ãƒ–ãƒ«è¡Œã®æ¤œå‡º
      if (line.trim().startsWith('|') && line.trim().endsWith('|')) {
        if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
        tableRows.push(line);
        continue;
      } else if (tableRows.length > 0) {
        html.push(this.parseTable(tableRows));
        tableRows = [];
      }
      
      // ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆï¼ˆãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ï¼‰
      const taskMatch = line.match(/^[-*+]\s+\[([ xX])\]\s+(.+)$/);
      if (taskMatch) {
        if (inList !== 'ul') {
          if (inList) html.push('</ol>');
          html.push('<ul class="task-list">');
          inList = 'ul';
        }
        const checked = taskMatch[1].toLowerCase() === 'x' ? 'checked' : '';
        html.push(`<li class="task-item"><input type="checkbox" ${checked} disabled>${this.parseInline(taskMatch[2])}</li>`);
        continue;
      }
      
      // é †åºãªã—ãƒªã‚¹ãƒˆ
      const ulMatch = line.match(/^[-*+]\s+(.+)$/);
      if (ulMatch) {
        if (inList !== 'ul') {
          if (inList) html.push('</ol>');
          html.push('<ul>');
          inList = 'ul';
        }
        html.push(`<li>${this.parseInline(ulMatch[1])}</li>`);
        continue;
      }
      
      // é †åºã‚ã‚Šãƒªã‚¹ãƒˆ
      const olMatch = line.match(/^\d+\.\s+(.+)$/);
      if (olMatch) {
        if (inList !== 'ol') {
          if (inList) html.push('</ul>');
          html.push('<ol>');
          inList = 'ol';
        }
        html.push(`<li>${this.parseInline(olMatch[1])}</li>`);
        continue;
      }
      
      // ç©ºè¡Œ
      if (line.trim() === '') {
        if (inList) {
          html.push(inList === 'ol' ? '</ol>' : '</ul>');
          inList = null;
        }
        if (tableRows.length > 0) {
          html.push(this.parseTable(tableRows));
          tableRows = [];
        }
        continue;
      }
      
      // é€šå¸¸ã®ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•
      if (inList) { html.push(inList === 'ol' ? '</ol>' : '</ul>'); inList = null; }
      if (tableRows.length > 0) { html.push(this.parseTable(tableRows)); tableRows = []; }
      html.push(`<p>${this.parseInline(line)}</p>`);
    }
    
    // é–‰ã˜ã‚¿ã‚°ã®å‡¦ç†
    if (inList) html.push(inList === 'ol' ? '</ol>' : '</ul>');
    if (inCodeBlock) html.push('</code></pre>');
    if (tableRows.length > 0) html.push(this.parseTable(tableRows));
    if (blockquoteBuffer.length > 0) {
      const content = blockquoteBuffer.filter(l => l).map(l => this.parseInline(l)).join('<br>');
      if (alertType) {
        const alertIcons = { 'NOTE': 'â„¹ï¸', 'TIP': 'ğŸ’¡', 'IMPORTANT': 'â—', 'WARNING': 'âš ï¸', 'CAUTION': 'ğŸ”´' };
        html.push(`<div class="alert alert-${alertType.toLowerCase()}"><span class="alert-title">${alertIcons[alertType]} ${alertType}</span><p>${content}</p></div>`);
      } else {
        html.push(`<blockquote>${content}</blockquote>`);
      }
    }
    
    return html.join('\n');
  },
  
  parseTable(rows) {
    if (rows.length < 2) return '';
    
    const parseRow = (row) => {
      return row.trim()
        .replace(/^\|/, '')
        .replace(/\|$/, '')
        .split('|')
        .map(cell => cell.trim());
    };
    
    const headerCells = parseRow(rows[0]);
    
    // 2è¡Œç›®ãŒåŒºåˆ‡ã‚Šè¡Œã‹ãƒã‚§ãƒƒã‚¯
    const separatorRow = rows[1].trim();
    if (!/^\|[\s\-:|]+\|$/.test(separatorRow)) {
      return rows.map(row => `<p>${this.parseInline(row)}</p>`).join('\n');
    }
    
    // ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã‚’è§£æ
    const alignments = parseRow(rows[1]).map(cell => {
      if (cell.startsWith(':') && cell.endsWith(':')) return 'center';
      if (cell.endsWith(':')) return 'right';
      return 'left';
    });
    
    let html = '<table><thead><tr>';
    headerCells.forEach((cell, i) => {
      const align = alignments[i] || 'left';
      html += `<th style="text-align: ${align}">${this.parseInline(cell)}</th>`;
    });
    html += '</tr></thead><tbody>';
    
    // ãƒ‡ãƒ¼ã‚¿è¡Œ
    for (let i = 2; i < rows.length; i++) {
      const cells = parseRow(rows[i]);
      html += '<tr>';
      cells.forEach((cell, j) => {
        const align = alignments[j] || 'left';
        html += `<td style="text-align: ${align}">${this.parseInline(cell)}</td>`;
      });
      html += '</tr>';
    }
    
    html += '</tbody></table>';
    return html;
  }
};

const VimEditor = {
  mode: 'normal',
  register: '',
  searchTerm: '',
  undoStack: [],
  redoStack: [],
  visualStart: null,
  visualLine: false,
  count: '',
  pendingKey: '',
  pendingOperator: '',
  modified: false,
  
  // æ–°æ©Ÿèƒ½ç”¨ã®çŠ¶æ…‹
  marks: {},                    // ãƒãƒ¼ã‚¯
  macros: {},                   // ãƒã‚¯ãƒ­
  recordingMacro: null,         // è¨˜éŒ²ä¸­ã®ãƒã‚¯ãƒ­å
  macroBuffer: [],              // ãƒã‚¯ãƒ­è¨˜éŒ²ãƒãƒƒãƒ•ã‚¡
  lastMacro: null,              // æœ€å¾Œã«å®Ÿè¡Œã—ãŸãƒã‚¯ãƒ­
  lastFindChar: null,           // f/F/t/T ã®æœ€å¾Œã®æ–‡å­—
  lastFindDirection: 1,         // 1: forward, -1: backward
  lastFindType: 'f',            // 'f' or 't'
  lastEdit: null,               // ãƒ‰ãƒƒãƒˆãƒªãƒ”ãƒ¼ãƒˆç”¨
  lastEditText: '',             // æŒ¿å…¥ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆ
  previousPosition: null,       // '' ã‚¸ãƒ£ãƒ³ãƒ—ç”¨
  currentFileName: 'ç„¡é¡Œ',      // ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«å
  fileInsertMode: false,        // ãƒ•ã‚¡ã‚¤ãƒ«æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰
  currentFileHandle: null,      // File System Access APIç”¨
  
  init() {
    this.editor = document.getElementById('editor');
    this.preview = document.getElementById('preview-content');
    this.modeIndicator = document.getElementById('vim-mode');
    this.cursorPos = document.getElementById('cursor-pos');
    this.commandLine = document.getElementById('command-line');
    this.commandInput = document.getElementById('command-input');
    this.commandPrefix = document.getElementById('command-prefix');
    this.lineNumbers = document.getElementById('line-numbers');
    this.fileStatus = document.getElementById('file-status');
    this.fileName = document.getElementById('file-name');
    this.macroIndicator = document.getElementById('macro-indicator');
    this.cursorOverlay = document.getElementById('cursor-overlay');
    this.fileInput = document.getElementById('file-input');
    this.fontSizeDisplay = document.getElementById('font-size-display');
    
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³IDï¼ˆã‚¿ãƒ–ã”ã¨ã«ç‹¬ç«‹ï¼‰
    this.sessionId = sessionStorage.getItem('vim-md-session-id');
    if (!this.sessionId) {
      this.sessionId = 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      sessionStorage.setItem('vim-md-session-id', this.sessionId);
    }
    
    // ç›®æ¬¡ãƒ‘ãƒãƒ«
    this.tocPane = document.getElementById('toc-pane');
    this.tocContent = document.getElementById('toc-content');
    this.tocOpenBtn = document.getElementById('toc-open-btn');
    this.tocVisible = true;
    
    // è¦‹å‡ºã—ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
    this.headingHighlight = document.createElement('div');
    this.headingHighlight.id = 'heading-highlight';
    document.getElementById('editor-wrapper').appendChild(this.headingHighlight);
    
    // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºï¼ˆ%ï¼‰- ã“ã‚Œã¯å…¨ã‚¿ãƒ–å…±é€šã§OK
    this.fontSize = parseInt(localStorage.getItem('vim-md-font-size')) || 100;
    this.applyFontSize();
    
    // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã®ã‚¤ãƒ™ãƒ³ãƒˆ
    this.fileInput.addEventListener('change', e => this.handleFileOpen(e));
    
    // ã‚«ãƒ¼ã‚½ãƒ«è¨ˆæ¸¬ç”¨ã®éš ã—è¦ç´ 
    this.measureSpan = document.createElement('span');
    this.measureSpan.style.cssText = `
      position: absolute;
      visibility: hidden;
      white-space: pre;
      font-family: inherit;
      font-size: 0.95rem;
      line-height: 1.5;
    `;
    document.body.appendChild(this.measureSpan);
    
    this.setupEventListeners();
    this.loadFromStorage();
    this.updateLineNumbers();
    this.updatePreview();
    this.updateToc();
    this.updateHeadingHighlight();
    this.saveState();
    this.updateCursorOverlay();
    this.initialized = true;
  },
  
  setupEventListeners() {
    this.editor.addEventListener('keydown', e => this.handleKeydown(e));
    this.editor.addEventListener('input', e => this.onInput(e));
    this.editor.addEventListener('click', () => this.updateCursorPos());
    this.editor.addEventListener('scroll', () => this.syncScroll());
    this.commandInput.addEventListener('keydown', e => this.handleCommandKey(e));
    
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape' && !document.getElementById('help-modal').classList.contains('hidden')) {
        toggleHelp();
      }
    });
    
    this.editor.addEventListener('scroll', () => {
      this.lineNumbers.scrollTop = this.editor.scrollTop;
      this.updateCursorOverlay();
      this.updateHeadingHighlight();
    });
  },
  
  loadFromStorage() {
    // ã¾ãšã‚»ãƒƒã‚·ãƒ§ãƒ³å›ºæœ‰ã®å†…å®¹ã‚’æ¢ã™
    const sessionContent = sessionStorage.getItem('vim-md-content-' + this.sessionId);
    if (sessionContent) {
      this.editor.value = sessionContent;
      return;
    }
    
    // ãªã‘ã‚Œã°å¾“æ¥ã®localStorageã‹ã‚‰èª­ã¿è¾¼ã¿ï¼ˆåˆå›èµ·å‹•æ™‚ï¼‰
    const saved = localStorage.getItem('vim-md-content');
    if (saved) {
      this.editor.value = saved;
    } else {
      this.editor.value = `# mdvim v0.1 ã¸ã‚ˆã†ã“ãï¼

**mdvim** ã¯ Vimé¢¨ã®Markdownã‚¨ãƒ‡ã‚£ã‚¿ã§ã™ã€‚

## ä¸»ãªæ©Ÿèƒ½

### Vimæ“ä½œ
- \`h\`/\`j\`/\`k\`/\`l\` ã§ã‚«ãƒ¼ã‚½ãƒ«ç§»å‹•
- \`i\`/\`a\`/\`o\` ã§æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰
- \`dd\`/\`yy\`/\`p\` ã§å‰Šé™¤ãƒ»ã‚³ãƒ”ãƒ¼ãƒ»è²¼ã‚Šä»˜ã‘
- \`u\`/\`Ctrl+r\` ã§ã‚¢ãƒ³ãƒ‰ã‚¥ãƒ»ãƒªãƒ‰ã‚¥

### æ¤œç´¢ãƒ»ç½®æ›
- \`/pattern\` ã§æ¤œç´¢
- \`:s/old/new/g\` ã§ç½®æ›
- \`:%s/old/new/g\` ã§å…¨ç½®æ›

### ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ
- \`:w\` ã§ä¿å­˜ãƒ€ã‚¤ã‚¢ãƒ­ã‚°
- \`:e\` ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
- \`:new\` ã§æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«

### æ•°å¼ï¼ˆLaTeXï¼‰

ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³: $E = mc^2$

ãƒ–ãƒ­ãƒƒã‚¯:
$$
\\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}
$$

### ãƒ†ãƒ¼ãƒ–ãƒ«

| ã‚­ãƒ¼ | å‹•ä½œ |
|:-----|:-----|
| \`h\` | å·¦ã¸ç§»å‹• |
| \`j\` | ä¸‹ã¸ç§»å‹• |
| \`k\` | ä¸Šã¸ç§»å‹• |
| \`l\` | å³ã¸ç§»å‹• |

### Mermaidå›³

\`\`\`mermaid
graph LR
    A[mdvim] --> B[Vimæ“ä½œ]
    A --> C[Markdown]
    A --> D[ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼]
\`\`\`

### ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ

- [x] Vimæ“ä½œ
- [x] Markdownãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
- [x] æ•°å¼ã‚µãƒãƒ¼ãƒˆ
- [x] Mermaidå›³
- [ ] ã•ã‚‰ã«æ©Ÿèƒ½è¿½åŠ äºˆå®š

### GitHub Alerts

> [!NOTE]
> ã“ã‚Œã¯è£œè¶³æƒ…å ±ã§ã™ã€‚

> [!WARNING]
> ã“ã‚Œã¯è­¦å‘Šã§ã™ã€‚

### Qiita Noteè¨˜æ³•

:::note info
ã‚¤ãƒ³ãƒ•ã‚©ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
:::

:::note warn
è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
:::

### çµµæ–‡å­—

:smile: :rocket: :star: :+1:

---

\`?\` ã‚­ãƒ¼ã§ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º
`;
    }
  },
  
  // ãƒã‚¯ãƒ­è¨˜éŒ²
  recordKey(key, e) {
    if (this.recordingMacro && key !== 'q') {
      this.macroBuffer.push({ key, ctrlKey: e?.ctrlKey, shiftKey: e?.shiftKey });
    }
  },
  
  handleKeydown(e) {
    // Ctrl+[ ã‚’ESCã¨ã—ã¦æ‰±ã†
    if (e.ctrlKey && e.key === '[') {
      e.preventDefault();
      if (this.mode === 'insert') {
        this.exitInsertMode();
      } else if (this.mode === 'visual') {
        this.setMode('normal');
        this.editor.selectionEnd = this.editor.selectionStart;
      }
      return;
    }
    
    if (this.mode === 'insert') {
      if (e.key === 'Escape') {
        e.preventDefault();
        this.exitInsertMode();
      } else if (e.key === 'Tab') {
        e.preventDefault();
        this.handleTab(e.shiftKey);
      }
      return;
    }
    
    if (this.mode === 'visual') {
      e.preventDefault();
      this.handleVisualMode(e);
      return;
    }
    
    e.preventDefault();
    this.handleNormalMode(e);
  },
  
  // ã‚¿ãƒ–ã‚­ãƒ¼å‡¦ç†ï¼ˆã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ/ã‚¢ãƒ³ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆï¼‰
  handleTab(isShift) {
    const text = this.editor.value;
    const start = this.editor.selectionStart;
    const end = this.editor.selectionEnd;
    const tabChar = '  '; // 2ã‚¹ãƒšãƒ¼ã‚¹ã‚’ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã¨ã—ã¦ä½¿ç”¨
    
    // é¸æŠç¯„å›²ãŒãªã„å ´åˆ
    if (start === end) {
      if (isShift) {
        // Shift+Tab: ç¾åœ¨è¡Œã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™
        const lineStart = text.lastIndexOf('\n', start - 1) + 1;
        const lineText = text.substring(lineStart, start);
        
        if (lineText.startsWith(tabChar)) {
          this.editor.value = text.substring(0, lineStart) + text.substring(lineStart + tabChar.length);
          this.editor.selectionStart = this.editor.selectionEnd = start - tabChar.length;
        } else if (lineText.startsWith('\t')) {
          this.editor.value = text.substring(0, lineStart) + text.substring(lineStart + 1);
          this.editor.selectionStart = this.editor.selectionEnd = start - 1;
        }
      } else {
        // Tab: ã‚¿ãƒ–æ–‡å­—ã‚’æŒ¿å…¥
        this.editor.value = text.substring(0, start) + tabChar + text.substring(end);
        this.editor.selectionStart = this.editor.selectionEnd = start + tabChar.length;
      }
    } else {
      // é¸æŠç¯„å›²ãŒã‚ã‚‹å ´åˆ: è¤‡æ•°è¡Œã‚’ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ/ã‚¢ãƒ³ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
      const lineStart = text.lastIndexOf('\n', start - 1) + 1;
      const lineEnd = text.indexOf('\n', end);
      const actualEnd = lineEnd === -1 ? text.length : lineEnd;
      const selectedLines = text.substring(lineStart, actualEnd);
      const lines = selectedLines.split('\n');
      
      let newLines;
      if (isShift) {
        // ã‚¢ãƒ³ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
        newLines = lines.map(line => {
          if (line.startsWith(tabChar)) {
            return line.substring(tabChar.length);
          } else if (line.startsWith('\t')) {
            return line.substring(1);
          }
          return line;
        });
      } else {
        // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
        newLines = lines.map(line => tabChar + line);
      }
      
      const newText = newLines.join('\n');
      this.editor.value = text.substring(0, lineStart) + newText + text.substring(actualEnd);
      
      // é¸æŠç¯„å›²ã‚’ç¶­æŒ
      this.editor.selectionStart = lineStart;
      this.editor.selectionEnd = lineStart + newText.length;
    }
    
    this.modified = true;
    this.updateFileStatus();
    this.onInput();
  },
  
  exitInsertMode() {
    // æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰çµ‚äº†æ™‚ã®å‡¦ç†
    if (this.lastEdit && this.lastEdit.type === 'insert') {
      this.lastEdit.insertedText = this.lastEditText;
    }
    this.lastEditText = '';
    
    this.setMode('normal');
    if (this.editor.selectionStart > 0) {
      this.editor.selectionStart--;
      this.editor.selectionEnd = this.editor.selectionStart;
    }
  },
  
  handleNormalMode(e) {
    const key = e.key;
    
    this.recordKey(key, e);
    
    // æ•°å€¤ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹
    if (/^[1-9]$/.test(key) || (this.count && /^[0-9]$/.test(key))) {
      this.count += key;
      return;
    }
    
    const count = parseInt(this.count) || 1;
    this.count = '';
    
    // ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼å¾…ã¡çŠ¶æ…‹ï¼ˆd, c, y ã®å¾Œï¼‰
    if (this.pendingOperator) {
      this.handleOperatorPending(key, count, e);
      return;
    }
    
    // ä¿ç•™ä¸­ã®ã‚­ãƒ¼
    if (this.pendingKey) {
      this.handlePendingKey(key, count);
      return;
    }
    
    // Ctrlçµ„ã¿åˆã‚ã›
    if (e.ctrlKey) {
      switch(key) {
        case 'r': this.redo(); return;
        case 'd': this.scrollHalfPage(1); return;
        case 'u': this.scrollHalfPage(-1); return;
        case 'f': this.scrollFullPage(1); return;
        case 'b': this.scrollFullPage(-1); return;
      }
    }
    
    switch(key) {
      // ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
      case 'i': 
        this.setLastEdit('insert', this.editor.selectionStart);
        this.setMode('insert'); 
        break;
      case 'I': 
        this.moveToFirstNonSpace(); 
        this.setLastEdit('insert', this.editor.selectionStart);
        this.setMode('insert'); 
        break;
      case 'a': 
        if (this.editor.selectionStart < this.editor.value.length) {
          this.editor.selectionStart++;
          this.editor.selectionEnd = this.editor.selectionStart;
        }
        this.setLastEdit('insert', this.editor.selectionStart);
        this.setMode('insert'); 
        break;
      case 'A': 
        this.moveToLineEnd(); 
        this.setLastEdit('insert', this.editor.selectionStart);
        this.setMode('insert'); 
        break;
      case 'o': 
        this.saveState();
        this.moveToLineEnd(); 
        this.insertText('\n'); 
        this.setLastEdit('o');
        this.setMode('insert'); 
        break;
      case 'O': 
        this.saveState();
        this.moveToLineStart(); 
        this.insertText('\n'); 
        this.moveCursor(-1); 
        this.setLastEdit('O');
        this.setMode('insert'); 
        break;
      case 's':
        this.saveState();
        this.deleteChar();
        this.setLastEdit('s');
        this.setMode('insert');
        break;
      case 'S':
        this.saveState();
        this.deleteLineContent();
        this.setLastEdit('S');
        this.setMode('insert');
        break;
      case 'v': 
        this.setMode('visual'); 
        this.visualStart = this.editor.selectionStart; 
        this.visualLine = false; 
        break;
      case 'V': 
        this.setMode('visual'); 
        this.selectCurrentLine(); 
        this.visualLine = true; 
        break;
      case ':': 
        this.setMode('command'); 
        this.commandPrefix.textContent = ':'; 
        break;
      case '/': 
        this.setMode('command'); 
        this.commandPrefix.textContent = '/'; 
        break;
      case '?': 
        toggleHelp(); 
        break;
      
      // ç§»å‹•
      case 'h': case 'ArrowLeft': this.moveCursor(-count); break;
      case 'l': case 'ArrowRight': this.moveCursor(count); break;
      case 'j': case 'ArrowDown': for (let i = 0; i < count; i++) this.moveVertical(1); break;
      case 'k': case 'ArrowUp': for (let i = 0; i < count; i++) this.moveVertical(-1); break;
      case 'w': for (let i = 0; i < count; i++) this.moveWord(1); break;
      case 'b': for (let i = 0; i < count; i++) this.moveWord(-1); break;
      case 'e': for (let i = 0; i < count; i++) this.moveWordEnd(); break;
      case '0': this.moveToLineStart(); break;
      case '$': this.moveToLineEnd(); break;
      case '^': this.moveToFirstNonSpace(); break;
      case 'g': this.pendingKey = 'g'; break;
      case 'G': if (count > 1) this.gotoLine(count); else this.moveToEnd(); break;
      
      // è¡Œå†…æ¤œç´¢ (f/F/t/T)
      case 'f': this.pendingKey = 'f'; break;
      case 'F': this.pendingKey = 'F'; break;
      case 't': this.pendingKey = 't'; break;
      case 'T': this.pendingKey = 'T'; break;
      case ';': this.repeatFindChar(1); break;
      case ',': this.repeatFindChar(-1); break;
      
      // æ‹¬å¼§ã‚¸ãƒ£ãƒ³ãƒ—
      case '%': this.jumpToMatchingBracket(); break;
      
      // ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ç§»å‹•
      case '{': for (let i = 0; i < count; i++) this.moveParagraph(-1); break;
      case '}': for (let i = 0; i < count; i++) this.moveParagraph(1); break;
      
      // ãƒãƒ¼ã‚¯
      case 'm': this.pendingKey = 'm'; break;
      case "'": this.pendingKey = "'"; break;
      case '`': this.pendingKey = '`'; break;
      
      // ãƒã‚¯ãƒ­
      case 'q':
        if (this.recordingMacro) {
          this.stopRecordingMacro();
        } else {
          this.pendingKey = 'q_start';
        }
        break;
      case '@': this.pendingKey = '@'; break;
      
      // ç·¨é›†
      case 'x': 
        this.saveState(); 
        for (let i = 0; i < count; i++) this.deleteChar(); 
        this.setLastEdit('x', null, count);
        break;
      case 'X': 
        this.saveState(); 
        for (let i = 0; i < count; i++) this.deleteCharBefore(); 
        this.setLastEdit('X', null, count);
        break;
      case 'd': this.pendingOperator = 'd'; break;
      case 'D': 
        this.saveState(); 
        this.deleteToLineEnd(); 
        this.setLastEdit('D');
        break;
      case 'c': this.pendingOperator = 'c'; break;
      case 'C': 
        this.saveState(); 
        this.deleteToLineEnd(); 
        this.setLastEdit('C');
        this.setMode('insert'); 
        break;
      case 'y': this.pendingOperator = 'y'; break;
      case 'Y': this.yankLine(); break;
      case 'p': this.saveState(); this.paste(); break;
      case 'P': this.saveState(); this.pasteBefore(); break;
      case 'u': this.undo(); break;
      case 'J': this.saveState(); this.joinLines(); this.setLastEdit('J'); break;
      case 'r': this.pendingKey = 'r'; break;
      
      // ãƒ‰ãƒƒãƒˆãƒªãƒ”ãƒ¼ãƒˆ
      case '.': this.repeatLastEdit(count); break;
      
      // å¤§æ–‡å­—/å°æ–‡å­—åˆ‡æ›¿
      case '~': 
        this.saveState(); 
        for (let i = 0; i < count; i++) this.toggleCase(); 
        this.setLastEdit('~', null, count);
        break;
      
      // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
      case '>': this.pendingKey = '>'; break;
      case '<': this.pendingKey = '<'; break;
      
      // æ¤œç´¢
      case 'n': this.findNext(); break;
      case 'N': this.findPrev(); break;
      case '*': this.searchWordUnderCursor(); break;
    }
    
    this.updateCursorPos();
  },
  
  // ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼å¾…ã¡çŠ¶æ…‹ã®å‡¦ç† (d, c, y ã®å¾Œ)
  handleOperatorPending(key, count, e) {
    const op = this.pendingOperator;
    this.pendingOperator = '';
    
    // ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (i/a)
    if (key === 'i' || key === 'a') {
      this.pendingKey = op + key;  // ä¾‹: 'di', 'ca'
      return;
    }
    
    // ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã®é‡è¤‡ (dd, cc, yy)
    if (key === op) {
      this.saveState();
      if (op === 'd') {
        for (let i = 0; i < count; i++) this.deleteLine();
        this.setLastEdit('dd', null, count);
      } else if (op === 'c') {
        this.deleteLineContent();
        this.setLastEdit('cc', null, count);
        this.setMode('insert');
      } else if (op === 'y') {
        this.yankLine();
      }
      return;
    }
    
    // ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³
    this.saveState();
    const startPos = this.editor.selectionStart;
    
    switch(key) {
      case 'w':
        for (let i = 0; i < count; i++) this.moveWord(1);
        break;
      case 'b':
        for (let i = 0; i < count; i++) this.moveWord(-1);
        break;
      case 'e':
        for (let i = 0; i < count; i++) this.moveWordEnd();
        this.editor.selectionStart++;
        this.editor.selectionEnd++;
        break;
      case '$':
        this.moveToLineEnd();
        break;
      case '0':
        this.moveToLineStart();
        break;
      case '^':
        this.moveToFirstNonSpace();
        break;
      case 'G':
        this.moveToEnd();
        break;
      case '{':
        this.moveParagraph(-1);
        break;
      case '}':
        this.moveParagraph(1);
        break;
      case 'g':
        this.pendingKey = op + 'g';
        return;
      default:
        return;
    }
    
    const endPos = this.editor.selectionStart;
    const start = Math.min(startPos, endPos);
    const end = Math.max(startPos, endPos);
    
    this.applyOperator(op, start, end, key, count);
    this.updateCursorPos();
  },
  
  applyOperator(op, start, end, motion, count) {
    const text = this.editor.value.substring(start, end);
    
    if (op === 'y') {
      this.register = text;
      this.editor.selectionStart = start;
      this.editor.selectionEnd = start;
      this.showStatus('ãƒ¤ãƒ³ã‚¯ã—ã¾ã—ãŸ');
    } else if (op === 'd') {
      this.register = text;
      this.editor.value = this.editor.value.substring(0, start) + this.editor.value.substring(end);
      this.editor.selectionStart = start;
      this.editor.selectionEnd = start;
      this.setLastEdit('d' + motion, null, count);
      this.onInput();
    } else if (op === 'c') {
      this.register = text;
      this.editor.value = this.editor.value.substring(0, start) + this.editor.value.substring(end);
      this.editor.selectionStart = start;
      this.editor.selectionEnd = start;
      this.setLastEdit('c' + motion, null, count);
      this.setMode('insert');
      this.onInput();
    }
  },
  
  handlePendingKey(key, count) {
    const pending = this.pendingKey;
    this.pendingKey = '';
    
    switch(pending) {
      case 'g':
        if (key === 'g') this.moveToStart();
        break;
        
      case 'd':
        this.saveState();
        if (key === 'd') { for (let i = 0; i < count; i++) this.deleteLine(); this.setLastEdit('dd', null, count); }
        else if (key === 'w') { this.deleteWord(); this.setLastEdit('dw'); }
        else if (key === '$') { this.deleteToLineEnd(); this.setLastEdit('d$'); }
        else if (key === '0') { this.deleteToLineStart(); this.setLastEdit('d0'); }
        break;
        
      case 'y':
        if (key === 'y') this.yankLine();
        else if (key === 'w') this.yankWord();
        break;
        
      case 'c':
        this.saveState();
        if (key === 'c') { this.deleteLineContent(); this.setLastEdit('cc'); this.setMode('insert'); }
        else if (key === 'w') { this.deleteWord(); this.setLastEdit('cw'); this.setMode('insert'); }
        break;
        
      case 'r':
        if (key.length === 1) {
          this.saveState();
          this.replaceChar(key);
          this.setLastEdit('r', key);
        }
        break;
        
      // è¡Œå†…æ¤œç´¢
      case 'f':
        if (key.length === 1) {
          this.findCharInLine(key, 1, false);
          this.lastFindChar = key;
          this.lastFindDirection = 1;
          this.lastFindType = 'f';
        }
        break;
      case 'F':
        if (key.length === 1) {
          this.findCharInLine(key, -1, false);
          this.lastFindChar = key;
          this.lastFindDirection = -1;
          this.lastFindType = 'f';
        }
        break;
      case 't':
        if (key.length === 1) {
          this.findCharInLine(key, 1, true);
          this.lastFindChar = key;
          this.lastFindDirection = 1;
          this.lastFindType = 't';
        }
        break;
      case 'T':
        if (key.length === 1) {
          this.findCharInLine(key, -1, true);
          this.lastFindChar = key;
          this.lastFindDirection = -1;
          this.lastFindType = 't';
        }
        break;
        
      // ãƒãƒ¼ã‚¯
      case 'm':
        if (/^[a-z]$/.test(key)) {
          this.marks[key] = this.editor.selectionStart;
          this.showStatus(`ãƒãƒ¼ã‚¯ '${key}' ã‚’è¨­å®š`);
        }
        break;
      case "'":
        if (key === "'") {
          // '' ã§ç›´å‰ä½ç½®ã¸
          if (this.previousPosition !== null) {
            const current = this.editor.selectionStart;
            this.gotoPosition(this.previousPosition);
            this.previousPosition = current;
            this.moveToFirstNonSpace();
          }
        } else if (/^[a-z]$/.test(key) && this.marks[key] !== undefined) {
          this.previousPosition = this.editor.selectionStart;
          this.gotoPosition(this.marks[key]);
          this.moveToFirstNonSpace();
        }
        break;
      case '`':
        if (/^[a-z]$/.test(key) && this.marks[key] !== undefined) {
          this.previousPosition = this.editor.selectionStart;
          this.gotoPosition(this.marks[key]);
        }
        break;
        
      // ãƒã‚¯ãƒ­
      case 'q_start':
        if (/^[a-z]$/.test(key)) {
          this.startRecordingMacro(key);
        }
        break;
      case '@':
        if (key === '@' && this.lastMacro) {
          this.playMacro(this.lastMacro);
        } else if (/^[a-z]$/.test(key) && this.macros[key]) {
          this.playMacro(key);
        }
        break;
        
      // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
      case '>':
        if (key === '>') {
          this.saveState();
          for (let i = 0; i < count; i++) this.indentLine(1);
          this.setLastEdit('>>', null, count);
        }
        break;
      case '<':
        if (key === '<') {
          this.saveState();
          for (let i = 0; i < count; i++) this.indentLine(-1);
          this.setLastEdit('<<', null, count);
        }
        break;
        
      // ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (di, da, ci, ca, yi, ya)
      case 'di': case 'da': case 'ci': case 'ca': case 'yi': case 'ya':
        this.handleTextObject(pending, key);
        break;
        
      // dg, cg, yg
      case 'dg':
        if (key === 'g') {
          this.saveState();
          const pos = this.editor.selectionStart;
          this.register = this.editor.value.substring(0, pos);
          this.editor.value = this.editor.value.substring(pos);
          this.editor.selectionStart = 0;
          this.editor.selectionEnd = 0;
          this.onInput();
        }
        break;
    }
    
    this.updateCursorPos();
  },
  
  // ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‡¦ç†
  handleTextObject(opType, objChar) {
    const op = opType[0];  // 'd', 'c', 'y'
    const inner = opType[1] === 'i';  // true: inner, false: around
    
    let range = null;
    
    switch(objChar) {
      case 'w':
        range = this.getWordRange(inner);
        break;
      case '"':
      case "'":
      case '`':
        range = this.getQuoteRange(objChar, inner);
        break;
      case '(':
      case ')':
      case 'b':
        range = this.getBracketRange('(', ')', inner);
        break;
      case '[':
      case ']':
        range = this.getBracketRange('[', ']', inner);
        break;
      case '{':
      case '}':
      case 'B':
        range = this.getBracketRange('{', '}', inner);
        break;
      case '<':
      case '>':
        range = this.getBracketRange('<', '>', inner);
        break;
    }
    
    if (range) {
      this.saveState();
      const text = this.editor.value.substring(range.start, range.end);
      
      if (op === 'y') {
        this.register = text;
        this.showStatus('ãƒ¤ãƒ³ã‚¯ã—ã¾ã—ãŸ');
      } else {
        this.register = text;
        this.editor.value = this.editor.value.substring(0, range.start) + this.editor.value.substring(range.end);
        this.editor.selectionStart = range.start;
        this.editor.selectionEnd = range.start;
        this.setLastEdit(opType + objChar);
        
        if (op === 'c') {
          this.setMode('insert');
        }
        this.onInput();
      }
    }
  },
  
  getWordRange(inner) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    let start = pos;
    let end = pos;
    
    // å˜èªã®å¢ƒç•Œã‚’è¦‹ã¤ã‘ã‚‹
    while (start > 0 && /\w/.test(text[start - 1])) start--;
    while (end < text.length && /\w/.test(text[end])) end++;
    
    if (!inner) {
      // around: å¾Œç¶šã®ç©ºç™½ã‚‚å«ã‚ã‚‹
      while (end < text.length && /\s/.test(text[end]) && text[end] !== '\n') end++;
    }
    
    if (start === end) return null;
    return { start, end };
  },
  
  getQuoteRange(quote, inner) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    // ç¾åœ¨è¡Œã‚’å–å¾—
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    const line = text.substring(lineStart, lineEnd);
    const colPos = pos - lineStart;
    
    // å¼•ç”¨ç¬¦ã®ãƒšã‚¢ã‚’æ¢ã™
    let start = -1;
    let end = -1;
    let inQuote = false;
    let quoteStart = -1;
    
    for (let i = 0; i < line.length; i++) {
      if (line[i] === quote && (i === 0 || line[i-1] !== '\\')) {
        if (!inQuote) {
          quoteStart = i;
          inQuote = true;
        } else {
          if (colPos >= quoteStart && colPos <= i) {
            start = quoteStart;
            end = i;
            break;
          }
          inQuote = false;
        }
      }
    }
    
    if (start === -1 || end === -1) return null;
    
    if (inner) {
      return { start: lineStart + start + 1, end: lineStart + end };
    } else {
      return { start: lineStart + start, end: lineStart + end + 1 };
    }
  },
  
  getBracketRange(open, close, inner) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    // å¯¾å¿œã™ã‚‹æ‹¬å¼§ã‚’æ¢ã™
    let depth = 0;
    let start = -1;
    let end = -1;
    
    // é–‹ãæ‹¬å¼§ã‚’å¾Œã‚ã«æ¢ã™
    for (let i = pos; i >= 0; i--) {
      if (text[i] === close) depth++;
      else if (text[i] === open) {
        if (depth === 0) {
          start = i;
          break;
        }
        depth--;
      }
    }
    
    if (start === -1) return null;
    
    // é–‰ã˜æ‹¬å¼§ã‚’å‰ã«æ¢ã™
    depth = 0;
    for (let i = start; i < text.length; i++) {
      if (text[i] === open) depth++;
      else if (text[i] === close) {
        depth--;
        if (depth === 0) {
          end = i;
          break;
        }
      }
    }
    
    if (end === -1) return null;
    
    if (inner) {
      return { start: start + 1, end: end };
    } else {
      return { start: start, end: end + 1 };
    }
  },
  
  handleVisualMode(e) {
    const key = e.key;
    
    this.recordKey(key, e);
    
    if (key === 'Escape' || (e.ctrlKey && key === '[')) {
      this.setMode('normal');
      this.editor.selectionEnd = this.editor.selectionStart;
      return;
    }
    
    const start = Math.min(this.visualStart, this.editor.selectionStart);
    const end = Math.max(this.visualStart, this.editor.selectionEnd);
    
    switch(key) {
      case 'h': case 'ArrowLeft': this.moveCursor(-1); break;
      case 'l': case 'ArrowRight': this.moveCursor(1); break;
      case 'j': case 'ArrowDown': this.moveVertical(1); break;
      case 'k': case 'ArrowUp': this.moveVertical(-1); break;
      case 'w': this.moveWord(1); break;
      case 'b': this.moveWord(-1); break;
      case '0': this.moveToLineStart(); break;
      case '$': this.moveToLineEnd(); break;
      case 'G': this.moveToEnd(); break;
      case 'g': this.pendingKey = 'g'; break;
      case '{': this.moveParagraph(-1); break;
      case '}': this.moveParagraph(1); break;
      
      // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
      case '>':
        this.saveState();
        this.indentSelection(1);
        this.setMode('normal');
        return;
      case '<':
        this.saveState();
        this.indentSelection(-1);
        this.setMode('normal');
        return;
        
      case 'd': case 'x':
        this.saveState();
        this.editor.selectionStart = start;
        this.editor.selectionEnd = end;
        this.register = this.editor.value.substring(start, end);
        this.deleteSelection();
        this.setMode('normal');
        return;
      case 'y':
        this.register = this.editor.value.substring(start, end);
        this.setMode('normal');
        this.editor.selectionEnd = this.editor.selectionStart;
        this.showStatus('ãƒ¤ãƒ³ã‚¯ã—ã¾ã—ãŸ');
        return;
      case 'c':
        this.saveState();
        this.editor.selectionStart = start;
        this.editor.selectionEnd = end;
        this.register = this.editor.value.substring(start, end);
        this.deleteSelection();
        this.setMode('insert');
        return;
      case '~':
        this.saveState();
        this.toggleCaseSelection(start, end);
        this.setMode('normal');
        return;
      case 'U':
        this.saveState();
        this.changeCaseSelection(start, end, 'upper');
        this.setMode('normal');
        return;
      case 'u':
        this.saveState();
        this.changeCaseSelection(start, end, 'lower');
        this.setMode('normal');
        return;
    }
    
    // é¸æŠç¯„å›²ã®æ›´æ–°
    if (this.mode === 'visual') {
      const curPos = this.editor.selectionStart;
      if (this.visualLine) {
        const text = this.editor.value;
        const startLine = text.lastIndexOf('\n', Math.min(this.visualStart, curPos) - 1) + 1;
        let endLine = text.indexOf('\n', Math.max(this.visualStart, curPos));
        if (endLine === -1) endLine = text.length;
        else endLine++;
        this.editor.selectionStart = startLine;
        this.editor.selectionEnd = endLine;
      } else {
        this.editor.selectionStart = Math.min(this.visualStart, curPos);
        this.editor.selectionEnd = Math.max(this.visualStart, curPos);
      }
    }
    
    this.updateCursorPos();
  },
  
  handleCommandKey(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      const cmd = this.commandInput.value;
      const prefix = this.commandPrefix.textContent;
      this.commandInput.value = '';
      this.setMode('normal');
      
      if (prefix === ':') this.executeCommand(cmd);
      else if (prefix === '/') this.search(cmd);
    } else if (e.key === 'Escape' || (e.ctrlKey && e.key === '[')) {
      e.preventDefault();
      this.commandInput.value = '';
      this.setMode('normal');
    }
  },
  
  executeCommand(cmd) {
    // ç½®æ›ã‚³ãƒãƒ³ãƒ‰ã®ãƒ‘ãƒ¼ã‚¹
    const substituteMatch = cmd.match(/^(%)?s\/(.+?)\/(.*)\/([gic]*)$/);
    if (substituteMatch) {
      this.substitute(substituteMatch);
      return;
    }
    
    // ç¯„å›²æŒ‡å®šç½®æ›
    const rangeSubMatch = cmd.match(/^(\d+),(\d+)s\/(.+?)\/(.*)\/([gic]*)$/);
    if (rangeSubMatch) {
      this.substituteRange(rangeSubMatch);
      return;
    }
    
    const parts = cmd.trim().split(/\s+/);
    const command = parts[0];
    
    switch(command) {
      case 'w':
        if (parts[1]) {
          // ãƒ•ã‚¡ã‚¤ãƒ«åæŒ‡å®šã‚ã‚Š â†’ ç›´æ¥ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
          this.downloadFile(parts[1]);
        } else {
          // ãƒ•ã‚¡ã‚¤ãƒ«åãªã— â†’ ä¿å­˜ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã
          this.saveWithDialog();
        }
        break;
      case 'q':
        if (this.modified) {
          this.showStatus('ä¿å­˜ã•ã‚Œã¦ã„ãªã„å¤‰æ›´ãŒã‚ã‚Šã¾ã™ï¼ :q! ã§å¼·åˆ¶çµ‚äº†');
        } else {
          this.showStatus('çµ‚äº†ã™ã‚‹ã«ã¯ãƒ–ãƒ©ã‚¦ã‚¶ã‚’é–‰ã˜ã¦ãã ã•ã„');
        }
        break;
      case 'q!':
        this.showStatus('çµ‚äº†ã™ã‚‹ã«ã¯ãƒ–ãƒ©ã‚¦ã‚¶ã‚’é–‰ã˜ã¦ãã ã•ã„');
        break;
      case 'wq': case 'x':
        this.saveWithDialog();
        break;
      case 'e': case 'edit': case 'open':
        if (parts[1]) {
          // ãƒ•ã‚¡ã‚¤ãƒ«åæŒ‡å®š â†’ æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦æ‰±ã†
          if (this.modified) {
            this.showStatus('ä¿å­˜ã•ã‚Œã¦ã„ãªã„å¤‰æ›´ãŒã‚ã‚Šã¾ã™ï¼ :e! ã§å¼·åˆ¶');
          } else {
            this.editor.value = '';
            this.fileName.textContent = parts[1];
            this.currentFileName = parts[1];
            this.modified = false;
            this.updateFileStatus();
            this.onInput();
          }
        } else {
          // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã
          this.openWithDialog();
        }
        break;
      case 'e!':
        // å¼·åˆ¶çš„ã«æ–°è¦/é–‹ã
        if (parts[1]) {
          this.editor.value = '';
          this.fileName.textContent = parts[1];
          this.currentFileName = parts[1];
          this.modified = false;
          this.updateFileStatus();
          this.onInput();
        } else {
          this.openWithDialog();
        }
        break;
      case 'saveas': case 'sav':
        if (parts[1]) {
          this.downloadFile(parts[1]);
        } else {
          this.saveWithDialog();
        }
        break;
      case 'read': case 'r':
        // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ¿å…¥
        this.openFileDialog(true);
        break;
      case 'new':
        // æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«
        if (this.modified) {
          this.showStatus('ä¿å­˜ã•ã‚Œã¦ã„ãªã„å¤‰æ›´ãŒã‚ã‚Šã¾ã™ï¼');
        } else {
          this.newFile();
        }
        break;
      case 'new!':
        this.newFile();
        break;
      case 'set':
        if (parts[1] === 'nu' || parts[1] === 'number') {
          this.lineNumbers.style.display = 'block';
        } else if (parts[1] === 'nonu' || parts[1] === 'nonumber') {
          this.lineNumbers.style.display = 'none';
        } else if (parts[1] && parts[1].startsWith('theme=')) {
          const theme = parts[1].split('=')[1];
          if (['dark', 'light', 'original'].includes(theme)) {
            setTheme(theme);
          } else {
            this.showStatus('ç„¡åŠ¹ãªãƒ†ãƒ¼ãƒ: dark, light, original ã‹ã‚‰é¸æŠ');
          }
        } else if (parts[1] === 'theme') {
          const current = document.documentElement.getAttribute('data-theme') || 'dark';
          this.showStatus(`ç¾åœ¨ã®ãƒ†ãƒ¼ãƒ: ${current}`);
        }
        break;
      case 'theme':
        if (parts[1] && ['dark', 'light', 'original'].includes(parts[1])) {
          setTheme(parts[1]);
        } else {
          this.showStatus('ä½¿ç”¨æ³•: :theme dark|light|original');
        }
        break;
      case 'dark':
        setTheme('dark');
        break;
      case 'light':
        setTheme('light');
        break;
      case 'original':
        setTheme('original');
        break;
      case 'marks':
        this.showMarks();
        break;
      case 'help': case 'h':
        toggleHelp();
        break;
      case 'ls':
        this.save();
        this.showStatus('ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ã—ã¾ã—ãŸ');
        break;
      default:
        const lineNum = parseInt(command);
        if (!isNaN(lineNum)) {
          this.gotoLine(lineNum);
        } else {
          this.showStatus('ä¸æ˜ãªã‚³ãƒãƒ³ãƒ‰: ' + command);
        }
    }
  },
  
  // ç½®æ›ã‚³ãƒãƒ³ãƒ‰
  substitute(match) {
    const [, global, pattern, replacement, flags] = match;
    const isGlobal = flags.includes('g');
    
    this.saveState();
    
    if (global === '%') {
      // å…¨ç½®æ›
      const regex = new RegExp(pattern, isGlobal ? 'g' : '');
      const oldValue = this.editor.value;
      this.editor.value = oldValue.replace(regex, replacement);
      const count = (oldValue.match(new RegExp(pattern, 'g')) || []).length;
      this.showStatus(`${count} ä»¶ç½®æ›ã—ã¾ã—ãŸ`);
    } else {
      // ç¾åœ¨è¡Œã®ã¿
      const text = this.editor.value;
      const pos = this.editor.selectionStart;
      const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
      let lineEnd = text.indexOf('\n', pos);
      if (lineEnd === -1) lineEnd = text.length;
      
      const line = text.substring(lineStart, lineEnd);
      const regex = new RegExp(pattern, isGlobal ? 'g' : '');
      const newLine = line.replace(regex, replacement);
      
      this.editor.value = text.substring(0, lineStart) + newLine + text.substring(lineEnd);
      this.showStatus('ç½®æ›ã—ã¾ã—ãŸ');
    }
    
    this.onInput();
  },
  
  substituteRange(match) {
    const [, startLine, endLine, pattern, replacement, flags] = match;
    const isGlobal = flags.includes('g');
    const start = parseInt(startLine);
    const end = parseInt(endLine);
    
    this.saveState();
    
    const lines = this.editor.value.split('\n');
    const regex = new RegExp(pattern, isGlobal ? 'g' : '');
    let count = 0;
    
    for (let i = start - 1; i < end && i < lines.length; i++) {
      const matches = lines[i].match(new RegExp(pattern, 'g'));
      if (matches) count += matches.length;
      lines[i] = lines[i].replace(regex, replacement);
    }
    
    this.editor.value = lines.join('\n');
    this.showStatus(`${count} ä»¶ç½®æ›ã—ã¾ã—ãŸ`);
    this.onInput();
  },
  
  showMarks() {
    const markList = Object.entries(this.marks)
      .map(([k, v]) => `'${k}: ${v}`)
      .join(', ');
    this.showStatus(markList || 'ãƒãƒ¼ã‚¯ãªã—');
  },
  
  // è¡Œå†…æ¤œç´¢
  findCharInLine(char, direction, beforeChar) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    
    let newPos = -1;
    
    if (direction > 0) {
      // å‰æ–¹æ¤œç´¢
      for (let i = pos + 1; i < lineEnd; i++) {
        if (text[i] === char) {
          newPos = beforeChar ? i - 1 : i;
          break;
        }
      }
    } else {
      // å¾Œæ–¹æ¤œç´¢
      for (let i = pos - 1; i >= lineStart; i--) {
        if (text[i] === char) {
          newPos = beforeChar ? i + 1 : i;
          break;
        }
      }
    }
    
    if (newPos >= lineStart && newPos < lineEnd) {
      this.editor.selectionStart = newPos;
      this.editor.selectionEnd = newPos;
    }
  },
  
  repeatFindChar(directionMultiplier) {
    if (this.lastFindChar) {
      const direction = this.lastFindDirection * directionMultiplier;
      const beforeChar = this.lastFindType === 't';
      this.findCharInLine(this.lastFindChar, direction, beforeChar);
    }
  },
  
  // ãƒ‘ãƒ©ã‚°ãƒ©ãƒ•ç§»å‹•
  moveParagraph(direction) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lines = text.split('\n');
    
    // ç¾åœ¨ã®è¡Œç•ªå·ã‚’è¨ˆç®—
    let currentLine = 0;
    let charCount = 0;
    for (let i = 0; i < lines.length; i++) {
      if (charCount + lines[i].length >= pos) {
        currentLine = i;
        break;
      }
      charCount += lines[i].length + 1;
    }
    
    let targetLine = currentLine;
    
    if (direction > 0) {
      // æ¬¡ã®ç©ºè¡Œã‚’æ¢ã™ï¼ˆ}ï¼‰
      // ã¾ãšç¾åœ¨ã®ç©ºè¡Œãƒ–ãƒ­ãƒƒã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—
      while (targetLine < lines.length && lines[targetLine].trim() === '') {
        targetLine++;
      }
      // æ¬¡ã®ç©ºè¡Œã‚’è¦‹ã¤ã‘ã‚‹
      while (targetLine < lines.length && lines[targetLine].trim() !== '') {
        targetLine++;
      }
    } else {
      // å‰ã®ç©ºè¡Œã‚’æ¢ã™ï¼ˆ{ï¼‰
      // ã¾ãšç¾åœ¨è¡Œã‹ã‚‰1ã¤æˆ»ã‚‹
      targetLine--;
      // ç¾åœ¨ã®ç©ºè¡Œãƒ–ãƒ­ãƒƒã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—
      while (targetLine >= 0 && lines[targetLine].trim() === '') {
        targetLine--;
      }
      // å‰ã®ç©ºè¡Œã‚’è¦‹ã¤ã‘ã‚‹
      while (targetLine >= 0 && lines[targetLine].trim() !== '') {
        targetLine--;
      }
      // è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°å…ˆé ­ã¸
      if (targetLine < 0) targetLine = 0;
    }
    
    // targetLineãŒç¯„å›²å¤–ãªã‚‰è£œæ­£
    targetLine = Math.max(0, Math.min(targetLine, lines.length - 1));
    
    // æ–°ã—ã„ä½ç½®ã‚’è¨ˆç®—
    let newPos = 0;
    for (let i = 0; i < targetLine; i++) {
      newPos += lines[i].length + 1;
    }
    
    this.previousPosition = pos;
    this.editor.selectionStart = newPos;
    this.editor.selectionEnd = newPos;
    this.scrollToCursor();
    this.updateCursorPos();
  },
  
  // æ‹¬å¼§ã‚¸ãƒ£ãƒ³ãƒ—
  jumpToMatchingBracket() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const char = text[pos];
    
    const pairs = { '(': ')', ')': '(', '[': ']', ']': '[', '{': '}', '}': '{', '<': '>', '>': '<' };
    const openBrackets = '([{<';
    
    if (!pairs[char]) {
      // ç¾åœ¨ä½ç½®ã«æ‹¬å¼§ãŒãªã„å ´åˆã€è¡Œå†…ã§æœ€åˆã®æ‹¬å¼§ã‚’æ¢ã™
      const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
      let lineEnd = text.indexOf('\n', pos);
      if (lineEnd === -1) lineEnd = text.length;
      
      for (let i = pos; i < lineEnd; i++) {
        if (pairs[text[i]]) {
          this.editor.selectionStart = i;
          this.editor.selectionEnd = i;
          this.jumpToMatchingBracket();
          return;
        }
      }
      return;
    }
    
    const target = pairs[char];
    const isOpen = openBrackets.includes(char);
    let depth = 0;
    
    if (isOpen) {
      for (let i = pos; i < text.length; i++) {
        if (text[i] === char) depth++;
        else if (text[i] === target) {
          depth--;
          if (depth === 0) {
            this.previousPosition = pos;
            this.editor.selectionStart = i;
            this.editor.selectionEnd = i;
            this.scrollToCursor();
            return;
          }
        }
      }
    } else {
      for (let i = pos; i >= 0; i--) {
        if (text[i] === char) depth++;
        else if (text[i] === target) {
          depth--;
          if (depth === 0) {
            this.previousPosition = pos;
            this.editor.selectionStart = i;
            this.editor.selectionEnd = i;
            this.scrollToCursor();
            return;
          }
        }
      }
    }
  },
  
  // ãƒã‚¯ãƒ­
  startRecordingMacro(name) {
    this.recordingMacro = name;
    this.macroBuffer = [];
    this.macroIndicator.classList.add('active');
    this.modeIndicator.classList.add('recording');
    this.showStatus(`ãƒã‚¯ãƒ­ '${name}' è¨˜éŒ²é–‹å§‹`);
  },
  
  stopRecordingMacro() {
    this.macros[this.recordingMacro] = [...this.macroBuffer];
    this.showStatus(`ãƒã‚¯ãƒ­ '${this.recordingMacro}' è¨˜éŒ²å®Œäº† (${this.macroBuffer.length} ã‚­ãƒ¼)`);
    this.recordingMacro = null;
    this.macroBuffer = [];
    this.macroIndicator.classList.remove('active');
    this.modeIndicator.classList.remove('recording');
  },
  
  playMacro(name) {
    const macro = this.macros[name];
    if (!macro || macro.length === 0) return;
    
    this.lastMacro = name;
    
    // ãƒã‚¯ãƒ­å†ç”Ÿä¸­ã¯è¨˜éŒ²ã—ãªã„
    const wasRecording = this.recordingMacro;
    this.recordingMacro = null;
    
    for (const keyInfo of macro) {
      const event = new KeyboardEvent('keydown', {
        key: keyInfo.key,
        ctrlKey: keyInfo.ctrlKey || false,
        shiftKey: keyInfo.shiftKey || false
      });
      
      if (this.mode === 'insert') {
        if (keyInfo.key === 'Escape') {
          this.exitInsertMode();
        } else if (keyInfo.key.length === 1) {
          this.insertText(keyInfo.key);
        }
      } else {
        this.handleNormalMode(event);
      }
    }
    
    this.recordingMacro = wasRecording;
  },
  
  // ãƒ‰ãƒƒãƒˆãƒªãƒ”ãƒ¼ãƒˆ
  setLastEdit(type, char = null, count = 1) {
    this.lastEdit = { type, char, count, insertedText: '' };
  },
  
  repeatLastEdit(count) {
    if (!this.lastEdit) return;
    
    const repeat = count || this.lastEdit.count || 1;
    
    for (let i = 0; i < repeat; i++) {
      this.saveState();
      
      switch(this.lastEdit.type) {
        case 'x':
          this.deleteChar();
          break;
        case 'X':
          this.deleteCharBefore();
          break;
        case 'dd':
          this.deleteLine();
          break;
        case 'dw':
          this.deleteWord();
          break;
        case 'd$':
        case 'D':
          this.deleteToLineEnd();
          break;
        case 'd0':
          this.deleteToLineStart();
          break;
        case 'cc':
        case 'S':
          this.deleteLineContent();
          this.insertText(this.lastEdit.insertedText || '');
          break;
        case 'cw':
          this.deleteWord();
          this.insertText(this.lastEdit.insertedText || '');
          break;
        case 'C':
          this.deleteToLineEnd();
          this.insertText(this.lastEdit.insertedText || '');
          break;
        case 'r':
          this.replaceChar(this.lastEdit.char);
          break;
        case 's':
          this.deleteChar();
          this.insertText(this.lastEdit.insertedText || '');
          break;
        case 'o':
          this.moveToLineEnd();
          this.insertText('\n' + (this.lastEdit.insertedText || ''));
          break;
        case 'O':
          this.moveToLineStart();
          this.insertText((this.lastEdit.insertedText || '') + '\n');
          this.moveVertical(-1);
          break;
        case 'insert':
          this.insertText(this.lastEdit.insertedText || '');
          break;
        case '~':
          this.toggleCase();
          break;
        case '>>':
          this.indentLine(1);
          break;
        case '<<':
          this.indentLine(-1);
          break;
        case 'J':
          this.joinLines();
          break;
        // ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        case 'diw': case 'daw': case 'ciw': case 'caw':
        case 'di"': case 'da"': case "di'": case "da'":
        case 'di(': case 'da(': case 'di[': case 'da[':
        case 'di{': case 'da{': case 'di`': case 'da`':
          const op = this.lastEdit.type[0];
          const inner = this.lastEdit.type[1] === 'i';
          const objChar = this.lastEdit.type[2];
          this.handleTextObject(op + (inner ? 'i' : 'a'), objChar);
          if (op === 'c') {
            this.insertText(this.lastEdit.insertedText || '');
          }
          break;
      }
    }
  },
  
  // å¤§æ–‡å­—/å°æ–‡å­—åˆ‡æ›¿
  toggleCase() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    if (pos < text.length) {
      const char = text[pos];
      let newChar;
      if (char === char.toLowerCase()) {
        newChar = char.toUpperCase();
      } else {
        newChar = char.toLowerCase();
      }
      
      this.editor.value = text.substring(0, pos) + newChar + text.substring(pos + 1);
      this.editor.selectionStart = pos + 1;
      this.editor.selectionEnd = pos + 1;
      this.onInput();
    }
  },
  
  toggleCaseSelection(start, end) {
    const text = this.editor.value;
    let result = '';
    
    for (let i = start; i < end; i++) {
      const char = text[i];
      if (char === char.toLowerCase()) {
        result += char.toUpperCase();
      } else {
        result += char.toLowerCase();
      }
    }
    
    this.editor.value = text.substring(0, start) + result + text.substring(end);
    this.editor.selectionStart = start;
    this.editor.selectionEnd = start;
    this.onInput();
  },
  
  changeCaseSelection(start, end, caseType) {
    const text = this.editor.value;
    const selected = text.substring(start, end);
    const changed = caseType === 'upper' ? selected.toUpperCase() : selected.toLowerCase();
    
    this.editor.value = text.substring(0, start) + changed + text.substring(end);
    this.editor.selectionStart = start;
    this.editor.selectionEnd = start;
    this.onInput();
  },
  
  // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
  indentLine(direction) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    
    const line = text.substring(lineStart, lineEnd);
    let newLine;
    
    if (direction > 0) {
      newLine = '  ' + line;
    } else {
      newLine = line.replace(/^  /, '').replace(/^\t/, '');
    }
    
    this.editor.value = text.substring(0, lineStart) + newLine + text.substring(lineEnd);
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineStart;
    this.onInput();
  },
  
  indentSelection(direction) {
    const text = this.editor.value;
    const start = this.editor.selectionStart;
    const end = this.editor.selectionEnd;
    
    const lineStart = text.lastIndexOf('\n', start - 1) + 1;
    let lineEnd = text.indexOf('\n', end - 1);
    if (lineEnd === -1) lineEnd = text.length;
    
    const selectedLines = text.substring(lineStart, lineEnd).split('\n');
    const newLines = selectedLines.map(line => {
      if (direction > 0) {
        return '  ' + line;
      } else {
        return line.replace(/^  /, '').replace(/^\t/, '');
      }
    });
    
    this.editor.value = text.substring(0, lineStart) + newLines.join('\n') + text.substring(lineEnd);
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineStart;
    this.onInput();
  },
  
  // ç§»å‹•ç³»
  moveCursor(delta) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const newPos = Math.max(0, Math.min(text.length, pos + delta));
    this.editor.selectionStart = newPos;
    this.editor.selectionEnd = newPos;
  },
  
  moveVertical(direction) {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lines = text.substring(0, pos).split('\n');
    const currentLine = lines.length - 1;
    const currentCol = lines[lines.length - 1].length;
    const allLines = text.split('\n');
    
    const targetLine = currentLine + direction;
    if (targetLine < 0 || targetLine >= allLines.length) return;
    
    let newPos = 0;
    for (let i = 0; i < targetLine; i++) newPos += allLines[i].length + 1;
    newPos += Math.min(currentCol, allLines[targetLine].length);
    
    this.editor.selectionStart = newPos;
    this.editor.selectionEnd = newPos;
  },
  
  moveWord(direction) {
    const text = this.editor.value;
    let pos = this.editor.selectionStart;
    
    if (direction > 0) {
      const match = text.substring(pos).match(/^\s*\S+\s*/);
      if (match) pos += match[0].length;
    } else {
      const before = text.substring(0, pos);
      const match = before.match(/\S+\s*$/);
      if (match) pos -= match[0].length;
    }
    
    this.editor.selectionStart = pos;
    this.editor.selectionEnd = pos;
  },
  
  moveWordEnd() {
    const text = this.editor.value;
    let pos = this.editor.selectionStart;
    const match = text.substring(pos + 1).match(/^\s*\S*/);
    if (match) pos += match[0].length;
    this.editor.selectionStart = pos;
    this.editor.selectionEnd = pos;
  },
  
  moveToLineStart() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineStart;
  },
  
  moveToLineEnd() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    this.editor.selectionStart = lineEnd;
    this.editor.selectionEnd = lineEnd;
  },
  
  moveToFirstNonSpace() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    const line = text.substring(lineStart, lineEnd);
    const match = line.match(/^\s*/);
    const newPos = lineStart + (match ? match[0].length : 0);
    this.editor.selectionStart = newPos;
    this.editor.selectionEnd = newPos;
  },
  
  moveToStart() { 
    this.previousPosition = this.editor.selectionStart;
    this.editor.selectionStart = 0; 
    this.editor.selectionEnd = 0;
    this.editor.scrollTop = 0;
  },
  
  moveToEnd() { 
    this.previousPosition = this.editor.selectionStart;
    const len = this.editor.value.length; 
    this.editor.selectionStart = len; 
    this.editor.selectionEnd = len;
    this.editor.scrollTop = this.editor.scrollHeight;
  },
  
  gotoLine(lineNum) {
    this.previousPosition = this.editor.selectionStart;
    const lines = this.editor.value.split('\n');
    const targetLine = Math.min(Math.max(1, lineNum), lines.length) - 1;
    let pos = 0;
    for (let i = 0; i < targetLine; i++) pos += lines[i].length + 1;
    this.editor.selectionStart = pos;
    this.editor.selectionEnd = pos;
    this.scrollToCursor();
    this.editor.focus();
    this.updateCursorPos();
  },
  
  gotoPosition(pos) {
    this.editor.selectionStart = pos;
    this.editor.selectionEnd = pos;
    this.scrollToCursor();
    this.editor.focus();
    this.updateCursorPos();
  },
  
  selectCurrentLine() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    else lineEnd++;
    this.visualStart = lineStart;
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineEnd;
  },
  
  // ç·¨é›†ç³»
  insertText(text) {
    const pos = this.editor.selectionStart;
    const before = this.editor.value.substring(0, pos);
    const after = this.editor.value.substring(this.editor.selectionEnd);
    this.editor.value = before + text + after;
    this.editor.selectionStart = pos + text.length;
    this.editor.selectionEnd = this.editor.selectionStart;
    this.onInput();
  },
  
  deleteChar() {
    const pos = this.editor.selectionStart;
    if (pos < this.editor.value.length) {
      this.editor.value = this.editor.value.substring(0, pos) + this.editor.value.substring(pos + 1);
      this.onInput();
    }
  },
  
  deleteCharBefore() {
    const pos = this.editor.selectionStart;
    if (pos > 0) {
      this.editor.value = this.editor.value.substring(0, pos - 1) + this.editor.value.substring(pos);
      this.editor.selectionStart = pos - 1;
      this.editor.selectionEnd = pos - 1;
      this.onInput();
    }
  },
  
  deleteLine() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    else lineEnd++;
    
    this.register = text.substring(lineStart, lineEnd);
    this.editor.value = text.substring(0, lineStart) + text.substring(lineEnd);
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineStart;
    this.onInput();
  },
  
  deleteLineContent() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    
    // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’ä¿æŒ
    const line = text.substring(lineStart, lineEnd);
    const indent = line.match(/^\s*/)[0];
    
    this.register = line;
    this.editor.value = text.substring(0, lineStart) + indent + text.substring(lineEnd);
    this.editor.selectionStart = lineStart + indent.length;
    this.editor.selectionEnd = lineStart + indent.length;
    this.onInput();
  },
  
  deleteWord() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const match = text.substring(pos).match(/^\S*\s*/);
    if (match) {
      this.register = match[0];
      this.editor.value = text.substring(0, pos) + text.substring(pos + match[0].length);
      this.onInput();
    }
  },
  
  deleteToLineEnd() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    
    this.register = text.substring(pos, lineEnd);
    this.editor.value = text.substring(0, pos) + text.substring(lineEnd);
    this.onInput();
  },
  
  deleteToLineStart() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    
    this.register = text.substring(lineStart, pos);
    this.editor.value = text.substring(0, lineStart) + text.substring(pos);
    this.editor.selectionStart = lineStart;
    this.editor.selectionEnd = lineStart;
    this.onInput();
  },
  
  deleteSelection() {
    const start = this.editor.selectionStart;
    const end = this.editor.selectionEnd;
    this.editor.value = this.editor.value.substring(0, start) + this.editor.value.substring(end);
    this.editor.selectionStart = start;
    this.editor.selectionEnd = start;
    this.onInput();
  },
  
  replaceChar(char) {
    const pos = this.editor.selectionStart;
    const text = this.editor.value;
    if (pos < text.length) {
      this.editor.value = text.substring(0, pos) + char + text.substring(pos + 1);
      this.onInput();
    }
  },
  
  joinLines() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) return;
    
    // æ¬¡ã®è¡Œã®å…ˆé ­ã®ç©ºç™½ã‚’å–å¾—
    const nextLineStart = lineEnd + 1;
    const nextLineMatch = text.substring(nextLineStart).match(/^\s*/);
    const nextLineIndent = nextLineMatch ? nextLineMatch[0].length : 0;
    
    this.editor.value = text.substring(0, lineEnd) + ' ' + text.substring(nextLineStart + nextLineIndent);
    this.editor.selectionStart = lineEnd;
    this.editor.selectionEnd = lineEnd;
    this.onInput();
  },
  
  // ãƒ¤ãƒ³ã‚¯/ãƒšãƒ¼ã‚¹ãƒˆ
  yankLine() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
    let lineEnd = text.indexOf('\n', pos);
    if (lineEnd === -1) lineEnd = text.length;
    else lineEnd++;
    
    this.register = text.substring(lineStart, lineEnd);
    this.showStatus('1è¡Œãƒ¤ãƒ³ã‚¯ã—ã¾ã—ãŸ');
  },
  
  yankWord() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const match = text.substring(pos).match(/^\S+/);
    if (match) {
      this.register = match[0];
      this.showStatus('ãƒ¤ãƒ³ã‚¯ã—ã¾ã—ãŸ');
    }
  },
  
  paste() {
    if (!this.register) return;
    
    if (this.register.endsWith('\n')) {
      let lineEnd = this.editor.value.indexOf('\n', this.editor.selectionStart);
      if (lineEnd === -1) lineEnd = this.editor.value.length;
      this.editor.selectionStart = lineEnd;
      this.editor.selectionEnd = lineEnd;
      this.insertText('\n' + this.register.slice(0, -1));
    } else {
      this.moveCursor(1);
      this.insertText(this.register);
    }
  },
  
  pasteBefore() {
    if (!this.register) return;
    
    if (this.register.endsWith('\n')) {
      this.moveToLineStart();
      this.insertText(this.register);
      this.moveToLineStart();
    } else {
      this.insertText(this.register);
    }
  },
  
  // ã‚¢ãƒ³ãƒ‰ã‚¥/ãƒªãƒ‰ã‚¥
  saveState() {
    this.undoStack.push({ text: this.editor.value, pos: this.editor.selectionStart });
    this.redoStack = [];
    if (this.undoStack.length > 100) this.undoStack.shift();
  },
  
  undo() {
    if (this.undoStack.length === 0) { this.showStatus('ã“ã‚Œä»¥ä¸Šæˆ»ã‚Œã¾ã›ã‚“'); return; }
    this.redoStack.push({ text: this.editor.value, pos: this.editor.selectionStart });
    const state = this.undoStack.pop();
    this.editor.value = state.text;
    this.editor.selectionStart = state.pos;
    this.editor.selectionEnd = state.pos;
    this.onInput();
    this.showStatus('ã‚¢ãƒ³ãƒ‰ã‚¥ã—ã¾ã—ãŸ');
  },
  
  redo() {
    if (this.redoStack.length === 0) { this.showStatus('ã“ã‚Œä»¥ä¸Šã‚„ã‚Šç›´ã›ã¾ã›ã‚“'); return; }
    this.undoStack.push({ text: this.editor.value, pos: this.editor.selectionStart });
    const state = this.redoStack.pop();
    this.editor.value = state.text;
    this.editor.selectionStart = state.pos;
    this.editor.selectionEnd = state.pos;
    this.onInput();
    this.showStatus('ãƒªãƒ‰ã‚¥ã—ã¾ã—ãŸ');
  },
  
  // æ¤œç´¢
  search(term) { this.searchTerm = term; this.findNext(); },
  
  searchWordUnderCursor() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    let start = pos;
    let end = pos;
    while (start > 0 && /\w/.test(text[start - 1])) start--;
    while (end < text.length && /\w/.test(text[end])) end++;
    
    if (start < end) {
      this.searchTerm = text.substring(start, end);
      this.findNext();
    }
  },
  
  findNext() {
    if (!this.searchTerm) return;
    const text = this.editor.value;
    const pos = this.editor.selectionStart + 1;
    let idx = text.indexOf(this.searchTerm, pos);
    
    if (idx === -1) idx = text.indexOf(this.searchTerm);
    
    if (idx !== -1) {
      this.previousPosition = this.editor.selectionStart;
      this.editor.selectionStart = idx;
      this.editor.selectionEnd = idx + this.searchTerm.length;
      this.scrollToCursor();
      this.showStatus('/' + this.searchTerm);
    } else {
      this.showStatus('è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ' + this.searchTerm);
    }
    this.editor.focus();
    this.updateCursorPos();
  },
  
  findPrev() {
    if (!this.searchTerm) return;
    const text = this.editor.value;
    const pos = this.editor.selectionStart - 1;
    let idx = text.lastIndexOf(this.searchTerm, pos);
    
    if (idx === -1) idx = text.lastIndexOf(this.searchTerm);
    
    if (idx !== -1) {
      this.previousPosition = this.editor.selectionStart;
      this.editor.selectionStart = idx;
      this.editor.selectionEnd = idx + this.searchTerm.length;
      this.scrollToCursor();
      this.showStatus('/' + this.searchTerm);
    } else {
      this.showStatus('è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ' + this.searchTerm);
    }
    this.editor.focus();
    this.updateCursorPos();
  },
  
  // ä¿å­˜
  save() {
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³å›ºæœ‰ã®ä¿å­˜
    sessionStorage.setItem('vim-md-content-' + this.sessionId, this.editor.value);
    // å…¨ä½“ã®ä¿å­˜ï¼ˆæœ€å¾Œã«æ˜ç¤ºçš„ã«ä¿å­˜ã—ãŸå†…å®¹ï¼‰
    localStorage.setItem('vim-md-content', this.editor.value);
    this.modified = false;
    this.updateFileStatus();
    this.showStatus('ä¿å­˜ã—ã¾ã—ãŸ');
  },
  
  // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¸ã®è‡ªå‹•ä¿å­˜ï¼ˆã‚¿ãƒ–å›ºæœ‰ï¼‰
  autoSave() {
    sessionStorage.setItem('vim-md-content-' + this.sessionId, this.editor.value);
  },
  
  // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§ä¿å­˜
  async saveWithDialog() {
    // File System Access API ãŒä½¿ãˆã‚‹ã‹ç¢ºèª
    if ('showSaveFilePicker' in window) {
      try {
        const handle = await window.showSaveFilePicker({
          suggestedName: this.currentFileName || 'document.md',
          types: [{
            description: 'Markdown Files',
            accept: { 'text/markdown': ['.md', '.markdown'] }
          }, {
            description: 'Text Files',
            accept: { 'text/plain': ['.txt'] }
          }]
        });
        
        const writable = await handle.createWritable();
        await writable.write(this.editor.value);
        await writable.close();
        
        this.currentFileName = handle.name;
        this.fileName.textContent = handle.name;
        this.currentFileHandle = handle;
        this.modified = false;
        this.updateFileStatus();
        this.showStatus(`"${handle.name}" ã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
      } catch (err) {
        if (err.name !== 'AbortError') {
          this.showStatus('ä¿å­˜ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ');
        }
      }
    } else {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å…¥åŠ›
      const filename = prompt('ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:', this.currentFileName || 'document.md');
      if (filename) {
        this.downloadFile(filename);
      }
    }
  },
  
  // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
  async openWithDialog() {
    // File System Access API ãŒä½¿ãˆã‚‹ã‹ç¢ºèª
    if ('showOpenFilePicker' in window) {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{
            description: 'Markdown Files',
            accept: { 'text/markdown': ['.md', '.markdown'] }
          }, {
            description: 'Text Files',
            accept: { 'text/plain': ['.txt'] }
          }],
          multiple: false
        });
        
        const file = await handle.getFile();
        const content = await file.text();
        
        this.undoStack = [];
        this.redoStack = [];
        this.editor.value = content;
        this.fileName.textContent = file.name;
        this.currentFileName = file.name;
        this.currentFileHandle = handle;
        this.modified = false;
        this.updateFileStatus();
        this.updateLineNumbers();
        this.updatePreview();
        this.editor.selectionStart = 0;
        this.editor.selectionEnd = 0;
        this.updateCursorPos();
        this.saveState();
        this.showStatus(`"${file.name}" ã‚’é–‹ãã¾ã—ãŸ`);
      } catch (err) {
        if (err.name !== 'AbortError') {
          this.showStatus('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã‘ã¾ã›ã‚“ã§ã—ãŸ');
        }
      }
    } else {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: inputè¦ç´ ã‚’ä½¿ç”¨
      this.openFileDialog(false);
    }
  },
  
  // æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«
  newFile() {
    this.undoStack = [];
    this.redoStack = [];
    this.editor.value = '';
    this.fileName.textContent = 'ç„¡é¡Œ';
    this.currentFileName = 'ç„¡é¡Œ';
    this.currentFileHandle = null;
    this.modified = false;
    this.updateFileStatus();
    this.updateLineNumbers();
    this.updatePreview();
    this.editor.selectionStart = 0;
    this.editor.selectionEnd = 0;
    this.updateCursorPos();
    this.saveState();
    this.showStatus('æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«');
  },
  
  // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
  downloadFile(filename) {
    // æ‹¡å¼µå­ãŒãªã‘ã‚Œã° .md ã‚’è¿½åŠ 
    if (!filename.includes('.')) {
      filename += '.md';
    }
    
    const blob = new Blob([this.editor.value], { type: 'text/markdown;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    this.fileName.textContent = filename;
    this.currentFileName = filename;
    this.modified = false;
    this.updateFileStatus();
    this.showStatus(`"${filename}" ã‚’ä¿å­˜ã—ã¾ã—ãŸ`);
  },
  
  // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã
  openFileDialog(insertMode = false) {
    this.fileInsertMode = insertMode;
    this.fileInput.click();
  },
  
  // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
  handleFileOpen(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      const content = event.target.result;
      
      if (this.fileInsertMode) {
        // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«æŒ¿å…¥
        this.saveState();
        this.insertText(content);
        this.showStatus(`"${file.name}" ã‚’æŒ¿å…¥ã—ã¾ã—ãŸ`);
      } else {
        // ãƒ•ã‚¡ã‚¤ãƒ«å…¨ä½“ã‚’ç½®ãæ›ãˆ
        this.undoStack = [];
        this.redoStack = [];
        this.editor.value = content;
        this.fileName.textContent = file.name;
        this.currentFileName = file.name;
        this.modified = false;
        this.updateFileStatus();
        this.updateLineNumbers();
        this.updatePreview();
        this.editor.selectionStart = 0;
        this.editor.selectionEnd = 0;
        this.updateCursorPos();
        this.saveState();
        this.showStatus(`"${file.name}" ã‚’é–‹ãã¾ã—ãŸ`);
      }
      
      this.fileInsertMode = false;
    };
    
    reader.onerror = () => {
      this.showStatus('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
    };
    
    reader.readAsText(file);
    
    // åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†åº¦é¸æŠã§ãã‚‹ã‚ˆã†ã«ãƒªã‚»ãƒƒãƒˆ
    this.fileInput.value = '';
  },
  
  // UI
  setMode(mode) {
    this.mode = mode;
    this.modeIndicator.textContent = mode.toUpperCase();
    this.modeIndicator.className = mode;
    if (this.recordingMacro) this.modeIndicator.classList.add('recording');
    
    if (mode === 'command') {
      this.commandLine.classList.remove('hidden');
      this.commandInput.focus();
    } else {
      this.commandLine.classList.add('hidden');
      this.editor.focus();
    }
    
    this.editor.readOnly = (mode !== 'insert');
    
    // ã‚«ãƒ¼ã‚½ãƒ«è¡¨ç¤ºã®æ›´æ–°
    if (mode === 'insert') {
      this.editor.classList.add('insert-mode');
    } else {
      this.editor.classList.remove('insert-mode');
    }
    this.updateCursorOverlay();
  },
  
  onInput(e) {
    this.modified = true;
    this.updateFileStatus();
    this.updateLineNumbers();
    this.updatePreview();
    this.updateToc();
    this.updateHeadingHighlight();
    this.updateCursorPos();
    
    // æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ã§ã®ãƒ†ã‚­ã‚¹ãƒˆè¿½è·¡
    if (this.mode === 'insert' && e && e.data) {
      this.lastEditText += e.data;
    }
    
    // è‡ªå‹•ä¿å­˜ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹: 1ç§’å¾Œã«ä¿å­˜ï¼‰
    clearTimeout(this.autoSaveTimer);
    this.autoSaveTimer = setTimeout(() => this.autoSave(), 1000);
  },
  
  updateCursorPos() {
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const lines = text.substring(0, pos).split('\n');
    const line = lines.length;
    const col = lines[lines.length - 1].length + 1;
    this.cursorPos.textContent = `${line}:${col}`;
    this.updateCursorOverlay();
    
    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ç¾åœ¨è¡Œã«åŒæœŸ
    this.syncPreviewToLine(line - 1);
    
    // ç›®æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
    this.updateTocActive(line - 1);
  },
  
  updateCursorOverlay() {
    if (!this.cursorOverlay) return;
    
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    
    // ç¾åœ¨è¡Œã¨ã‚«ãƒ©ãƒ ã‚’è¨ˆç®—
    const textBeforeCursor = text.substring(0, pos);
    const lines = textBeforeCursor.split('\n');
    const currentLineIndex = lines.length - 1;
    const currentCol = lines[currentLineIndex];
    
    // è¡Œã®é«˜ã•ã¨ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’å–å¾—
    const style = getComputedStyle(this.editor);
    const lineHeight = parseFloat(style.lineHeight);
    const paddingTop = parseFloat(style.paddingTop);
    const paddingLeft = parseFloat(style.paddingLeft);
    
    // æ–‡å­—å¹…ã‚’æ¸¬å®š
    this.measureSpan.textContent = currentCol || ' ';
    const charWidth = this.measureSpan.getBoundingClientRect().width / (currentCol.length || 1);
    const textWidth = currentCol.length * charWidth;
    
    // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’è¨ˆç®—
    const top = paddingTop + (currentLineIndex * lineHeight) - this.editor.scrollTop;
    const left = paddingLeft + textWidth - this.editor.scrollLeft;
    
    // ã‚«ãƒ¼ã‚½ãƒ«ã®æ–‡å­—ï¼ˆãƒ–ãƒ­ãƒƒã‚¯ã‚«ãƒ¼ã‚½ãƒ«ç”¨ï¼‰
    const charAtCursor = text[pos] || ' ';
    const cursorWidth = charAtCursor === '\n' || charAtCursor === ' ' || pos >= text.length 
      ? charWidth 
      : charWidth;
    
    // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’é…ç½®
    this.cursorOverlay.style.top = `${top}px`;
    this.cursorOverlay.style.left = `${left}px`;
    this.cursorOverlay.style.width = `${cursorWidth}px`;
    this.cursorOverlay.style.height = `${lineHeight}px`;
    
    // ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦ã‚¯ãƒ©ã‚¹ã‚’è¨­å®š
    this.cursorOverlay.className = this.mode;
    
    // ç”»é¢å¤–ãªã‚‰éè¡¨ç¤º
    if (top < 0 || top > this.editor.clientHeight) {
      this.cursorOverlay.style.display = 'none';
    } else {
      this.cursorOverlay.style.display = 'block';
    }
  },
  
  updateFileStatus() { this.fileStatus.textContent = this.modified ? '[+]' : ''; },
  
  updateLineNumbers() {
    const lines = this.editor.value.split('\n');
    let html = '';
    let inCodeBlock = false;
    
    for (let i = 0; i < lines.length; i++) {
      const lineNum = i + 1;
      const line = lines[i];
      
      // ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®é–‹å§‹/çµ‚äº†ã‚’è¿½è·¡
      if (line.trim().startsWith('```')) {
        inCodeBlock = !inCodeBlock;
      }
      
      // ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å¤–ã§è¦‹å‡ºã—è¡Œã‹ã©ã†ã‹åˆ¤å®š
      const headingMatch = !inCodeBlock && line.match(/^(#{1,6})\s+.+/);
      
      if (headingMatch) {
        const level = headingMatch[1].length;
        html += `<span class="line-num heading-h${level}">${lineNum}</span>`;
      } else {
        html += `<span class="line-num">${lineNum}</span>`;
      }
    }
    
    this.lineNumbers.innerHTML = html;
  },

  updatePreview() {
    this.preview.innerHTML = MarkdownParser.parse(this.editor.value);
    this.renderMath();
    this.renderMermaid();
    this.setupHeadingFold();
    this.highlightCode();
  },
  
  // ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  highlightCode() {
    if (typeof hljs !== 'undefined') {
      this.preview.querySelectorAll('pre code').forEach(block => {
        hljs.highlightElement(block);
      });
    }
  },
  
  // ç›®æ¬¡ã‚’æ›´æ–°
  updateToc() {
    if (!this.tocContent) return;
    
    const lines = this.editor.value.split('\n');
    let html = '';
    let inCodeBlock = false;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      if (line.trim().startsWith('```')) {
        inCodeBlock = !inCodeBlock;
        continue;
      }
      if (inCodeBlock) continue;
      
      const match = line.match(/^(#{1,6})\s+(.+)/);
      if (match) {
        const level = match[1].length;
        const text = match[2].trim();
        html += `<div class="toc-item h${level}" data-line="${i}" title="${text}">${text}</div>`;
      }
    }
    
    this.tocContent.innerHTML = html || '<div style="padding: 0.5rem; color: var(--text-secondary); font-size: 0.85rem;">è¦‹å‡ºã—ãŒã‚ã‚Šã¾ã›ã‚“</div>';
    
    // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
    this.tocContent.querySelectorAll('.toc-item').forEach(item => {
      item.addEventListener('click', () => {
        const lineNum = parseInt(item.dataset.line);
        this.jumpToLine(lineNum);
      });
    });
  },
  
  // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’é©ç”¨
  applyFontSize() {
    const scale = this.fontSize / 100;
    const baseFontSize = 0.95 * scale;
    const basePreviewSize = 1 * scale;
    
    if (this.editor) {
      this.editor.style.fontSize = `${baseFontSize}rem`;
    }
    if (this.lineNumbers) {
      this.lineNumbers.style.fontSize = `${baseFontSize * 0.95}rem`;
    }
    if (this.preview) {
      this.preview.style.fontSize = `${basePreviewSize}rem`;
    }
    
    if (this.fontSizeDisplay) {
      this.fontSizeDisplay.textContent = `${this.fontSize}%`;
    }
    
    // è¦‹å‡ºã—ãƒã‚¤ãƒ©ã‚¤ãƒˆã®ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚‚æ›´æ–°
    if (this.headingHighlight) {
      this.headingHighlight.style.fontSize = `${baseFontSize}rem`;
    }
    
    // åˆæœŸåŒ–å®Œäº†å¾Œã®ã¿è¡¨ç¤ºã‚’æ›´æ–°
    if (this.initialized) {
      this.updateHeadingHighlight();
      this.updateCursorOverlay();
    }
  },
  
  // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’å¤§ãã
  increaseFontSize() {
    if (this.fontSize < 200) {
      this.fontSize += 10;
      this.applyFontSize();
      localStorage.setItem('vim-md-font-size', this.fontSize);
    }
  },
  
  // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’å°ã•ã
  decreaseFontSize() {
    if (this.fontSize > 50) {
      this.fontSize -= 10;
      this.applyFontSize();
      localStorage.setItem('vim-md-font-size', this.fontSize);
    }
  },
  
  // ç›®æ¬¡ã®é–‹é–‰
  toggleToc() {
    this.tocVisible = !this.tocVisible;
    
    if (this.tocVisible) {
      this.tocPane.classList.remove('collapsed');
      this.tocOpenBtn.classList.add('hidden');
    } else {
      this.tocPane.classList.add('collapsed');
      this.tocOpenBtn.classList.remove('hidden');
    }
  },
  
  // æŒ‡å®šè¡Œã«ã‚¸ãƒ£ãƒ³ãƒ—
  jumpToLine(lineNum) {
    const lines = this.editor.value.split('\n');
    
    // è¡Œã®å…ˆé ­ä½ç½®ã‚’è¨ˆç®—
    let pos = 0;
    for (let i = 0; i < lineNum; i++) {
      pos += lines[i].length + 1;
    }
    
    // ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç§»å‹•
    this.editor.focus();
    this.editor.setSelectionRange(pos, pos);
    
    // ã‚¨ãƒ‡ã‚£ã‚¿ã‚’ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const scrollTop = lineNum * lineHeight - this.editor.clientHeight / 3;
    this.editor.scrollTop = Math.max(0, scrollTop);
    
    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚‚åŒæœŸ
    this.syncPreviewToLine(lineNum);
    
    // ç›®æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
    this.updateTocActive(lineNum);
    
    // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ›´æ–°
    this.updateCursorPos();
    this.updateCursorOverlay();
  },
  
  // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æŒ‡å®šè¡Œã«åŒæœŸ
  // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æŒ‡å®šè¡Œã«åŒæœŸ
  syncPreviewToLine(lineNum) {
    const lines = this.editor.value.split('\n');
    let targetHeadingText = null;
    let targetLevel = null;
    let inCodeBlock = false;
    
    // æŒ‡å®šè¡ŒãŒè¦‹å‡ºã—ã‹ãƒã‚§ãƒƒã‚¯
    const currentLine = lines[lineNum];
    if (currentLine && /^#{1,6}\s+/.test(currentLine)) {
      targetHeadingText = currentLine.replace(/^#+\s+/, '').trim();
      targetLevel = currentLine.match(/^(#{1,6})/)[1].length;
    } else {
      // æŒ‡å®šè¡Œä»¥å‰ã§æœ€ã‚‚è¿‘ã„è¦‹å‡ºã—ã‚’æ¢ã™
      for (let i = lineNum; i >= 0; i--) {
        const line = lines[i];
        if (line.trim().startsWith('```')) {
          inCodeBlock = !inCodeBlock;
        }
        if (!inCodeBlock && /^#{1,6}\s+/.test(line)) {
          targetHeadingText = line.replace(/^#+\s+/, '').trim();
          targetLevel = line.match(/^(#{1,6})/)[1].length;
          break;
        }
      }
    }
    
    if (targetHeadingText) {
      // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†…ã§è©²å½“ã™ã‚‹è¦‹å‡ºã—ã‚’æ¢ã—ã¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
      const headings = this.preview.querySelectorAll('h1, h2, h3, h4, h5, h6');
      for (const h of headings) {
        const text = h.textContent.replace(/^[â–¼â–¶]\s*/, '').trim();
        if (text === targetHeadingText) {
          // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å†…ã§ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
          const previewContent = document.getElementById('preview-content');
          const rect = h.getBoundingClientRect();
          const containerRect = previewContent.getBoundingClientRect();
          const scrollOffset = rect.top - containerRect.top + previewContent.scrollTop - 50;
          previewContent.scrollTop = Math.max(0, scrollOffset);
          break;
        }
      }
    }
  },
  
  // ç›®æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
  updateTocActive(lineNum) {
    if (!this.tocContent) return;
    
    const items = this.tocContent.querySelectorAll('.toc-item');
    let activeItem = null;
    
    // ç¾åœ¨è¡Œä»¥å‰ã§æœ€ã‚‚è¿‘ã„è¦‹å‡ºã—ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«
    items.forEach(item => {
      item.classList.remove('active');
      const itemLine = parseInt(item.dataset.line);
      if (itemLine <= lineNum) {
        activeItem = item;
      }
    });
    
    if (activeItem) {
      activeItem.classList.add('active');
      // ç›®æ¬¡å†…ã§ã‚¢ã‚¯ãƒ†ã‚£ãƒ–é …ç›®ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
      activeItem.scrollIntoView({ block: 'nearest' });
    }
  },
  
  // è¦‹å‡ºã—è¡Œã®ãƒã‚¤ãƒ©ã‚¤ãƒˆæ›´æ–°
  // è¦‹å‡ºã—è¡Œã®ãƒã‚¤ãƒ©ã‚¤ãƒˆæ›´æ–°
  updateHeadingHighlight() {
    if (!this.headingHighlight) return;
    
    const lines = this.editor.value.split('\n');
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const paddingTop = parseFloat(getComputedStyle(this.editor).paddingTop);
    const paddingLeft = parseFloat(getComputedStyle(this.editor).paddingLeft);
    const scrollTop = this.editor.scrollTop;
    const scrollLeft = this.editor.scrollLeft;
    
    let html = '';
    let inCodeBlock = false;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      if (line.trim().startsWith('```')) {
        inCodeBlock = !inCodeBlock;
        continue;
      }
      if (inCodeBlock) continue;
      
      const match = line.match(/^(#{1,6})\s+/);
      if (match) {
        const level = match[1].length;
        const top = paddingTop + i * lineHeight - scrollTop;
        
        // ç”»é¢å†…ã®è¡Œã®ã¿è¡¨ç¤º
        if (top > -lineHeight && top < this.editor.clientHeight + lineHeight) {
          // ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
          const escapedLine = line
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
          
          html += `<div class="heading-text-overlay h${level}" style="top: ${top}px; left: ${paddingLeft - scrollLeft}px; height: ${lineHeight}px; line-height: ${lineHeight}px;">${escapedLine}</div>`;
        }
      }
    }
    
    this.headingHighlight.innerHTML = html;
  },
  
  // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è¦‹å‡ºã—æŠ˜ã‚Šç•³ã¿æ©Ÿèƒ½
  setupHeadingFold() {
    const headings = this.preview.querySelectorAll('h1, h2, h3, h4, h5, h6');
    
    headings.forEach(heading => {
      // æŠ˜ã‚Šç•³ã¿ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’è¿½åŠ 
      if (!heading.querySelector('.fold-indicator')) {
        const indicator = document.createElement('span');
        indicator.className = 'fold-indicator';
        indicator.textContent = 'â–¼';
        heading.insertBefore(indicator, heading.firstChild);
      }
      
      // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
      heading.style.cursor = 'pointer';
      heading.onclick = (e) => {
        e.stopPropagation();
        this.toggleHeadingFold(heading);
      };
    });
  },
  
  toggleHeadingFold(heading) {
    const level = parseInt(heading.tagName[1]);
    const indicator = heading.querySelector('.fold-indicator');
    const isFolded = heading.classList.contains('folded');
    
    if (isFolded) {
      // å±•é–‹ã™ã‚‹å ´åˆ - ç›´æ¥ã®å­ãƒ¬ãƒ™ãƒ«ã®ã¿è¡¨ç¤º
      heading.classList.remove('folded');
      indicator.textContent = 'â–¼';
      
      let sibling = heading.nextElementSibling;
      let directChildLevel = null; // ç›´æ¥ã®å­ãƒ¬ãƒ™ãƒ«
      
      while (sibling) {
        if (/^H[1-6]$/.test(sibling.tagName)) {
          const siblingLevel = parseInt(sibling.tagName[1]);
          
          // åŒãƒ¬ãƒ™ãƒ«ä»¥ä¸Šã®è¦‹å‡ºã—ã§åœæ­¢
          if (siblingLevel <= level) break;
          
          // æœ€åˆã«è¦‹ã¤ã‹ã£ãŸå­è¦‹å‡ºã—ã®ãƒ¬ãƒ™ãƒ«ã‚’ç›´æ¥ã®å­ãƒ¬ãƒ™ãƒ«ã¨ã™ã‚‹
          if (directChildLevel === null) {
            directChildLevel = siblingLevel;
          }
          
          // ç›´æ¥ã®å­ãƒ¬ãƒ™ãƒ«ã®è¦‹å‡ºã—ã®ã¿è¡¨ç¤º
          if (siblingLevel === directChildLevel) {
            sibling.style.display = '';
            sibling.classList.remove('heading-hidden');
            // å­è¦‹å‡ºã—ã¯æŠ˜ã‚ŠãŸãŸã¾ã‚ŒãŸçŠ¶æ…‹ã‚’ç¶­æŒ
          }
          // ãã‚Œä»¥å¤–ï¼ˆå­«ä»¥ä¸‹ï¼‰ã¯éè¡¨ç¤ºã®ã¾ã¾
        } else {
          // è¦‹å‡ºã—ä»¥å¤–ã®è¦ç´  - ç›´æ¥ã®å­ãƒ¬ãƒ™ãƒ«ãŒè¦‹ã¤ã‹ã‚‹å‰ãªã‚‰è¡¨ç¤º
          if (directChildLevel === null) {
            sibling.style.display = '';
            sibling.classList.remove('heading-hidden');
          }
        }
        sibling = sibling.nextElementSibling;
      }
    } else {
      // æŠ˜ã‚ŠãŸãŸã‚€å ´åˆ
      heading.classList.add('folded');
      indicator.textContent = 'â–¶';
      
      let sibling = heading.nextElementSibling;
      while (sibling) {
        if (/^H[1-6]$/.test(sibling.tagName)) {
          const siblingLevel = parseInt(sibling.tagName[1]);
          if (siblingLevel <= level) break;
        }
        sibling.style.display = 'none';
        sibling.classList.add('heading-hidden');
        sibling = sibling.nextElementSibling;
      }
    }
  },
  
  // å…¨ã¦ã®è¦‹å‡ºã—ã‚’æŠ˜ã‚ŠãŸãŸã‚€
  foldAllHeadings() {
    const headings = this.preview.querySelectorAll('h1, h2, h3, h4, h5, h6');
    headings.forEach(heading => {
      if (!heading.classList.contains('folded')) {
        this.toggleHeadingFold(heading);
      }
    });
  },
  
  // å…¨ã¦ã®è¦‹å‡ºã—ã‚’å±•é–‹ã™ã‚‹
  unfoldAllHeadings() {
    const headings = this.preview.querySelectorAll('h1, h2, h3, h4, h5, h6');
    // é€†é †ã§å±•é–‹ï¼ˆãƒã‚¹ãƒˆã•ã‚ŒãŸè¦‹å‡ºã—ã‚’æ­£ã—ãå±•é–‹ã™ã‚‹ãŸã‚ï¼‰
    const headingsArray = Array.from(headings).reverse();
    headingsArray.forEach(heading => {
      if (heading.classList.contains('folded')) {
        this.toggleHeadingFold(heading);
      }
    });
  },
  
  renderMermaid() {
    // MermaidãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
    if (typeof mermaid === 'undefined') return;
    
    const mermaidDivs = this.preview.querySelectorAll('.mermaid');
    if (mermaidDivs.length === 0) return;
    
    // å„Mermaidè¦ç´ ã«ãƒ¦ãƒ‹ãƒ¼ã‚¯IDã‚’ä»˜ä¸ã—ã¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    mermaidDivs.forEach((el, i) => {
      el.setAttribute('id', `mermaid-${Date.now()}-${i}`);
    });
    
    try {
      mermaid.run({
        nodes: mermaidDivs
      });
    } catch (e) {
      console.error('Mermaid rendering error:', e);
    }
  },
  
  renderMath() {
    // KaTeXãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
    if (typeof katex === 'undefined') return;
    
    // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³æ•°å¼ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    const inlineMath = this.preview.querySelectorAll('.math-inline');
    inlineMath.forEach(el => {
      const formula = el.getAttribute('data-math');
      try {
        katex.render(formula, el, {
          throwOnError: false,
          displayMode: false
        });
      } catch (e) {
        el.innerHTML = `<span class="math-error">${formula}</span>`;
      }
    });
    
    // ãƒ–ãƒ­ãƒƒã‚¯æ•°å¼ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    const blockMath = this.preview.querySelectorAll('.math-block');
    blockMath.forEach(el => {
      const formula = el.getAttribute('data-math');
      try {
        katex.render(formula, el, {
          throwOnError: false,
          displayMode: true
        });
      } catch (e) {
        el.innerHTML = `<span class="math-error">${formula}</span>`;
      }
    });
  },
  
  syncScroll() {
    const editor = this.editor;
    const preview = document.getElementById('preview-pane');
    const ratio = editor.scrollTop / (editor.scrollHeight - editor.clientHeight || 1);
    preview.scrollTop = ratio * (preview.scrollHeight - preview.clientHeight);
  },
  
  scrollHalfPage(direction) {
    const height = this.editor.clientHeight / 2;
    this.editor.scrollTop += height * direction;
    this.moveCursorToVisibleArea(direction);
  },
  
  scrollFullPage(direction) {
    const height = this.editor.clientHeight;
    this.editor.scrollTop += height * direction;
    this.moveCursorToVisibleArea(direction);
  },
  
  // ã‚«ãƒ¼ã‚½ãƒ«ã‚’è¡¨ç¤ºé ˜åŸŸå†…ã«ç§»å‹•
  moveCursorToVisibleArea(direction) {
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const visibleTop = this.editor.scrollTop;
    const visibleBottom = visibleTop + this.editor.clientHeight;
    
    // ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«è¡Œã‚’è¨ˆç®—
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const linesBeforeCursor = text.substring(0, pos).split('\n').length - 1;
    const cursorTop = linesBeforeCursor * lineHeight;
    
    // ã‚«ãƒ¼ã‚½ãƒ«ãŒè¦‹ãˆãªã„å ´åˆã€è¦‹ãˆã‚‹ä½ç½®ã«ç§»å‹•
    if (cursorTop < visibleTop || cursorTop > visibleBottom - lineHeight) {
      const targetLine = Math.floor((direction > 0 ? visibleTop : visibleBottom - lineHeight) / lineHeight);
      const lines = text.split('\n');
      const clampedLine = Math.max(0, Math.min(targetLine, lines.length - 1));
      
      let newPos = 0;
      for (let i = 0; i < clampedLine; i++) {
        newPos += lines[i].length + 1;
      }
      
      this.editor.selectionStart = newPos;
      this.editor.selectionEnd = newPos;
      this.updateCursorPos();
    }
  },
  
  // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
  scrollToCursor() {
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight);
    const text = this.editor.value;
    const pos = this.editor.selectionStart;
    const linesBeforeCursor = text.substring(0, pos).split('\n').length - 1;
    const cursorTop = linesBeforeCursor * lineHeight;
    
    const visibleTop = this.editor.scrollTop;
    const visibleBottom = visibleTop + this.editor.clientHeight;
    
    // ã‚«ãƒ¼ã‚½ãƒ«ãŒè¦‹ãˆãªã„å ´åˆã€ä¸­å¤®ä»˜è¿‘ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
    if (cursorTop < visibleTop) {
      this.editor.scrollTop = cursorTop - this.editor.clientHeight / 4;
    } else if (cursorTop > visibleBottom - lineHeight * 2) {
      this.editor.scrollTop = cursorTop - this.editor.clientHeight * 3 / 4;
    }
  },
  
  showStatus(msg) {
    const status = document.getElementById('help-hint');
    status.textContent = msg;
    setTimeout(() => { status.textContent = '? ã§ãƒ˜ãƒ«ãƒ—'; }, 2500);
  }
};

function setViewMode(mode) {
  const container = document.getElementById('main-container');
  
  // ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®ã¿ã‚’å¯¾è±¡ã«ã™ã‚‹
  ['edit', 'preview', 'split'].forEach(m => {
    document.getElementById('btn-' + m).classList.remove('active');
  });
  document.getElementById('btn-' + mode).classList.add('active');
  
  container.classList.remove('edit-only', 'preview-only', 'split-view');
  
  if (mode === 'edit') container.classList.add('edit-only');
  else if (mode === 'preview') container.classList.add('preview-only');
  else container.classList.add('split-view');
  
  VimEditor.editor.focus();
}

function setTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme);
  
  // ãƒ†ãƒ¼ãƒãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
  ['dark', 'light', 'original'].forEach(t => {
    const btn = document.getElementById('btn-theme-' + t);
    if (btn) btn.classList.remove('active');
  });
  const activeBtn = document.getElementById('btn-theme-' + theme);
  if (activeBtn) activeBtn.classList.add('active');
  
  // ãƒ†ãƒ¼ãƒè¨­å®šã‚’ä¿å­˜
  localStorage.setItem('vim-md-theme', theme);
  
  // VimEditorãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚Œã°é€šçŸ¥
  if (typeof VimEditor !== 'undefined' && VimEditor.showStatus) {
    VimEditor.showStatus(`ãƒ†ãƒ¼ãƒ: ${theme}`);
  }
}

function loadTheme() {
  const saved = localStorage.getItem('vim-md-theme');
  if (saved && ['dark', 'light', 'original'].includes(saved)) {
    document.documentElement.setAttribute('data-theme', saved);
    // ãƒœã‚¿ãƒ³ã®æ›´æ–°ï¼ˆDOMãŒæº–å‚™ã§ãã¦ã„ã‚‹å ´åˆï¼‰
    const btn = document.getElementById('btn-theme-' + saved);
    if (btn) {
      ['dark', 'light', 'original'].forEach(t => {
        const b = document.getElementById('btn-theme-' + t);
        if (b) b.classList.remove('active');
      });
      btn.classList.add('active');
    }
  }
}

function toggleHelp() {
  document.getElementById('help-modal').classList.toggle('hidden');
  if (document.getElementById('help-modal').classList.contains('hidden')) {
    VimEditor.editor.focus();
  }
}

document.addEventListener('DOMContentLoaded', () => {
  loadTheme();
  VimEditor.init();
  VimEditor.editor.focus();
});

window.addEventListener('beforeunload', e => {
  if (VimEditor.modified) {
    e.preventDefault();
    e.returnValue = '';
  }
});
  </script>
</body>
<!-- KaTeX JS -->
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<!-- Mermaid JS -->
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<!-- Highlight.js -->
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
<script>
  mermaid.initialize({ 
    startOnLoad: false,
    theme: 'dark',
    securityLevel: 'loose'
  });
</script>
</html>
